This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-19T16:02:11.846Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
- Pay special attention to the Repository Instruction. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>
<user_provided_header>
This repository contains the source code for the Repomix tool.
Repomix is designed to pack repository contents into a single file,
making it easier for AI systems to analyze and process the codebase.

Key Features:
- Configurable ignore patterns
- Custom header text support
- Efficient file processing and packing

Please refer to the README.md file for more detailed information on usage and configuration.

</user_provided_header>

</additional_info>

</file_summary>

<directory_structure>
.devcontainer/
  devcontainer.json
.github/
  workflows/
    ci.yml
    codeql.yml
    docker.yml
    homebrew.yml
  copilot-instructions.md
  dependabot.yml
  FUNDING.yml
  pull_request_template.md
  renovate.json5
.memo/
  commit-message.md
bin/
  repomix.cjs
scripts/
src/
  cli/
    actions/
      defaultAction.ts
      initAction.ts
      migrationAction.ts
      remoteAction.ts
      versionAction.ts
    cliPrint.ts
    cliRun.ts
    cliSpinner.ts
  config/
    configLoad.ts
    configSchema.ts
    defaultIgnore.ts
    globalDirectory.ts
  core/
    file/
      fileCollect.ts
      fileManipulate.ts
      filePathSort.ts
      fileProcess.ts
      fileSearch.ts
      fileTreeGenerate.ts
      fileTypes.ts
      gitCommand.ts
      packageJsonParse.ts
      permissionCheck.ts
    metrics/
      aggregateMetrics.ts
      calculateAllFileMetrics.ts
      calculateIndividualFileMetrics.ts
      calculateMetrics.ts
    output/
      outputStyles/
        markdownStyle.ts
        plainStyle.ts
        xmlStyle.ts
      outputGenerate.ts
      outputGeneratorTypes.ts
      outputStyleDecorate.ts
    packager/
      copyToClipboardIfEnabled.ts
      writeOutputToDisk.ts
    parser/
    security/
      filterOutUntrustedFiles.ts
      runSecurityCheckIfEnabled.ts
      securityCheck.ts
      validateFileSafety.ts
    tokenCount/
      tokenCount.ts
    packager.ts
  shared/
    errorHandle.ts
    logger.ts
    processConcurrency.ts
    types.ts
  index.ts
tests/
  cli/
    actions/
      defaultAction.test.ts
      initAction.test.ts
      migrationAction.test.ts
      remoteAction.test.ts
      versionAction.test.ts
    cliPrint.test.ts
    cliRun.test.ts
  config/
    configLoad.test.ts
    configSchema.test.ts
    globalDirectory.test.ts
  core/
    file/
      fileCollect.test.ts
      fileManipulate.test.ts
      filePathSort.test.ts
      fileProcess.test.ts
      fileSearch.test.ts
      gitCommand.test.ts
      packageJsonParse.test.ts
      permissionCheck.test.ts
    metrics/
      aggregateMetrics.test.ts
      calculateAllFileMetrics.test.ts
      calculateIndividualFileMetrics.test.ts
      calculateMetrics.test.ts
    output/
      outputStyles/
        markdownStyle.test.ts
        plainStyle.test.ts
        xmlStyle.test.ts
      outputGenerate.test.ts
    packager/
      copyToClipboardIfEnabled.test.ts
      writeOutputToDisk.test.ts
    security/
      filterOutUntrustedFiles.test.ts
      runSecurityCheckIfEnabled.test.ts
      securityCheck.test.ts
      validateFileSafety.test.ts
    tokenCount/
      tokenCount.test.ts
    packager.test.ts
  integration-tests/
    packager.test.ts
  shared/
    logger.test.ts
  testing/
    testUtils.ts
website/
  client/
    .vitepress/
      config/
        configEnUs.ts
        configEs.ts
        configJa.ts
        configKo.ts
        configPtBr.ts
        configShard.ts
        configZhCn.ts
      theme/
        component.d.ts
        custom.css
        index.ts
        style.css
      config.ts
    components/
      api/
        client.ts
      utils/
        analytics.ts
      Hero.vue
      Home.vue
      ResultViewer.vue
      TryIt.vue
    composables/
    guide/
    src/
      de/
      en/
        guide/
          development/
            index.md
            setup.md
          tips/
            best-practices.md
          command-line-options.md
          comment-removal.md
          configuration.md
          custom-instructions.md
          index.md
          installation.md
          output.md
          prompt-examples.md
          remote-repository-processing.md
          security.md
          usage.md
        index.md
      es/
        guide/
          development/
            index.md
            setup.md
          tips/
            best-practices.md
          command-line-options.md
          comment-removal.md
          configuration.md
          custom-instructions.md
          index.md
          installation.md
          output.md
          prompt-examples.md
          remote-repository-processing.md
          security.md
          usage.md
        index.md
      ja/
        guide/
          development/
            index.md
            setup.md
          tips/
            best-practices.md
          command-line-options.md
          comment-removal.md
          configuration.md
          custom-instructions.md
          index.md
          installation.md
          output.md
          prompt-examples.md
          remote-repository-processing.md
          security.md
          usage.md
        index.md
      ko/
        guide/
          development/
            index.md
            setup.md
          tips/
            best-practices.md
          command-line-options.md
          comment-removal.md
          configuration.md
          custom-instructions.md
          index.md
          installation.md
          output.md
          prompt-examples.md
          remote-repository-processing.md
          security.md
          usage.md
        index.md
      pt-br/
        guide/
          development/
            index.md
            setup.md
          tips/
            best-practices.md
          command-line-options.md
          comment-removal.md
          configuration.md
          custom-instructions.md
          index.md
          installation.md
          output.md
          prompt-examples.md
          remote-repository-processing.md
          security.md
          usage.md
        index.md
      public/
        images/
          repomix-logo.svg
      zh-cn/
        guide/
          development/
            index.md
            setup.md
          tips/
            best-practices.md
          command-line-options.md
          comment-removal.md
          configuration.md
          custom-instructions.md
          index.md
          installation.md
          output.md
          prompt-examples.md
          remote-repository-processing.md
          security.md
          usage.md
        index.md
    .gitignore
    .tool-versions
    Dockerfile
    package.json
    tsconfig.json
    tsconfig.node.json
  server/
    src/
      schemas/
        request.ts
      utils/
        cache.ts
        errorHandler.ts
        rateLimit.ts
        validation.ts
      index.ts
      remoteRepo.ts
      types.ts
    .dockerignore
    .gitignore
    cloudbuild.yaml
    Dockerfile
    package.json
    tsconfig.json
  compose.yml
.codecov.yml
.dockerignore
.editorconfig
.gitignore
.node-version
.npmignore
.repomixignore
.secretlintrc.json
.tool-versions
biome.json
CODE_OF_CONDUCT.md
CONTRIBUTING.md
Dockerfile
LICENSE
package.json
README.md
repomix-instruction.md
repomix.config.json
SECURITY.md
tsconfig.build.json
tsconfig.json
typos.toml
vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".devcontainer/devcontainer.json">
{
  "name": "Repomix",
  "image": "mcr.microsoft.com/devcontainers/typescript-node:1-22-bullseye",
  "runArgs": ["--name", "repomix-devcontainer"],
  "postCreateCommand": "npm install"
}
</file>

<file path=".github/workflows/ci.yml">
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  lint-biome:
    name: Lint Biome
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-node@v4
      with:
        node-version-file: .tool-versions
        cache: npm
    - run: npm ci
    - run: npm run lint-biome && git diff --exit-code

  lint-ts:
    name: Lint TypeScript
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-node@v4
      with:
        node-version-file: .tool-versions
        cache: npm
    - run: npm ci
    - run: npm run lint-ts

  lint-secretlint:
    name: Lint Secretlint
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-node@v4
      with:
        node-version-file: .tool-versions
        cache: npm
    - run: npm ci
    - run: npm run lint-secretlint

  lint-action:
    name: Lint GitHub Actions
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: docker://rhysd/actionlint:latest
        with:
          args: "-color"

  check-npm-audit:
    name: Check npm audit
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-node@v4
      with:
        node-version-file: .tool-versions
        cache: npm
    - run: npm audit

  check-typos:
    name: Check typos
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: crate-ci/typos@master

  test:
    name: Test
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        node-version: [18.0.0, 18.x, 19.x, 20.x, 21.x, 22.x, 23.x]
    runs-on: ${{ matrix.os }}
    steps:
    - uses: actions/checkout@v4
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
    - run: npm ci
    - run: npm run test --reporter=verbose
      env:
        CI_OS: ${{ runner.os }}

  test-coverage:
    name: Test coverage
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-node@v4
      with:
        node-version-file: .tool-versions
        cache: npm
    - run: npm ci
    - run: npm run test-coverage -- --reporter=verbose
      env:
        CI_OS: ${{ runner.os }}
    - uses: actions/upload-artifact@v4
      with:
        name: test-coverage
        path: coverage/
    - uses: codecov/codecov-action@v5
      with:
        fail_ci_if_error: true
        directory: ./coverage
      env:
        CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

  build-and-run:
    name: Build and run
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        node-version: [18.0.0, 18.x, 19.x, 20.x, 21.x, 22.x, 23.x]
    runs-on: ${{ matrix.os }}
    steps:
    - uses: actions/checkout@v4
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
    - run: npm ci
    - run: npm run build
    - name: Install only production dependencies
      run: npm ci --omit=dev
    - run: node bin/repomix.cjs
    - run: node bin/repomix.cjs --version
    - run: node bin/repomix.cjs --help
    - name: Upload build artifact
      uses: actions/upload-artifact@v4
      with:
        name: repomix-output-${{ matrix.os }}-${{ matrix.node-version }}.txt
        path: repomix-output.txt
</file>

<file path=".github/workflows/codeql.yml">
name: "CodeQL"

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  schedule:
    - cron: '25 11 * * 0'

jobs:
  analyze:
    name: Analyze (${{ matrix.language }})
    runs-on: ${{ (matrix.language == 'swift' && 'macos-latest') || 'ubuntu-latest' }}
    permissions:
      security-events: write
      packages: read
      actions: read
      contents: read

    strategy:
      fail-fast: false
      matrix:
        include:
        - language: javascript-typescript
          build-mode: none
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    # Initializes the CodeQL tools for scanning.
    - name: Initialize CodeQL
      uses: github/codeql-action/init@v3
      with:
        languages: ${{ matrix.language }}
        build-mode: ${{ matrix.build-mode }}

    - if: matrix.build-mode == 'manual'
      shell: bash
      run: |
        echo 'If you are using a "manual" build mode for one or more of the' \
          'languages you are analyzing, replace this with the commands to build' \
          'your code, for example:'
        echo '  make bootstrap'
        echo '  make release'
        exit 1

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v3
      with:
        category: "/language:${{matrix.language}}"
</file>

<file path=".github/workflows/docker.yml">
name: Docker

on:
  push:
    branches:
      - "main"
    paths-ignore:
      - "**.md"
      - LICENSE
  pull_request:
    branches:
      - "*"
    paths:
      - "Dockerfile"
      - ".dockerignore"
      - ".github/workflows/docker.yml"
  workflow_dispatch:
  release:
    types: [published, edited]

permissions:
  contents: read
  packages: write

jobs:
  build-and-publish-image:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ghcr.io/yamadashy/repomix
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}
            type=semver,pattern={{major}}.{{minor}}
            type=raw,value=latest,enable=${{ github.event_name == 'release' }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and Publish Docker Image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: ${{ github.event_name != 'pull_request' }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64,linux/arm/v7
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
</file>

<file path=".github/workflows/homebrew.yml">
name: Homebrew

on:
  release:
    types:
      - created

jobs:
  homebrew:
    runs-on: macos-latest
    steps:
      - name: Set up Homebrew
        uses: Homebrew/actions/setup-homebrew@master
        with:
          test-bot: false

      - name: Configure Git user
        uses: Homebrew/actions/git-user-config@master

      - name: Bump packages
        uses: Homebrew/actions/bump-packages@master
        with:
          token: ${{ secrets.COMMITTER_TOKEN }}
          formulae: repomix
</file>

<file path=".github/copilot-instructions.md">
# Coding Guidelines
- Follow the Airbnb JavaScript Style Guide
- Suggest splitting files into smaller, focused units when appropriate
  - Keep code files under 250 lines, if the file is over 250 lines, split it into multiple files based on the functionality.
- Add comments for non-obvious logic. Keep all text in English
- All new features should have corresponding unit tests

## Dependencies and Testing
- Inject dependencies through a deps object parameter for testability
- Example:
  ```typescript
  export const functionName = async (
    param1: Type1,
    param2: Type2,
    deps = {
      defaultFunction1,
      defaultFunction2,
    }
  ) => {
    // Use deps.defaultFunction1() instead of direct call
  };
  ```
- Mock dependencies by passing test doubles through deps object
- Use vi.mock() only when dependency injection is not feasible
</file>

<file path=".github/dependabot.yml">
version: 2
updates:
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "daily"
</file>

<file path=".github/FUNDING.yml">
github: yamadashy
</file>

<file path=".github/pull_request_template.md">
<!-- Please include a summary of the changes -->

## Checklist

- [ ] Run `npm run test`
- [ ] Run `npm run lint`
</file>

<file path=".github/renovate.json5">
{
  "$schema": "https://docs.renovatebot.com/renovate-schema.json",
  "extends": [
    "config:recommended",
    "schedule:weekly",
    'group:allNonMajor'
  ],
  "rangeStrategy": "bump",
  "dependencyDashboard": false,
  "labels": ["dependencies", "renovate"],
  "packageRules": [
    {
      matchDepTypes: ['peerDependencies'],
      enabled: false,
    },
  ],
  "ignoreDeps": [
    "node",
  ]
}
</file>

<file path=".memo/commit-message.md">
コミットメッセージをcopilotで出力する用のファイル。
Conventional Commits に従うこと。

# 変更内容とコミットメッセージ
私がここに日本語で書きます。
```
feat(cli): parsableStyleのCLIフラグは、他のフラグに合わせてkebab-caseにする
```

上記を英語に翻訳してください。下の既存のコミットメッセージも参考にしてください。
```
feat(cli): change parsableStyle CLI flag to kebab-case to match other flags
```

# コミットメッセージの参考になるログ
`git log --oneline` の一部

```
4b628e1 chore(website): Add .tool-versions to specify Node.js version for Cloudflare Pages
76d625e feat: enhance repository name validation and expose validation function
429081b docs(readme): add Gitingest as an alternative tool for Python users
9ecb902 docs(readme): Improve Discord section and add icons to headings in README
76904c9 feat(website): Add configurable token count encoding and change default to o200k_base
a40b2d7 feat(fileSearch): use config.cwd instead of process.cwd() for better testability
5ce74ca feat(website): Swap navigation link positions for better visibility
3d7ffbe Merge pull request #249 from yamadashy/feat/website-include-pattern
42401bb feat(cli): Add CLI flags for controlling output sections and content processing
b453f3d fix(instruction): use current working directory for instruction file path
d4614ce Merge pull request #230 from yamadashy/chore/separate-docker-commands-for-easier-copy
145e5af docs(readme): Separate docker commands for easier copy & paste
2c7f84d feat(docker): Provide repomix as a globally available tool in the Docker image
8db9f95 feat(output): Add options to control file summary and directory structure output
09b6c57 refactor(core): extract git commands to core module and improve dependency injection
216cbbe docs: updated example config to match with new feat + minor clarification for config explanation
c6a9a86 feat(initAction): Improve init process: Select output style before file path
8c940fd Merge remote-tracking branch 'origin/main' into feature/remove-python-docstrings
a5f00e7 fix(command): remove unsafe flag from biome commands and fix cliRunner default params
0d8016e refactor(structure): Reorganize project file structure for improved modularity
9ebeed4 fix(ignore): Fix .gitignore/.repopackignore compliance and improve file filtering logic
8d7023a feat(config): Add include functionality and enhance file filtering with glob support
161944a fix(processFile): remove empty line is not working in some parts using remove comments option
```
</file>

<file path="bin/repomix.cjs">
#!/usr/bin/env node

const nodeVersion = process.versions.node;
const [major] = nodeVersion.split('.').map(Number);

const EXIT_CODES = {
  SUCCESS: 0,
  ERROR: 1,
};

if (major < 16) {
  console.error(`Repomix requires Node.js version 16 or higher. Current version: ${nodeVersion}\n`);
  process.exit(EXIT_CODES.ERROR);
}

function setupErrorHandlers() {
  process.on('uncaughtException', (error) => {
    console.error('Uncaught Exception:', error);
    process.exit(EXIT_CODES.ERROR);
  });

  process.on('unhandledRejection', (reason) => {
    console.error('Unhandled Promise Rejection:', reason);
    process.exit(EXIT_CODES.ERROR);
  });

  function shutdown() {
    process.exit(EXIT_CODES.SUCCESS);
  }

  process.on('SIGINT', () => {
    console.log('\nReceived SIGINT. Shutting down...');
    shutdown();
  });
  process.on('SIGTERM', shutdown);
}

(async () => {
  try {
    setupErrorHandlers();

    const { run } = await import('../lib/cli/cliRun.js');
    await run();
  } catch (error) {
    if (error instanceof Error) {
      console.error('Fatal Error:', {
        name: error.name,
        message: error.message,
        stack: error.stack,
      });
    } else {
      console.error('Fatal Error:', error);
    }

    process.exit(EXIT_CODES.ERROR);
  }
})();
</file>

<file path="src/cli/actions/defaultAction.ts">
import path from 'node:path';
import { loadFileConfig, mergeConfigs } from '../../config/configLoad.js';
import {
  type RepomixConfigCli,
  type RepomixConfigFile,
  type RepomixConfigMerged,
  type RepomixOutputStyle,
  repomixConfigCliSchema,
} from '../../config/configSchema.js';
import { type PackResult, pack } from '../../core/packager.js';
import { rethrowValidationErrorIfZodError } from '../../shared/errorHandle.js';
import { logger } from '../../shared/logger.js';
import { printCompletion, printSecurityCheck, printSummary, printTopFiles } from '../cliPrint.js';
import type { CliOptions } from '../cliRun.js';
import Spinner from '../cliSpinner.js';
import { runMigrationAction } from './migrationAction.js';

export interface DefaultActionRunnerResult {
  packResult: PackResult;
  config: RepomixConfigMerged;
}

export const runDefaultAction = async (
  directory: string,
  cwd: string,
  options: CliOptions,
): Promise<DefaultActionRunnerResult> => {
  logger.trace('Loaded CLI options:', options);

  // Run migration before loading config
  await runMigrationAction(cwd);

  // Load the config file
  const fileConfig: RepomixConfigFile = await loadFileConfig(cwd, options.config ?? null);
  logger.trace('Loaded file config:', fileConfig);

  // Parse the CLI options into a config
  const cliConfig: RepomixConfigCli = buildCliConfig(options);
  logger.trace('CLI config:', cliConfig);

  // Merge default, file, and CLI configs
  const config: RepomixConfigMerged = mergeConfigs(cwd, fileConfig, cliConfig);

  logger.trace('Merged config:', config);

  const targetPath = path.resolve(directory);

  const spinner = new Spinner('Packing files...');
  spinner.start();

  let packResult: PackResult;

  try {
    packResult = await pack(targetPath, config, (message) => {
      spinner.update(message);
    });
  } catch (error) {
    spinner.fail('Error during packing');
    throw error;
  }

  spinner.succeed('Packing completed successfully!');
  logger.log('');

  if (config.output.topFilesLength > 0) {
    printTopFiles(packResult.fileCharCounts, packResult.fileTokenCounts, config.output.topFilesLength);
    logger.log('');
  }

  printSecurityCheck(cwd, packResult.suspiciousFilesResults, config);
  logger.log('');

  printSummary(
    packResult.totalFiles,
    packResult.totalCharacters,
    packResult.totalTokens,
    config.output.filePath,
    packResult.suspiciousFilesResults,
    config,
  );
  logger.log('');

  printCompletion();

  return {
    packResult,
    config,
  };
};

const buildCliConfig = (options: CliOptions): RepomixConfigCli => {
  const cliConfig: RepomixConfigCli = {};

  if (options.output) {
    cliConfig.output = { filePath: options.output };
  }
  if (options.include) {
    cliConfig.include = options.include.split(',');
  }
  if (options.ignore) {
    cliConfig.ignore = { customPatterns: options.ignore.split(',') };
  }
  if (options.topFilesLen !== undefined) {
    cliConfig.output = { ...cliConfig.output, topFilesLength: options.topFilesLen };
  }
  if (options.outputShowLineNumbers !== undefined) {
    cliConfig.output = { ...cliConfig.output, showLineNumbers: options.outputShowLineNumbers };
  }
  if (options.copy) {
    cliConfig.output = { ...cliConfig.output, copyToClipboard: options.copy };
  }
  if (options.style) {
    cliConfig.output = { ...cliConfig.output, style: options.style.toLowerCase() as RepomixOutputStyle };
  }
  if (options.parsableStyle !== undefined) {
    cliConfig.output = { ...cliConfig.output, parsableStyle: options.parsableStyle };
  }
  if (options.securityCheck !== undefined) {
    cliConfig.security = { enableSecurityCheck: options.securityCheck };
  }
  if (options.fileSummary !== undefined) {
    cliConfig.output = { ...cliConfig.output, fileSummary: options.fileSummary };
  }
  if (options.directoryStructure !== undefined) {
    cliConfig.output = { ...cliConfig.output, directoryStructure: options.directoryStructure };
  }
  if (options.removeComments !== undefined) {
    cliConfig.output = { ...cliConfig.output, removeComments: options.removeComments };
  }
  if (options.removeEmptyLines !== undefined) {
    cliConfig.output = { ...cliConfig.output, removeEmptyLines: options.removeEmptyLines };
  }
  if (options.tokenCountEncoding) {
    cliConfig.tokenCount = { encoding: options.tokenCountEncoding };
  }

  try {
    return repomixConfigCliSchema.parse(cliConfig);
  } catch (error) {
    rethrowValidationErrorIfZodError(error, 'Invalid cli arguments');
    throw error;
  }
};
</file>

<file path="src/cli/actions/initAction.ts">
import fs from 'node:fs/promises';
import path from 'node:path';
import * as prompts from '@clack/prompts';
import pc from 'picocolors';
import {
  type RepomixConfigFile,
  type RepomixOutputStyle,
  defaultConfig,
  defaultFilePathMap,
} from '../../config/configSchema.js';
import { getGlobalDirectory } from '../../config/globalDirectory.js';
import { logger } from '../../shared/logger.js';

const onCancelOperation = () => {
  prompts.cancel('Initialization cancelled.');
  process.exit(0);
};

export const runInitAction = async (rootDir: string, isGlobal: boolean): Promise<void> => {
  prompts.intro(pc.bold(`Welcome to Repomix ${isGlobal ? 'Global ' : ''}Configuration!`));

  try {
    // Step 1: Ask if user wants to create a config file
    const isCreatedConfig = await createConfigFile(rootDir, isGlobal);

    // Step 2: Ask if user wants to create a .repomixignore file
    const isCreatedIgnoreFile = await createIgnoreFile(rootDir, isGlobal);

    if (!isCreatedConfig && !isCreatedIgnoreFile) {
      prompts.outro(
        pc.yellow('No files were created. You can run this command again when you need to create configuration files.'),
      );
    } else {
      prompts.outro(pc.green('Initialization complete! You can now use Repomix with your specified settings.'));
    }
  } catch (error) {
    logger.error('An error occurred during initialization:', error);
  }
};

export const createConfigFile = async (rootDir: string, isGlobal: boolean): Promise<boolean> => {
  const configPath = path.resolve(isGlobal ? getGlobalDirectory() : rootDir, 'repomix.config.json');

  const isCreateConfig = await prompts.confirm({
    message: `Do you want to create a ${isGlobal ? 'global ' : ''}${pc.green('repomix.config.json')} file?`,
  });
  if (!isCreateConfig) {
    prompts.log.info(`Skipping ${pc.green('repomix.config.json')} file creation.`);
    return false;
  }
  if (prompts.isCancel(isCreateConfig)) {
    onCancelOperation();
    return false;
  }

  let isConfigFileExists = false;
  try {
    await fs.access(configPath);
    isConfigFileExists = true;
  } catch {
    // File doesn't exist, so we can proceed
  }

  if (isConfigFileExists) {
    const isOverwrite = await prompts.confirm({
      message: `A ${isGlobal ? 'global ' : ''}${pc.green('repomix.config.json')} file already exists. Do you want to overwrite it?`,
    });
    if (!isOverwrite) {
      prompts.log.info(`Skipping ${pc.green('repomix.config.json')} file creation.`);
      return false;
    }
    if (prompts.isCancel(isOverwrite)) {
      onCancelOperation();
      return false;
    }
  }

  const options = await prompts.group(
    {
      outputStyle: () => {
        return prompts.select({
          message: 'Output style:',
          options: [
            { value: 'plain', label: 'Plain', hint: 'Simple text format' },
            { value: 'xml', label: 'XML', hint: 'Structured XML format' },
            { value: 'markdown', label: 'Markdown', hint: 'Markdown format' },
          ],
          initialValue: defaultConfig.output.style,
        });
      },
      outputFilePath: ({ results }) => {
        const defaultFilePath = defaultFilePathMap[results.outputStyle as RepomixOutputStyle];
        return prompts.text({
          message: 'Output file path:',
          initialValue: defaultFilePath,
          validate: (value) => (value.length === 0 ? 'Output file path is required' : undefined),
        });
      },
    },
    {
      onCancel: onCancelOperation,
    },
  );

  const config: RepomixConfigFile = {
    ...defaultConfig,
    output: {
      ...defaultConfig.output,
      filePath: options.outputFilePath as string,
      style: options.outputStyle as RepomixOutputStyle,
    },
  };

  await fs.mkdir(path.dirname(configPath), { recursive: true });
  await fs.writeFile(configPath, JSON.stringify(config, null, 2));

  const relativeConfigPath = path.relative(rootDir, configPath);

  prompts.log.success(
    pc.green(`${isGlobal ? 'Global config' : 'Config'} file created!\n`) + pc.dim(`Path: ${relativeConfigPath}`),
  );

  return true;
};

export const createIgnoreFile = async (rootDir: string, isGlobal: boolean): Promise<boolean> => {
  if (isGlobal) {
    prompts.log.info(`Skipping ${pc.green('.repomixignore')} file creation for global configuration.`);
    return false;
  }

  const ignorePath = path.resolve(rootDir, '.repomixignore');
  const createIgnore = await prompts.confirm({
    message: `Do you want to create a ${pc.green('.repomixignore')} file?`,
  });
  if (!createIgnore) {
    prompts.log.info(`Skipping ${pc.green('.repomixignore')} file creation.`);
    return false;
  }
  if (prompts.isCancel(createIgnore)) {
    onCancelOperation();
    return false;
  }

  let isIgnoreFileExists = false;
  try {
    await fs.access(ignorePath);
    isIgnoreFileExists = true;
  } catch {
    // File doesn't exist, so we can proceed
  }

  if (isIgnoreFileExists) {
    const overwrite = await prompts.confirm({
      message: `A ${pc.green('.repomixignore')} file already exists. Do you want to overwrite it?`,
    });

    if (!overwrite) {
      prompts.log.info(`${pc.green('.repomixignore')} file creation skipped. Existing file will not be modified.`);
      return false;
    }
  }

  const defaultIgnoreContent = `# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/
`;

  await fs.writeFile(ignorePath, defaultIgnoreContent);
  prompts.log.success(
    pc.green('Created .repomixignore file!\n') + pc.dim(`Path: ${path.relative(rootDir, ignorePath)}`),
  );

  return true;
};
</file>

<file path="src/cli/actions/migrationAction.ts">
import * as fs from 'node:fs/promises';
import path from 'node:path';
import * as prompts from '@clack/prompts';
import pc from 'picocolors';
import { getGlobalDirectory } from '../../config/globalDirectory.js';
import { logger } from '../../shared/logger.js';

interface MigrationPaths {
  oldConfigPath: string;
  newConfigPath: string;
  oldIgnorePath: string;
  newIgnorePath: string;
  oldInstructionPath: string;
  newInstructionPath: string;
  oldOutputPaths: string[];
  newOutputPaths: string[];
  oldGlobalConfigPath: string;
  newGlobalConfigPath: string;
}

interface MigrationResult {
  configMigrated: boolean;
  ignoreMigrated: boolean;
  instructionMigrated: boolean;
  outputFilesMigrated: string[];
  globalConfigMigrated: boolean;
  error?: Error;
}

/**
 * Check if a file exists at the given path
 */
const fileExists = async (filePath: string): Promise<boolean> => {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
};

/**
 * Replace all occurrences of 'repopack' with 'repomix' in a string
 */
const replaceRepopackString = (content: string): string => {
  return content.replace(/repopack/g, 'repomix').replace(/Repopack/g, 'Repomix');
};

/**
 * Update file content by replacing 'repopack' with 'repomix'
 */
const updateFileContent = async (filePath: string): Promise<boolean> => {
  const content = await fs.readFile(filePath, 'utf8');
  const updatedContent = replaceRepopackString(content);

  // Check if content needs to be updated
  if (content !== updatedContent) {
    await fs.writeFile(filePath, updatedContent, 'utf8');
    const relativePath = path.relative(process.cwd(), filePath);
    logger.log(`Updated repopack references in ${pc.cyan(relativePath)}`);
    return true;
  }

  return false;
};

/**
 * Parse JSON content, update instructionFilePath if exists
 */
const updateInstructionPath = (content: string): string => {
  try {
    const config = JSON.parse(content);
    if (config.output?.instructionFilePath) {
      config.output.instructionFilePath = config.output.instructionFilePath.replace('repopack', 'repomix');
    }
    // Also update output.filePath if it exists
    if (config.output?.filePath) {
      config.output.filePath = config.output.filePath.replace('repopack', 'repomix');
    }
    return JSON.stringify(config, null, 2);
  } catch {
    return content;
  }
};

/**
 * Get output file paths pairs
 */
const getOutputFilePaths = (rootDir: string): { oldPaths: string[]; newPaths: string[] } => {
  const extensions = ['.txt', '.xml', '.md'];
  const oldPaths = extensions.map((ext) => path.join(rootDir, `repopack-output${ext}`));
  const newPaths = extensions.map((ext) => path.join(rootDir, `repomix-output${ext}`));
  return { oldPaths, newPaths };
};

/**
 * Migrate a single file from old path to new path
 */
const migrateFile = async (
  oldPath: string,
  newPath: string,
  description: string,
  isConfig = false,
): Promise<boolean> => {
  if (!(await fileExists(oldPath))) {
    return false;
  }

  const exists = await fileExists(newPath);
  if (exists) {
    const shouldOverwrite = await prompts.confirm({
      message: `${description} already exists at ${newPath}. Do you want to overwrite it?`,
    });

    if (prompts.isCancel(shouldOverwrite) || !shouldOverwrite) {
      logger.info(`Skipping migration of ${description}`);
      return false;
    }
  }

  try {
    // Read and update content
    let content = await fs.readFile(oldPath, 'utf8');
    content = replaceRepopackString(content);

    // For config files, also update instructionFilePath and output.filePath
    if (isConfig) {
      content = updateInstructionPath(content);
    }

    // Ensure the target directory exists
    await fs.mkdir(path.dirname(newPath), { recursive: true });

    // Write to new file
    await fs.writeFile(newPath, content, 'utf8');

    // Remove old file
    await fs.unlink(oldPath);

    const relativeOldPath = path.relative(process.cwd(), oldPath);
    const relativeNewPath = path.relative(process.cwd(), newPath);

    logger.log(`Renamed ${description} from ${relativeOldPath} to ${relativeNewPath}`);
    return true;
  } catch (error) {
    logger.error(`Failed to migrate ${description}:`, error);
    return false;
  }
};

/**
 * Update content of gitignore and repomixignore files
 */
const updateIgnoreFiles = async (rootDir: string): Promise<void> => {
  const gitignorePath = path.join(rootDir, '.gitignore');
  const repomixignorePath = path.join(rootDir, '.repomixignore');

  if (await fileExists(gitignorePath)) {
    const updated = await updateFileContent(gitignorePath);
    if (!updated) {
      logger.debug('No changes needed in .gitignore');
    }
  }

  if (await fileExists(repomixignorePath)) {
    const updated = await updateFileContent(repomixignorePath);
    if (!updated) {
      logger.debug('No changes needed in .repomixignore');
    }
  }
};

/**
 * Get all migration related file paths
 */
const getMigrationPaths = (rootDir: string): MigrationPaths => {
  const { oldPaths: oldOutputPaths, newPaths: newOutputPaths } = getOutputFilePaths(rootDir);
  const oldGlobalDirectory = path.join(process.env.HOME || '', '.config', 'repopack');
  const newGlobalDirectory = getGlobalDirectory();

  return {
    oldConfigPath: path.join(rootDir, 'repopack.config.json'),
    newConfigPath: path.join(rootDir, 'repomix.config.json'),
    oldIgnorePath: path.join(rootDir, '.repopackignore'),
    newIgnorePath: path.join(rootDir, '.repomixignore'),
    oldInstructionPath: path.join(rootDir, 'repopack-instruction.md'),
    newInstructionPath: path.join(rootDir, 'repomix-instruction.md'),
    oldOutputPaths,
    newOutputPaths,
    oldGlobalConfigPath: path.join(oldGlobalDirectory, 'repopack.config.json'),
    newGlobalConfigPath: path.join(newGlobalDirectory, 'repomix.config.json'),
  };
};

/**
 * Migrate output files
 */
const migrateOutputFiles = async (oldPaths: string[], newPaths: string[]): Promise<string[]> => {
  const migratedFiles: string[] = [];

  for (let i = 0; i < oldPaths.length; i++) {
    const oldPath = oldPaths[i];
    const newPath = newPaths[i];
    const ext = path.extname(oldPath);

    if (await migrateFile(oldPath, newPath, `Output file (${ext})`)) {
      migratedFiles.push(newPath);
    }
  }

  return migratedFiles;
};

export const runMigrationAction = async (rootDir: string): Promise<MigrationResult> => {
  const result: MigrationResult = {
    configMigrated: false,
    ignoreMigrated: false,
    instructionMigrated: false,
    outputFilesMigrated: [],
    globalConfigMigrated: false,
  };

  try {
    const paths = getMigrationPaths(rootDir);

    // Check if migration is needed
    const hasOldConfig = await fileExists(paths.oldConfigPath);
    const hasOldIgnore = await fileExists(paths.oldIgnorePath);
    const hasOldInstruction = await fileExists(paths.oldInstructionPath);
    const hasOldGlobalConfig = await fileExists(paths.oldGlobalConfigPath);
    const hasOldOutput = await Promise.all(paths.oldOutputPaths.map(fileExists)).then((results) =>
      results.some((exists) => exists),
    );

    if (!hasOldConfig && !hasOldIgnore && !hasOldInstruction && !hasOldOutput && !hasOldGlobalConfig) {
      logger.debug('No Repopack files found to migrate.');
      return result;
    }

    // Show migration notice based on what needs to be migrated
    let migrationMessage = `Found ${pc.green('Repopack')} `;
    const items = [];
    if (hasOldConfig || hasOldIgnore || hasOldInstruction || hasOldOutput) items.push('local configuration');
    if (hasOldGlobalConfig) items.push('global configuration');
    migrationMessage += `${items.join(' and ')}. Would you like to migrate to ${pc.green('Repomix')}?`;

    // Confirm migration with user
    const shouldMigrate = await prompts.confirm({
      message: migrationMessage,
    });

    if (prompts.isCancel(shouldMigrate) || !shouldMigrate) {
      logger.info('Migration cancelled.');
      return result;
    }

    // Show migration notice
    logger.info(pc.cyan('\nMigrating from Repopack to Repomix...'));
    logger.log('');

    // Migrate config file
    if (hasOldConfig) {
      result.configMigrated = await migrateFile(paths.oldConfigPath, paths.newConfigPath, 'Configuration file', true);
    }

    // Migrate global config file
    if (hasOldGlobalConfig) {
      result.globalConfigMigrated = await migrateFile(
        paths.oldGlobalConfigPath,
        paths.newGlobalConfigPath,
        'Global configuration file',
        true,
      );
    }

    // Migrate ignore file
    if (hasOldIgnore) {
      result.ignoreMigrated = await migrateFile(paths.oldIgnorePath, paths.newIgnorePath, 'Ignore file');
    }

    // Migrate instruction file
    if (hasOldInstruction) {
      result.instructionMigrated = await migrateFile(
        paths.oldInstructionPath,
        paths.newInstructionPath,
        'Instruction file',
      );
    }

    // Migrate output files
    if (hasOldOutput) {
      result.outputFilesMigrated = await migrateOutputFiles(paths.oldOutputPaths, paths.newOutputPaths);
    }

    // Update content in gitignore and repomixignore
    await updateIgnoreFiles(rootDir);

    // Show success message
    if (
      result.configMigrated ||
      result.ignoreMigrated ||
      result.instructionMigrated ||
      result.outputFilesMigrated.length > 0 ||
      result.globalConfigMigrated
    ) {
      logger.log('');
      logger.success('✔ Migration completed successfully!');
      logger.log('');
      logger.info(
        'You can now use Repomix commands as usual. The old Repopack files have been migrated to the new format.',
      );
      logger.log('');
    }

    return result;
  } catch (error) {
    if (error instanceof Error) {
      result.error = error;
    } else {
      result.error = new Error(String(error));
    }
    logger.error('An error occurred during migration:', error);
    return result;
  }
};
</file>

<file path="src/cli/actions/remoteAction.ts">
import * as fs from 'node:fs/promises';
import os from 'node:os';
import path from 'node:path';
import pc from 'picocolors';
import { execGitShallowClone, isGitInstalled } from '../../core/file/gitCommand.js';
import { RepomixError } from '../../shared/errorHandle.js';
import { logger } from '../../shared/logger.js';
import type { CliOptions } from '../cliRun.js';
import Spinner from '../cliSpinner.js';
import { type DefaultActionRunnerResult, runDefaultAction } from './defaultAction.js';

// Check the short form of the GitHub URL. e.g. yamadashy/repomix
const remoteNamePattern = '[a-zA-Z0-9](?:[a-zA-Z0-9._-]*[a-zA-Z0-9])?';
const remoteNamePatternRegex = new RegExp(`^${remoteNamePattern}/${remoteNamePattern}$`);

export const runRemoteAction = async (
  repoUrl: string,
  options: CliOptions,
  deps = {
    isGitInstalled,
    execGitShallowClone,
  },
): Promise<DefaultActionRunnerResult> => {
  if (!(await deps.isGitInstalled())) {
    throw new RepomixError('Git is not installed or not in the system PATH.');
  }

  if (!isValidRemoteValue(repoUrl)) {
    throw new RepomixError('Invalid repository URL or user/repo format');
  }

  const spinner = new Spinner('Cloning repository...');

  const tempDirPath = await createTempDirectory();
  let result: DefaultActionRunnerResult;

  try {
    spinner.start();

    // Clone the repository
    await cloneRepository(formatRemoteValueToUrl(repoUrl), tempDirPath, options.remoteBranch, {
      execGitShallowClone: deps.execGitShallowClone,
    });

    spinner.succeed('Repository cloned successfully!');
    logger.log('');

    // Run the default action on the cloned repository
    result = await runDefaultAction(tempDirPath, tempDirPath, options);
    await copyOutputToCurrentDirectory(tempDirPath, process.cwd(), result.config.output.filePath);
  } catch (error) {
    spinner.fail('Error during repository cloning. cleanup...');
    throw error;
  } finally {
    // Cleanup the temporary directory
    await cleanupTempDirectory(tempDirPath);
  }

  return result;
};

export function isValidRemoteValue(remoteValue: string): boolean {
  if (remoteNamePatternRegex.test(remoteValue)) {
    return true;
  }

  // Check the direct form of the GitHub URL. e.g.  https://github.com/yamadashy/repomix or https://gist.github.com/yamadashy/1234567890abcdef
  try {
    new URL(remoteValue);
    return true;
  } catch (error) {
    return false;
  }
}

export const formatRemoteValueToUrl = (url: string): string => {
  // If the URL is in the format owner/repo, convert it to a GitHub URL
  if (remoteNamePatternRegex.test(url)) {
    logger.trace(`Formatting GitHub shorthand: ${url}`);
    return `https://github.com/${url}.git`;
  }

  // Add .git to HTTPS URLs if missing
  if (url.startsWith('https://') && !url.endsWith('.git')) {
    logger.trace(`Adding .git to HTTPS URL: ${url}`);
    return `${url}.git`;
  }

  return url;
};

export const createTempDirectory = async (): Promise<string> => {
  const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'repomix-'));
  logger.trace(`Created temporary directory. (path: ${pc.dim(tempDir)})`);
  return tempDir;
};

export const cloneRepository = async (
  url: string,
  directory: string,
  remoteBranch?: string,
  deps = {
    execGitShallowClone,
  },
): Promise<void> => {
  logger.log(`Clone repository: ${url} to temporary directory. ${pc.dim(`path: ${directory}`)}`);
  logger.log('');

  try {
    await deps.execGitShallowClone(url, directory, remoteBranch);
  } catch (error) {
    throw new RepomixError(`Failed to clone repository: ${(error as Error).message}`);
  }
};

export const cleanupTempDirectory = async (directory: string): Promise<void> => {
  logger.trace(`Cleaning up temporary directory: ${directory}`);
  await fs.rm(directory, { recursive: true, force: true });
};

export const copyOutputToCurrentDirectory = async (
  sourceDir: string,
  targetDir: string,
  outputFileName: string,
): Promise<void> => {
  const sourcePath = path.join(sourceDir, outputFileName);
  const targetPath = path.join(targetDir, outputFileName);

  try {
    logger.trace(`Copying output file from: ${sourcePath} to: ${targetPath}`);
    await fs.copyFile(sourcePath, targetPath);
  } catch (error) {
    throw new RepomixError(`Failed to copy output file: ${(error as Error).message}`);
  }
};
</file>

<file path="src/cli/actions/versionAction.ts">
import { getVersion } from '../../core/file/packageJsonParse.js';
import { logger } from '../../shared/logger.js';

export const runVersionAction = async (): Promise<void> => {
  const version = await getVersion();
  logger.log(version);
};
</file>

<file path="src/cli/cliPrint.ts">
import path from 'node:path';
import pc from 'picocolors';
import type { RepomixConfigMerged } from '../config/configSchema.js';
import type { SuspiciousFileResult } from '../core/security/securityCheck.js';
import { logger } from '../shared/logger.js';

export const printSummary = (
  totalFiles: number,
  totalCharacters: number,
  totalTokens: number,
  outputPath: string,
  suspiciousFilesResults: SuspiciousFileResult[],
  config: RepomixConfigMerged,
) => {
  let securityCheckMessage = '';
  if (config.security.enableSecurityCheck) {
    if (suspiciousFilesResults.length > 0) {
      securityCheckMessage = pc.yellow(
        `${suspiciousFilesResults.length.toLocaleString()} suspicious file(s) detected and excluded`,
      );
    } else {
      securityCheckMessage = pc.white('✔ No suspicious files detected');
    }
  } else {
    securityCheckMessage = pc.dim('Security check disabled');
  }

  logger.log(pc.white('📊 Pack Summary:'));
  logger.log(pc.dim('────────────────'));
  logger.log(`${pc.white('  Total Files:')} ${pc.white(totalFiles.toLocaleString())} files`);
  logger.log(`${pc.white('  Total Chars:')} ${pc.white(totalCharacters.toLocaleString())} chars`);
  logger.log(`${pc.white(' Total Tokens:')} ${pc.white(totalTokens.toLocaleString())} tokens`);
  logger.log(`${pc.white('       Output:')} ${pc.white(outputPath)}`);
  logger.log(`${pc.white('     Security:')} ${pc.white(securityCheckMessage)}`);
};

export const printSecurityCheck = (
  rootDir: string,
  suspiciousFilesResults: SuspiciousFileResult[],
  config: RepomixConfigMerged,
) => {
  if (!config.security.enableSecurityCheck) {
    return;
  }

  logger.log(pc.white('🔎 Security Check:'));
  logger.log(pc.dim('──────────────────'));

  if (suspiciousFilesResults.length === 0) {
    logger.log(`${pc.green('✔')} ${pc.white('No suspicious files detected.')}`);
  } else {
    logger.log(pc.yellow(`${suspiciousFilesResults.length} suspicious file(s) detected and excluded from the output:`));
    suspiciousFilesResults.forEach((suspiciousFilesResult, index) => {
      const relativeFilePath = path.relative(rootDir, suspiciousFilesResult.filePath);
      logger.log(`${pc.white(`${index + 1}.`)} ${pc.white(relativeFilePath)}`);
      logger.log(pc.dim(`   - ${suspiciousFilesResult.messages.join('\n   - ')}`));
    });
    logger.log(pc.yellow('\nThese files have been excluded from the output for security reasons.'));
    logger.log(pc.yellow('Please review these files for potential sensitive information.'));
  }
};

export const printTopFiles = (
  fileCharCounts: Record<string, number>,
  fileTokenCounts: Record<string, number>,
  topFilesLength: number,
) => {
  const topFilesLengthStrLen = topFilesLength.toString().length;
  logger.log(pc.white(`📈 Top ${topFilesLength} Files by Character Count and Token Count:`));
  logger.log(pc.dim(`─────────────────────────────────────────────────${'─'.repeat(topFilesLengthStrLen)}`));

  const topFiles = Object.entries(fileCharCounts)
    .sort((a, b) => b[1] - a[1])
    .slice(0, topFilesLength);

  topFiles.forEach(([filePath, charCount], index) => {
    const tokenCount = fileTokenCounts[filePath];
    const indexString = `${index + 1}.`.padEnd(3, ' ');
    logger.log(
      `${pc.white(`${indexString}`)} ${pc.white(filePath)} ${pc.dim(`(${charCount.toLocaleString()} chars, ${tokenCount.toLocaleString()} tokens)`)}`,
    );
  });
};

export const printCompletion = () => {
  logger.log(pc.green('🎉 All Done!'));
  logger.log(pc.white('Your repository has been successfully packed.'));

  logger.log('');
  logger.log(`💡 Repomix is now available in your browser! Try it at ${pc.underline('https://repomix.com')}`);
};
</file>

<file path="src/cli/cliRun.ts">
import process from 'node:process';
import { type OptionValues, program } from 'commander';
import pc from 'picocolors';
import type { RepomixOutputStyle } from '../config/configSchema.js';
import { getVersion } from '../core/file/packageJsonParse.js';
import { handleError } from '../shared/errorHandle.js';
import { logger } from '../shared/logger.js';
import { runDefaultAction } from './actions/defaultAction.js';
import { runInitAction } from './actions/initAction.js';
import { runRemoteAction } from './actions/remoteAction.js';
import { runVersionAction } from './actions/versionAction.js';

export interface CliOptions extends OptionValues {
  version?: boolean;
  output?: string;
  include?: string;
  ignore?: string;
  config?: string;
  copy?: boolean;
  verbose?: boolean;
  topFilesLen?: number;
  outputShowLineNumbers?: boolean;
  style?: RepomixOutputStyle;
  parsableStyle?: boolean;
  init?: boolean;
  global?: boolean;
  remote?: string;
  remoteBranch?: string;
  securityCheck?: boolean;
  fileSummary?: boolean;
  directoryStructure?: boolean;
  removeComments?: boolean;
  removeEmptyLines?: boolean;
  tokenCountEncoding?: string;
}

export const run = async () => {
  try {
    program
      .description('Repomix - Pack your repository into a single AI-friendly file')
      .arguments('[directory]')
      .option('-v, --version', 'show version information')
      .option('-o, --output <file>', 'specify the output file name')
      .option('--include <patterns>', 'list of include patterns (comma-separated)')
      .option('-i, --ignore <patterns>', 'additional ignore patterns (comma-separated)')
      .option('-c, --config <path>', 'path to a custom config file')
      .option('--copy', 'copy generated output to system clipboard')
      .option('--top-files-len <number>', 'specify the number of top files to display', Number.parseInt)
      .option('--output-show-line-numbers', 'add line numbers to each line in the output')
      .option('--style <type>', 'specify the output style (plain, xml, markdown)')
      .option('--parsable-style', 'by escaping and formatting, ensure the output is parsable as a document of its type')
      .option('--no-file-summary', 'disable file summary section output')
      .option('--no-directory-structure', 'disable directory structure section output')
      .option('--remove-comments', 'remove comments')
      .option('--remove-empty-lines', 'remove empty lines')
      .option('--verbose', 'enable verbose logging for detailed output')
      .option('--init', 'initialize a new repomix.config.json file')
      .option('--global', 'use global configuration (only applicable with --init)')
      .option('--remote <url>', 'process a remote Git repository')
      .option('--token-count-encoding <encoding>', 'specify token count encoding (e.g., o200k_base, cl100k_base)')
      .option(
        '--remote-branch <name>',
        'specify the remote branch name, tag, or commit hash (defaults to repository default branch)',
      )
      .option('--no-security-check', 'disable security check')
      .action((directory = '.', options: CliOptions = {}) => executeAction(directory, process.cwd(), options));

    await program.parseAsync(process.argv);
  } catch (error) {
    handleError(error);
  }
};

export const executeAction = async (directory: string, cwd: string, options: CliOptions) => {
  logger.setVerbose(options.verbose || false);

  if (options.version) {
    await runVersionAction();
    return;
  }

  const version = await getVersion();
  logger.log(pc.dim(`\n📦 Repomix v${version}\n`));

  if (options.init) {
    await runInitAction(cwd, options.global || false);
    return;
  }

  if (options.remote) {
    await runRemoteAction(options.remote, options);
    return;
  }

  await runDefaultAction(directory, cwd, options);
};
</file>

<file path="src/cli/cliSpinner.ts">
import cliSpinners from 'cli-spinners';
import logUpdate from 'log-update';
import pc from 'picocolors';

class Spinner {
  private spinner = cliSpinners.dots;
  private message: string;
  private currentFrame = 0;
  private interval: ReturnType<typeof setInterval> | null = null;

  constructor(message: string) {
    this.message = message;
  }

  start(): void {
    const frames = this.spinner.frames;
    const framesLength = frames.length;
    this.interval = setInterval(() => {
      this.currentFrame++;
      const frame = frames[this.currentFrame % framesLength];
      logUpdate(`${pc.cyan(frame)} ${this.message}`);
    }, this.spinner.interval);
  }

  update(message: string): void {
    this.message = message;
  }

  stop(finalMessage: string): void {
    if (this.interval) {
      clearInterval(this.interval);
      this.interval = null;
    }
    logUpdate(finalMessage);
    logUpdate.done();
  }

  succeed(message: string): void {
    this.stop(`${pc.green('✔')} ${message}`);
  }

  fail(message: string): void {
    this.stop(`${pc.red('✖')} ${message}`);
  }
}

export default Spinner;
</file>

<file path="src/config/configLoad.ts">
import * as fs from 'node:fs/promises';
import path from 'node:path';
import stripJsonComments from 'strip-json-comments';
import { z } from 'zod';
import { RepomixError, rethrowValidationErrorIfZodError } from '../shared/errorHandle.js';
import { logger } from '../shared/logger.js';
import {
  type RepomixConfigCli,
  type RepomixConfigFile,
  type RepomixConfigMerged,
  defaultConfig,
  defaultFilePathMap,
  repomixConfigFileSchema,
  repomixConfigMergedSchema,
} from './configSchema.js';
import { getGlobalDirectory } from './globalDirectory.js';

const defaultConfigPath = 'repomix.config.json';

const getGlobalConfigPath = () => {
  return path.join(getGlobalDirectory(), 'repomix.config.json');
};

export const loadFileConfig = async (rootDir: string, argConfigPath: string | null): Promise<RepomixConfigFile> => {
  let useDefaultConfig = false;
  let configPath = argConfigPath;
  if (!configPath) {
    useDefaultConfig = true;
    configPath = defaultConfigPath;
  }

  const fullPath = path.resolve(rootDir, configPath);

  logger.trace('Loading local config from:', fullPath);

  // Check local file existence
  const isLocalFileExists = await fs
    .stat(fullPath)
    .then((stats) => stats.isFile())
    .catch(() => false);

  if (isLocalFileExists) {
    return await loadAndValidateConfig(fullPath);
  }

  if (useDefaultConfig) {
    // Try to load global config
    const globalConfigPath = getGlobalConfigPath();
    logger.trace('Loading global config from:', globalConfigPath);

    const isGlobalFileExists = await fs
      .stat(globalConfigPath)
      .then((stats) => stats.isFile())
      .catch(() => false);

    if (isGlobalFileExists) {
      return await loadAndValidateConfig(globalConfigPath);
    }

    logger.note(
      `No custom config found at ${configPath} or global config at ${globalConfigPath}.\nYou can add a config file for additional settings. Please check https://github.com/yamadashy/repomix for more information.`,
    );
    return {};
  }
  throw new RepomixError(`Config file not found at ${configPath}`);
};

const loadAndValidateConfig = async (filePath: string): Promise<RepomixConfigFile> => {
  try {
    const fileContent = await fs.readFile(filePath, 'utf-8');
    const config = JSON.parse(stripJsonComments(fileContent));
    return repomixConfigFileSchema.parse(config);
  } catch (error) {
    rethrowValidationErrorIfZodError(error, 'Invalid config schema');
    if (error instanceof SyntaxError) {
      throw new RepomixError(`Invalid JSON in config file ${filePath}: ${error.message}`);
    }
    if (error instanceof Error) {
      throw new RepomixError(`Error loading config from ${filePath}: ${error.message}`);
    }
    throw new RepomixError(`Error loading config from ${filePath}`);
  }
};

export const mergeConfigs = (
  cwd: string,
  fileConfig: RepomixConfigFile,
  cliConfig: RepomixConfigCli,
): RepomixConfigMerged => {
  logger.trace('Default config:', defaultConfig);

  const baseConfig = defaultConfig;

  // If the output file path is not provided in the config file or CLI, use the default file path for the style
  if (cliConfig.output?.filePath == null && fileConfig.output?.filePath == null) {
    const style = cliConfig.output?.style || fileConfig.output?.style || baseConfig.output.style;
    baseConfig.output.filePath = defaultFilePathMap[style];

    logger.trace('Default output file path is set to:', baseConfig.output.filePath);
  }

  const mergedConfig = {
    cwd,
    output: {
      ...baseConfig.output,
      ...fileConfig.output,
      ...cliConfig.output,
    },
    include: [...(baseConfig.include || []), ...(fileConfig.include || []), ...(cliConfig.include || [])],
    ignore: {
      ...baseConfig.ignore,
      ...fileConfig.ignore,
      ...cliConfig.ignore,
      customPatterns: [
        ...(baseConfig.ignore.customPatterns || []),
        ...(fileConfig.ignore?.customPatterns || []),
        ...(cliConfig.ignore?.customPatterns || []),
      ],
    },
    security: {
      ...baseConfig.security,
      ...fileConfig.security,
      ...cliConfig.security,
    },
  };

  try {
    return repomixConfigMergedSchema.parse(mergedConfig);
  } catch (error) {
    rethrowValidationErrorIfZodError(error, 'Invalid merged config');
    throw error;
  }
};
</file>

<file path="src/config/configSchema.ts">
import type { TiktokenEncoding } from 'tiktoken';
import { z } from 'zod';

// Output style enum
export const repomixOutputStyleSchema = z.enum(['plain', 'xml', 'markdown']);
export type RepomixOutputStyle = z.infer<typeof repomixOutputStyleSchema>;

// Default values map
export const defaultFilePathMap: Record<RepomixOutputStyle, string> = {
  plain: 'repomix-output.txt',
  markdown: 'repomix-output.md',
  xml: 'repomix-output.xml',
} as const;

// Base config schema
export const repomixConfigBaseSchema = z.object({
  output: z
    .object({
      filePath: z.string().optional(),
      style: repomixOutputStyleSchema.optional(),
      parsableStyle: z.boolean().optional(),
      headerText: z.string().optional(),
      instructionFilePath: z.string().optional(),
      fileSummary: z.boolean().optional(),
      directoryStructure: z.boolean().optional(),
      removeComments: z.boolean().optional(),
      removeEmptyLines: z.boolean().optional(),
      topFilesLength: z.number().optional(),
      showLineNumbers: z.boolean().optional(),
      copyToClipboard: z.boolean().optional(),
      includeEmptyDirectories: z.boolean().optional(),
    })
    .optional(),
  include: z.array(z.string()).optional(),
  ignore: z
    .object({
      useGitignore: z.boolean().optional(),
      useDefaultPatterns: z.boolean().optional(),
      customPatterns: z.array(z.string()).optional(),
    })
    .optional(),
  security: z
    .object({
      enableSecurityCheck: z.boolean().optional(),
    })
    .optional(),
  tokenCount: z
    .object({
      encoding: z.string().optional(),
    })
    .optional(),
});

// Default config schema with default values
export const repomixConfigDefaultSchema = z.object({
  output: z
    .object({
      filePath: z.string().default(defaultFilePathMap.plain),
      style: repomixOutputStyleSchema.default('plain'),
      parsableStyle: z.boolean().default(false),
      headerText: z.string().optional(),
      instructionFilePath: z.string().optional(),
      fileSummary: z.boolean().default(true),
      directoryStructure: z.boolean().default(true),
      removeComments: z.boolean().default(false),
      removeEmptyLines: z.boolean().default(false),
      topFilesLength: z.number().int().min(0).default(5),
      showLineNumbers: z.boolean().default(false),
      copyToClipboard: z.boolean().default(false),
      includeEmptyDirectories: z.boolean().optional(),
    })
    .default({}),
  include: z.array(z.string()).default([]),
  ignore: z
    .object({
      useGitignore: z.boolean().default(true),
      useDefaultPatterns: z.boolean().default(true),
      customPatterns: z.array(z.string()).default([]),
    })
    .default({}),
  security: z
    .object({
      enableSecurityCheck: z.boolean().default(true),
    })
    .default({}),
  tokenCount: z
    .object({
      encoding: z
        .string()
        .default('o200k_base')
        .transform((val) => val as TiktokenEncoding),
    })
    .default({}),
});

export const repomixConfigFileSchema = repomixConfigBaseSchema;

export const repomixConfigCliSchema = repomixConfigBaseSchema;

export const repomixConfigMergedSchema = repomixConfigDefaultSchema
  .and(repomixConfigFileSchema)
  .and(repomixConfigCliSchema)
  .and(
    z.object({
      cwd: z.string(),
    }),
  );

export type RepomixConfigDefault = z.infer<typeof repomixConfigDefaultSchema>;
export type RepomixConfigFile = z.infer<typeof repomixConfigFileSchema>;
export type RepomixConfigCli = z.infer<typeof repomixConfigCliSchema>;
export type RepomixConfigMerged = z.infer<typeof repomixConfigMergedSchema>;

export const defaultConfig = repomixConfigDefaultSchema.parse({});
</file>

<file path="src/config/defaultIgnore.ts">
export const defaultIgnoreList = [
  // Version control
  '.git/**',
  '.hg/**',
  '.hgignore',
  '.svn/**',

  // Dependency directories
  'node_modules/**',
  '**/node_modules/**',
  'bower_components/**',
  '**/bower_components/**',
  'jspm_packages/**',
  '**/jspm_packages/**',
  'vendor/**',
  '.bundle/**',
  '.gradle/**',
  'target/**',

  // Logs
  'logs/**',
  '**/*.log',
  '**/npm-debug.log*',
  '**/yarn-debug.log*',
  '**/yarn-error.log*',

  // Runtime data
  'pids/**',
  '*.pid',
  '*.seed',
  '*.pid.lock',

  // Directory for instrumented libs generated by jscoverage/JSCover
  'lib-cov/**',

  // Coverage directory used by tools like istanbul
  'coverage/**',

  // nyc test coverage
  '.nyc_output/**',

  // Grunt intermediate storage
  '.grunt/**',

  // node-waf configuration
  '.lock-wscript',

  // Compiled binary addons
  'build/Release/**',

  // TypeScript v1 declaration files
  'typings/**',

  // Optional npm cache directory
  '**/.npm/**',

  // Optional eslint cache
  '.eslintcache',

  // Optional REPL history
  '.node_repl_history',

  // Output of 'npm pack'
  '*.tgz',

  // Yarn files
  '**/.yarn/**',

  // Yarn Integrity file
  '**/.yarn-integrity',

  // dotenv environment variables file
  '.env',

  // next.js build output
  '.next/**',

  // nuxt.js build output
  '.nuxt/**',

  // vuepress build output
  '.vuepress/dist/**',

  // Serverless directories
  '.serverless/**',

  // FuseBox cache
  '.fusebox/**',

  // DynamoDB Local files
  '.dynamodb/**',

  // TypeScript output
  'dist/**',

  // OS generated files
  '**/.DS_Store',
  '**/Thumbs.db',

  // Editor directories and files
  '.idea/**',
  '.vscode/**',
  '**/*.swp',
  '**/*.swo',
  '**/*.swn',
  '**/*.bak',

  // Package manager locks
  '**/package-lock.json',
  '**/yarn.lock',
  '**/pnpm-lock.yaml',

  // Build outputs
  'build/**',
  'out/**',

  // Temporary files
  'tmp/**',
  'temp/**',

  // repomix output
  'repomix-output.*',
  'repopack-output.*', // Legacy

  // Essential Python-related entries
  '**/__pycache__/**',
  '**/*.py[cod]',
  '**/venv/**',
  '**/.venv/**',
  '**/.pytest_cache/**',
  '**/.mypy_cache/**',
  '**/.ipynb_checkpoints/**',
  '**/Pipfile.lock',
  '**/poetry.lock',
];
</file>

<file path="src/config/globalDirectory.ts">
import os from 'node:os';
import path from 'node:path';

export const getGlobalDirectory = () => {
  if (process.platform === 'win32') {
    const localAppData = process.env.LOCALAPPDATA || path.join(os.homedir(), 'AppData', 'Local');
    return path.join(localAppData, 'Repomix');
  }

  if (process.env.XDG_CONFIG_HOME) {
    return path.join(process.env.XDG_CONFIG_HOME, 'repomix');
  }

  return path.join(os.homedir(), '.config', 'repomix');
};
</file>

<file path="src/core/file/fileCollect.ts">
import * as fs from 'node:fs/promises';
import path from 'node:path';
import iconv from 'iconv-lite';
import { isBinary } from 'istextorbinary';
import jschardet from 'jschardet';
import pMap from 'p-map';
import { logger } from '../../shared/logger.js';
import { getProcessConcurrency } from '../../shared/processConcurrency.js';
import type { RawFile } from './fileTypes.js';

export const collectFiles = async (filePaths: string[], rootDir: string): Promise<RawFile[]> => {
  const rawFiles = await pMap(
    filePaths,
    async (filePath) => {
      const fullPath = path.resolve(rootDir, filePath);
      const content = await readRawFile(fullPath);
      if (content) {
        return { path: filePath, content };
      }
      return null;
    },
    {
      concurrency: getProcessConcurrency(),
    },
  );

  return rawFiles.filter((file): file is RawFile => file != null);
};

const readRawFile = async (filePath: string): Promise<string | null> => {
  if (isBinary(filePath)) {
    logger.debug(`Skipping binary file: ${filePath}`);
    return null;
  }

  logger.trace(`Reading file: ${filePath}`);

  try {
    const buffer = await fs.readFile(filePath);

    if (isBinary(null, buffer)) {
      logger.debug(`Skipping binary file (content check): ${filePath}`);
      return null;
    }

    const encoding = jschardet.detect(buffer).encoding || 'utf-8';
    const content = iconv.decode(buffer, encoding);

    return content;
  } catch (error) {
    logger.warn(`Failed to read file: ${filePath}`, error);
    return null;
  }
};
</file>

<file path="src/core/file/fileManipulate.ts">
import path from 'node:path';
import strip from 'strip-comments';

interface FileManipulator {
  removeComments(content: string): string;
  removeEmptyLines(content: string): string;
}

const rtrimLines = (content: string): string =>
  content
    .split('\n')
    .map((line) => line.trimEnd())
    .join('\n');

class BaseManipulator implements FileManipulator {
  removeComments(content: string): string {
    return content;
  }

  removeEmptyLines(content: string): string {
    return content
      .split('\n')
      .filter((line) => line.trim() !== '')
      .join('\n');
  }
}

class StripCommentsManipulator extends BaseManipulator {
  private language: string;

  constructor(language: string) {
    super();
    this.language = language;
  }

  removeComments(content: string): string {
    const result = strip(content, {
      language: this.language,
      preserveNewlines: true,
    });
    return rtrimLines(result);
  }
}

class PythonManipulator extends BaseManipulator {
  removeDocStrings(content: string): string {
    if (!content) return '';
    const lines = content.split('\n');

    let result = '';

    let buffer = '';
    let quoteType: '' | "'" | '"' = '';
    let tripleQuotes = 0;

    const doubleQuoteRegex = /^\s*(?<!\\)(?:""")\s*(?:\n)?[\s\S]*?(?<!("""))(?<!\\)(?:""")/gm;
    const singleQuoteRegex = /^\s*(?<!\\)(?:''')\s*(?:\n)?[\s\S]*?(?<!('''))(?<!\\)(?:''')/gm;

    const sz = lines.length;
    for (let i = 0; i < sz; i++) {
      const line = lines[i] + (i !== sz - 1 ? '\n' : '');
      buffer += line;
      if (quoteType === '') {
        const indexSingle = line.search(/(?<![\"])(?<!\\)'''(?![\"])/g);
        const indexDouble = line.search(/(?<![\'])(?<!\\)"""(?![\'])/g);
        if (indexSingle !== -1 && (indexDouble === -1 || indexSingle < indexDouble)) {
          quoteType = "'";
        } else if (indexDouble !== -1 && (indexSingle === -1 || indexDouble < indexSingle)) {
          quoteType = '"';
        }
      }
      if (quoteType === "'") {
        tripleQuotes += (line.match(/(?<![\"])(?<!\\)'''(?!["])/g) || []).length;
      }
      if (quoteType === '"') {
        tripleQuotes += (line.match(/(?<![\'])(?<!\\)"""(?![\'])/g) || []).length;
      }

      if (tripleQuotes % 2 === 0) {
        const docstringRegex = quoteType === '"' ? doubleQuoteRegex : singleQuoteRegex;
        buffer = buffer.replace(docstringRegex, '');
        result += buffer;
        buffer = '';
        tripleQuotes = 0;
        quoteType = '';
      }
    }

    result += buffer;
    return result;
  }

  removeHashComments(content: string): string {
    const searchInPairs = (pairs: [number, number][], hashIndex: number): boolean => {
      return pairs.some(([start, end]) => hashIndex > start && hashIndex < end);
    };

    let result = '';
    const pairs: [number, number][] = [];
    let prevQuote = 0;
    while (prevQuote < content.length) {
      const openingQuote = content.slice(prevQuote + 1).search(/(?<!\\)(?:"|'|'''|""")/g) + prevQuote + 1;
      if (openingQuote === prevQuote) break;

      let closingQuote = -1;
      if (content.startsWith('"""', openingQuote) || content.startsWith("'''", openingQuote)) {
        const quoteType = content.slice(openingQuote, openingQuote + 3);
        closingQuote = content.indexOf(quoteType, openingQuote + 3);
      } else {
        const quoteType = content[openingQuote];
        closingQuote = content.indexOf(quoteType, openingQuote + 1);
      }

      if (closingQuote === -1) break;
      pairs.push([openingQuote, closingQuote]);
      prevQuote = closingQuote;
    }
    let prevHash = 0;
    while (prevHash < content.length) {
      const hashIndex = content.slice(prevHash).search(/(?<!\\)#/g) + prevHash;
      if (hashIndex === prevHash - 1) {
        result += content.slice(prevHash);
        break;
      }

      const isInsideString = searchInPairs(pairs, hashIndex);
      const nextNewLine = content.indexOf('\n', hashIndex);

      if (!isInsideString) {
        if (nextNewLine === -1) {
          result += content.slice(prevHash);
          break;
        }
        result += `${content.slice(prevHash, hashIndex)}\n`;
      } else {
        if (nextNewLine === -1) {
          result += content.slice(prevHash);
          break;
        }
        result += `${content.slice(prevHash, nextNewLine)}\n`;
      }

      prevHash = nextNewLine + 1;
    }
    return result;
  }

  removeComments(content: string): string {
    let result = this.removeDocStrings(content);
    result = this.removeHashComments(result);
    return rtrimLines(result);
  }
}

class CompositeManipulator extends BaseManipulator {
  private manipulators: FileManipulator[];

  constructor(...manipulators: FileManipulator[]) {
    super();
    this.manipulators = manipulators;
  }

  removeComments(content: string): string {
    return this.manipulators.reduce((acc, manipulator) => manipulator.removeComments(acc), content);
  }
}

const manipulators: Record<string, FileManipulator> = {
  '.c': new StripCommentsManipulator('c'),
  '.cs': new StripCommentsManipulator('csharp'),
  '.css': new StripCommentsManipulator('css'),
  '.dart': new StripCommentsManipulator('c'),
  '.go': new StripCommentsManipulator('c'),
  '.html': new StripCommentsManipulator('html'),
  '.java': new StripCommentsManipulator('java'),
  '.js': new StripCommentsManipulator('javascript'),
  '.jsx': new StripCommentsManipulator('javascript'),
  '.kt': new StripCommentsManipulator('c'),
  '.less': new StripCommentsManipulator('less'),
  '.php': new StripCommentsManipulator('php'),
  '.rb': new StripCommentsManipulator('ruby'),
  '.rs': new StripCommentsManipulator('c'),
  '.sass': new StripCommentsManipulator('sass'),
  '.scss': new StripCommentsManipulator('sass'),
  '.sh': new StripCommentsManipulator('perl'),
  '.sql': new StripCommentsManipulator('sql'),
  '.swift': new StripCommentsManipulator('swift'),
  '.ts': new StripCommentsManipulator('javascript'),
  '.tsx': new StripCommentsManipulator('javascript'),
  '.xml': new StripCommentsManipulator('xml'),
  '.yaml': new StripCommentsManipulator('perl'),
  '.yml': new StripCommentsManipulator('perl'),

  '.py': new PythonManipulator(),

  '.vue': new CompositeManipulator(
    new StripCommentsManipulator('html'),
    new StripCommentsManipulator('css'),
    new StripCommentsManipulator('javascript'),
  ),
  '.svelte': new CompositeManipulator(
    new StripCommentsManipulator('html'),
    new StripCommentsManipulator('css'),
    new StripCommentsManipulator('javascript'),
  ),
};

export const getFileManipulator = (filePath: string): FileManipulator | null => {
  const ext = path.extname(filePath);
  return manipulators[ext] || null;
};
</file>

<file path="src/core/file/filePathSort.ts">
import path from 'node:path';

export const sortPaths = (filePaths: string[]): string[] =>
  filePaths.sort((a, b) => {
    const partsA = a.split(path.sep);
    const partsB = b.split(path.sep);

    for (let i = 0; i < Math.min(partsA.length, partsB.length); i++) {
      if (partsA[i] !== partsB[i]) {
        const isLastA = i === partsA.length - 1;
        const isLastB = i === partsB.length - 1;

        if (!isLastA && isLastB) return -1; // Directory
        if (isLastA && !isLastB) return 1; // File

        return partsA[i].localeCompare(partsB[i]); // Alphabetical order
      }
    }

    // Sort by length if all parts are equal
    return partsA.length - partsB.length;
  });
</file>

<file path="src/core/file/fileProcess.ts">
import { setTimeout } from 'node:timers/promises';
import pMap from 'p-map';
import pc from 'picocolors';
import type { RepomixConfigMerged } from '../../config/configSchema.js';
import { logger } from '../../shared/logger.js';
import { getProcessConcurrency } from '../../shared/processConcurrency.js';
import type { RepomixProgressCallback } from '../../shared/types.js';
import { getFileManipulator } from './fileManipulate.js';
import type { ProcessedFile, RawFile } from './fileTypes.js';

export const processFiles = async (
  rawFiles: RawFile[],
  config: RepomixConfigMerged,
  progressCallback: RepomixProgressCallback,
): Promise<ProcessedFile[]> => {
  return pMap(
    rawFiles,
    async (rawFile, index) => {
      progressCallback(`Processing file... (${index + 1}/${rawFiles.length}) ${pc.dim(rawFile.path)}`);

      const resultContent = await processContent(rawFile.content, rawFile.path, config);

      // Sleep for a short time to prevent blocking the event loop
      await setTimeout(1);

      return {
        path: rawFile.path,
        content: resultContent,
      };
    },
    {
      concurrency: getProcessConcurrency(),
    },
  );
};

export const processContent = async (
  content: string,
  filePath: string,
  config: RepomixConfigMerged,
): Promise<string> => {
  let processedContent = content;
  const manipulator = getFileManipulator(filePath);

  logger.trace(`Processing file: ${filePath}`);

  const processStartAt = process.hrtime.bigint();

  if (config.output.removeComments && manipulator) {
    processedContent = manipulator.removeComments(processedContent);
  }

  if (config.output.removeEmptyLines && manipulator) {
    processedContent = manipulator.removeEmptyLines(processedContent);
  }

  processedContent = processedContent.trim();

  if (config.output.showLineNumbers) {
    const lines = processedContent.split('\n');
    const padding = lines.length.toString().length;
    const numberedLines = lines.map((line, index) => `${(index + 1).toString().padStart(padding)}: ${line}`);
    processedContent = numberedLines.join('\n');
  }

  const processEndAt = process.hrtime.bigint();

  logger.trace(`Processed file: ${filePath}. Took: ${(Number(processEndAt - processStartAt) / 1e6).toFixed(2)}ms`);

  return processedContent;
};
</file>

<file path="src/core/file/fileSearch.ts">
import fs from 'node:fs/promises';
import path from 'node:path';
import { globby } from 'globby';
import { minimatch } from 'minimatch';
import type { RepomixConfigMerged } from '../../config/configSchema.js';
import { defaultIgnoreList } from '../../config/defaultIgnore.js';
import { logger } from '../../shared/logger.js';
import { sortPaths } from './filePathSort.js';
import { PermissionError, checkDirectoryPermissions } from './permissionCheck.js';

export interface FileSearchResult {
  filePaths: string[];
  emptyDirPaths: string[];
}

const findEmptyDirectories = async (
  rootDir: string,
  directories: string[],
  ignorePatterns: string[],
): Promise<string[]> => {
  const emptyDirs: string[] = [];

  for (const dir of directories) {
    const fullPath = path.join(rootDir, dir);
    try {
      const entries = await fs.readdir(fullPath);
      const hasVisibleContents = entries.some((entry) => !entry.startsWith('.'));

      if (!hasVisibleContents) {
        // This checks if the directory itself matches any ignore patterns
        const shouldIgnore = ignorePatterns.some((pattern) => minimatch(dir, pattern) || minimatch(`${dir}/`, pattern));

        if (!shouldIgnore) {
          emptyDirs.push(dir);
        }
      }
    } catch (error) {
      logger.debug(`Error checking directory ${dir}:`, error);
    }
  }

  return emptyDirs;
};

// Check if a path is a git worktree reference file
const isGitWorktreeRef = async (gitPath: string): Promise<boolean> => {
  try {
    const stats = await fs.stat(gitPath);
    if (!stats.isFile()) {
      return false;
    }

    const content = await fs.readFile(gitPath, 'utf8');
    return content.startsWith('gitdir:');
  } catch {
    return false;
  }
};

// Get all file paths considering the config
export const searchFiles = async (rootDir: string, config: RepomixConfigMerged): Promise<FileSearchResult> => {
  // First check directory permissions
  const permissionCheck = await checkDirectoryPermissions(rootDir);

  if (!permissionCheck.hasPermission) {
    if (permissionCheck.error instanceof PermissionError) {
      throw permissionCheck.error;
    }
    throw new Error(`Cannot access directory ${rootDir}: ${permissionCheck.error?.message}`);
  }

  const includePatterns = config.include.length > 0 ? config.include : ['**/*'];

  try {
    const [ignorePatterns, ignoreFilePatterns] = await Promise.all([
      getIgnorePatterns(rootDir, config),
      getIgnoreFilePatterns(config),
    ]);

    logger.trace('Include patterns:', includePatterns);
    logger.trace('Ignore patterns:', ignorePatterns);
    logger.trace('Ignore file patterns:', ignoreFilePatterns);

    // Check if .git is a worktree reference
    const gitPath = path.join(rootDir, '.git');
    const isWorktree = await isGitWorktreeRef(gitPath);

    // Modify ignore patterns for git worktree
    const adjustedIgnorePatterns = [...ignorePatterns];
    if (isWorktree) {
      // Remove '.git/**' pattern and add '.git' to ignore the reference file
      const gitIndex = adjustedIgnorePatterns.indexOf('.git/**');
      if (gitIndex !== -1) {
        adjustedIgnorePatterns.splice(gitIndex, 1);
        adjustedIgnorePatterns.push('.git');
      }
    }

    const filePaths = await globby(includePatterns, {
      cwd: rootDir,
      ignore: [...adjustedIgnorePatterns],
      ignoreFiles: [...ignoreFilePatterns],
      onlyFiles: true,
      absolute: false,
      dot: true,
      followSymbolicLinks: false,
    }).catch((error) => {
      // Handle EPERM errors specifically
      if (error.code === 'EPERM' || error.code === 'EACCES') {
        throw new PermissionError(
          'Permission denied while scanning directory. Please check folder access permissions for your terminal app.',
          rootDir,
        );
      }
      throw error;
    });

    let emptyDirPaths: string[] = [];
    if (config.output.includeEmptyDirectories) {
      const directories = await globby(includePatterns, {
        cwd: rootDir,
        ignore: [...adjustedIgnorePatterns],
        ignoreFiles: [...ignoreFilePatterns],
        onlyDirectories: true,
        absolute: false,
        dot: true,
        followSymbolicLinks: false,
      });

      emptyDirPaths = await findEmptyDirectories(rootDir, directories, adjustedIgnorePatterns);
    }

    logger.trace(`Filtered ${filePaths.length} files`);

    return {
      filePaths: sortPaths(filePaths),
      emptyDirPaths: sortPaths(emptyDirPaths),
    };
  } catch (error: unknown) {
    // Re-throw PermissionError as is
    if (error instanceof PermissionError) {
      throw error;
    }

    if (error instanceof Error) {
      logger.error('Error filtering files:', error.message);
      throw new Error(`Failed to filter files in directory ${rootDir}. Reason: ${error.message}`);
    }

    logger.error('An unexpected error occurred:', error);
    throw new Error('An unexpected error occurred while filtering files.');
  }
};

export const parseIgnoreContent = (content: string): string[] => {
  if (!content) return [];

  return content.split('\n').reduce<string[]>((acc, line) => {
    const trimmedLine = line.trim();
    if (trimmedLine && !trimmedLine.startsWith('#')) {
      acc.push(trimmedLine);
    }
    return acc;
  }, []);
};

export const getIgnoreFilePatterns = async (config: RepomixConfigMerged): Promise<string[]> => {
  const ignoreFilePatterns: string[] = [];

  if (config.ignore.useGitignore) {
    ignoreFilePatterns.push('**/.gitignore');
  }

  ignoreFilePatterns.push('**/.repomixignore');

  return ignoreFilePatterns;
};

export const getIgnorePatterns = async (rootDir: string, config: RepomixConfigMerged): Promise<string[]> => {
  const ignorePatterns = new Set<string>();

  // Add default ignore patterns
  if (config.ignore.useDefaultPatterns) {
    logger.trace('Adding default ignore patterns');
    for (const pattern of defaultIgnoreList) {
      ignorePatterns.add(pattern);
    }
  }

  // Add repomix output file
  if (config.output.filePath) {
    const absoluteOutputPath = path.resolve(config.cwd, config.output.filePath);
    const relativeToTargetPath = path.relative(rootDir, absoluteOutputPath);

    logger.trace('Adding output file to ignore patterns:', relativeToTargetPath);

    ignorePatterns.add(relativeToTargetPath);
  }

  // Add custom ignore patterns
  if (config.ignore.customPatterns) {
    logger.trace('Adding custom ignore patterns:', config.ignore.customPatterns);
    for (const pattern of config.ignore.customPatterns) {
      ignorePatterns.add(pattern);
    }
  }

  return Array.from(ignorePatterns);
};
</file>

<file path="src/core/file/fileTreeGenerate.ts">
import nodepath from 'node:path';

interface TreeNode {
  name: string;
  children: TreeNode[];
  isDirectory: boolean;
}

const createTreeNode = (name: string, isDirectory: boolean): TreeNode => ({ name, children: [], isDirectory });

export const generateFileTree = (files: string[], emptyDirPaths: string[] = []): TreeNode => {
  const root: TreeNode = createTreeNode('root', true);

  for (const file of files) {
    addPathToTree(root, file, false);
  }

  // Add empty directories
  for (const dir of emptyDirPaths) {
    addPathToTree(root, dir, true);
  }

  return root;
};

const addPathToTree = (root: TreeNode, path: string, isDirectory: boolean): void => {
  const parts = path.split(nodepath.sep);
  let currentNode = root;

  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];
    const isLastPart = i === parts.length - 1;
    let child = currentNode.children.find((c) => c.name === part);

    if (!child) {
      child = createTreeNode(part, !isLastPart || isDirectory);
      currentNode.children.push(child);
    }

    currentNode = child;
  }
};

const sortTreeNodes = (node: TreeNode) => {
  node.children.sort((a, b) => {
    if (a.isDirectory === b.isDirectory) {
      return a.name.localeCompare(b.name);
    }
    return a.isDirectory ? -1 : 1;
  });

  for (const child of node.children) {
    sortTreeNodes(child);
  }
};

export const treeToString = (node: TreeNode, prefix = ''): string => {
  sortTreeNodes(node);
  let result = '';

  for (const child of node.children) {
    result += `${prefix}${child.name}${child.isDirectory ? '/' : ''}\n`;
    if (child.isDirectory) {
      result += treeToString(child, `${prefix}  `);
    }
  }

  return result;
};

export const generateTreeString = (files: string[], emptyDirPaths: string[] = []): string => {
  const tree = generateFileTree(files, emptyDirPaths);
  return treeToString(tree).trim();
};
</file>

<file path="src/core/file/fileTypes.ts">
export interface RawFile {
  path: string;
  content: string;
}

export interface ProcessedFile {
  path: string;
  content: string;
}
</file>

<file path="src/core/file/gitCommand.ts">
import { execFile } from 'node:child_process';
import fs from 'node:fs/promises';
import path from 'node:path';
import { promisify } from 'node:util';
import { RepomixError } from '../../shared/errorHandle.js';
import { logger } from '../../shared/logger.js';

const execFileAsync = promisify(execFile);

export const isGitInstalled = async (
  deps = {
    execFileAsync,
  },
) => {
  try {
    const result = await deps.execFileAsync('git', ['--version']);
    return !result.stderr;
  } catch (error) {
    logger.trace('Git is not installed:', (error as Error).message);
    return false;
  }
};

export const execGitShallowClone = async (
  url: string,
  directory: string,
  remoteBranch?: string,
  deps = {
    execFileAsync,
  },
) => {
  // Check if the URL is valid
  try {
    new URL(url);
  } catch (error) {
    throw new RepomixError(`Invalid repository URL. Please provide a valid URL. url: ${url}`);
  }

  if (remoteBranch) {
    await deps.execFileAsync('git', ['-C', directory, 'init']);
    await deps.execFileAsync('git', ['-C', directory, 'remote', 'add', 'origin', url]);
    try {
      await deps.execFileAsync('git', ['-C', directory, 'fetch', '--depth', '1', 'origin', remoteBranch]);
      await deps.execFileAsync('git', ['-C', directory, 'checkout', 'FETCH_HEAD']);
    } catch (err: unknown) {
      // git fetch --depth 1 origin <short SHA> always throws "couldn't find remote ref" error
      const isRefNotfoundError =
        err instanceof Error && err.message.includes(`couldn't find remote ref ${remoteBranch}`);

      if (!isRefNotfoundError) {
        // Rethrow error as nothing else we can do
        throw err;
      }

      // Short SHA detection - matches a hexadecimal string of 4 to 39 characters
      // If the string matches this regex, it MIGHT be a short SHA
      // If the string doesn't match, it is DEFINITELY NOT a short SHA
      const isNotShortSHA = !remoteBranch.match(/^[0-9a-f]{4,39}$/i);

      if (isNotShortSHA) {
        // Rethrow error as nothing else we can do
        throw err;
      }

      // Maybe the error is due to a short SHA, let's try again
      // Can't use --depth 1 here as we need to fetch the specific commit
      await deps.execFileAsync('git', ['-C', directory, 'fetch', 'origin']);
      await deps.execFileAsync('git', ['-C', directory, 'checkout', remoteBranch]);
    }
  } else {
    await deps.execFileAsync('git', ['clone', '--depth', '1', url, directory]);
  }

  // Clean up .git directory
  await fs.rm(path.join(directory, '.git'), { recursive: true, force: true });
};
</file>

<file path="src/core/file/packageJsonParse.ts">
import * as fs from 'node:fs/promises';
import path from 'node:path';
import * as url from 'node:url';
import { logger } from '../../shared/logger.js';

export const getVersion = async (): Promise<string> => {
  try {
    const packageJson = await parsePackageJson();

    if (!packageJson.version) {
      logger.warn('No version found in package.json');
      return 'unknown';
    }

    return packageJson.version;
  } catch (error) {
    logger.error('Error reading package.json:', error);
    return 'unknown';
  }
};

const parsePackageJson = async (): Promise<{
  name: string;
  version: string;
}> => {
  const dirName = url.fileURLToPath(new URL('.', import.meta.url));
  const packageJsonPath = path.join(dirName, '..', '..', '..', 'package.json');
  const packageJsonFile = await fs.readFile(packageJsonPath, 'utf-8');
  const packageJson = JSON.parse(packageJsonFile);
  return packageJson;
};
</file>

<file path="src/core/file/permissionCheck.ts">
import { constants } from 'node:fs';
import * as fs from 'node:fs/promises';
import { platform } from 'node:os';
import { logger } from '../../shared/logger.js';

export interface PermissionCheckResult {
  hasPermission: boolean;
  error?: Error;
  details?: {
    read?: boolean;
    write?: boolean;
    execute?: boolean;
  };
}

export class PermissionError extends Error {
  constructor(
    message: string,
    public readonly path: string,
    public readonly code?: string,
  ) {
    super(message);
    this.name = 'PermissionError';
  }
}

export const checkDirectoryPermissions = async (dirPath: string): Promise<PermissionCheckResult> => {
  try {
    // First try to read directory contents
    await fs.readdir(dirPath);

    // Check specific permissions
    const details = {
      read: false,
      write: false,
      execute: false,
    };

    try {
      await fs.access(dirPath, constants.R_OK);
      details.read = true;
    } catch {}

    try {
      await fs.access(dirPath, constants.W_OK);
      details.write = true;
    } catch {}

    try {
      await fs.access(dirPath, constants.X_OK);
      details.execute = true;
    } catch {}

    const hasAllPermissions = details.read && details.write && details.execute;

    if (!hasAllPermissions) {
      return {
        hasPermission: false,
        details,
      };
    }

    return {
      hasPermission: true,
      details,
    };
  } catch (error) {
    if (error instanceof Error && 'code' in error) {
      switch (error.code) {
        case 'EPERM':
        case 'EACCES':
        case 'EISDIR':
          return {
            hasPermission: false,
            error: new PermissionError(getMacOSPermissionMessage(dirPath, error.code), dirPath, error.code),
          };
        default:
          logger.debug('Directory permission check error:', error);
          return {
            hasPermission: false,
            error: error as Error,
          };
      }
    }
    return {
      hasPermission: false,
      error: error instanceof Error ? error : new Error(String(error)),
    };
  }
};

const getMacOSPermissionMessage = (dirPath: string, errorCode?: string): string => {
  if (platform() === 'darwin') {
    return `Permission denied: Cannot access '${dirPath}', error code: ${errorCode}.

This error often occurs when macOS security restrictions prevent access to the directory.
To fix this:

1. Open System Settings
2. Navigate to Privacy & Security > Files and Folders
3. Find your terminal app (Terminal.app, iTerm2, VS Code, etc.)
4. Grant necessary folder access permissions

If your terminal app is not listed:
- Try running repomix command again
- When prompted by macOS, click "Allow"
- Restart your terminal app if needed
`;
  }

  return `Permission denied: Cannot access '${dirPath}'`;
};
</file>

<file path="src/core/metrics/aggregateMetrics.ts">
import type { ProcessedFile } from '../file/fileTypes.js';
import type { TokenCounter } from '../tokenCount/tokenCount.js';
import type { FileMetrics } from './calculateIndividualFileMetrics.js';

export const aggregateMetrics = (
  fileMetrics: FileMetrics[],
  processedFiles: ProcessedFile[],
  output: string,
  tokenCounter: TokenCounter,
) => {
  const totalFiles = processedFiles.length;
  const totalCharacters = output.length;
  const totalTokens = tokenCounter.countTokens(output);

  const fileCharCounts: Record<string, number> = {};
  const fileTokenCounts: Record<string, number> = {};
  for (const file of fileMetrics) {
    fileCharCounts[file.path] = file.charCount;
    fileTokenCounts[file.path] = file.tokenCount;
  }

  return {
    totalFiles,
    totalCharacters,
    totalTokens,
    fileCharCounts,
    fileTokenCounts,
  };
};
</file>

<file path="src/core/metrics/calculateAllFileMetrics.ts">
import pMap from 'p-map';
import { getProcessConcurrency } from '../../shared/processConcurrency.js';
import type { RepomixProgressCallback } from '../../shared/types.js';
import type { ProcessedFile } from '../file/fileTypes.js';
import type { TokenCounter } from '../tokenCount/tokenCount.js';
import { type FileMetrics, calculateIndividualFileMetrics } from './calculateIndividualFileMetrics.js';

export const calculateAllFileMetrics = async (
  processedFiles: ProcessedFile[],
  tokenCounter: TokenCounter,
  progressCallback: RepomixProgressCallback,
): Promise<FileMetrics[]> => {
  return await pMap(
    processedFiles,
    (file, index) => calculateIndividualFileMetrics(file, index, processedFiles.length, tokenCounter, progressCallback),
    {
      concurrency: getProcessConcurrency(),
    },
  );
};
</file>

<file path="src/core/metrics/calculateIndividualFileMetrics.ts">
import { setTimeout } from 'node:timers/promises';
import pc from 'picocolors';
import type { RepomixProgressCallback } from '../../shared/types.js';
import type { ProcessedFile } from '../file/fileTypes.js';
import type { TokenCounter } from '../tokenCount/tokenCount.js';

export interface FileMetrics {
  path: string;
  charCount: number;
  tokenCount: number;
}

export const calculateIndividualFileMetrics = async (
  file: ProcessedFile,
  index: number,
  totalFiles: number,
  tokenCounter: TokenCounter,
  progressCallback: RepomixProgressCallback,
): Promise<FileMetrics> => {
  const charCount = file.content.length;
  const tokenCount = tokenCounter.countTokens(file.content, file.path);

  progressCallback(`Calculating metrics... (${index + 1}/${totalFiles}) ${pc.dim(file.path)}`);

  // Sleep for a short time to prevent blocking the event loop
  await setTimeout(1);

  return { path: file.path, charCount, tokenCount };
};
</file>

<file path="src/core/metrics/calculateMetrics.ts">
import { TiktokenEncoding } from 'tiktoken';
import type { RepomixConfigMerged } from '../../config/configSchema.js';
import type { RepomixProgressCallback } from '../../shared/types.js';
import type { ProcessedFile } from '../file/fileTypes.js';
import { TokenCounter } from '../tokenCount/tokenCount.js';
import { aggregateMetrics } from './aggregateMetrics.js';
import { calculateAllFileMetrics } from './calculateAllFileMetrics.js';

export interface CalculateMetricsResult {
  totalFiles: number;
  totalCharacters: number;
  totalTokens: number;
  fileCharCounts: Record<string, number>;
  fileTokenCounts: Record<string, number>;
}

export const calculateMetrics = async (
  processedFiles: ProcessedFile[],
  output: string,
  progressCallback: RepomixProgressCallback,
  config: RepomixConfigMerged,
): Promise<CalculateMetricsResult> => {
  const tokenCounter = new TokenCounter(config.tokenCount.encoding);

  progressCallback('Calculating metrics...');
  const fileMetrics = await calculateAllFileMetrics(processedFiles, tokenCounter, progressCallback);

  const result = aggregateMetrics(fileMetrics, processedFiles, output, tokenCounter);

  tokenCounter.free();

  return result;
};
</file>

<file path="src/core/output/outputStyles/markdownStyle.ts">
import Handlebars from 'handlebars';

export const getMarkdownTemplate = () => {
  return /* md */ `
{{{generationHeader}}}

{{#if fileSummaryEnabled}}
# File Summary

## Purpose
{{{summaryPurpose}}}

## File Format
{{{summaryFileFormat}}}
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
{{{summaryUsageGuidelines}}}

## Notes
{{{summaryNotes}}}

## Additional Info
{{#if headerText}}
### User Provided Header
{{{headerText}}}
{{/if}}

{{/if}}
{{#if directoryStructureEnabled}}
# Directory Structure
\`\`\`
{{{treeString}}}
\`\`\`

{{/if}}
# Files

{{#each processedFiles}}
## File: {{{this.path}}}
{{{../markdownCodeBlockDelimiter}}}{{{getFileExtension this.path}}}
{{{this.content}}}
{{{../markdownCodeBlockDelimiter}}}

{{/each}}

{{#if instruction}}
# Instruction
{{{instruction}}}
{{/if}}
`;
};

Handlebars.registerHelper('getFileExtension', (filePath) => {
  const extension = filePath.split('.').pop()?.toLowerCase();
  switch (extension) {
    case 'js':
    case 'jsx':
      return 'javascript';
    case 'ts':
    case 'tsx':
      return 'typescript';
    case 'vue':
      return 'vue';
    case 'py':
      return 'python';
    case 'rb':
      return 'ruby';
    case 'java':
      return 'java';
    case 'c':
    case 'cpp':
      return 'cpp';
    case 'cs':
      return 'csharp';
    case 'go':
      return 'go';
    case 'rs':
      return 'rust';
    case 'php':
      return 'php';
    case 'swift':
      return 'swift';
    case 'kt':
      return 'kotlin';
    case 'scala':
      return 'scala';
    case 'html':
      return 'html';
    case 'css':
      return 'css';
    case 'scss':
    case 'sass':
      return 'scss';
    case 'json':
      return 'json';
    case 'json5':
      return 'json5';
    case 'xml':
      return 'xml';
    case 'yaml':
    case 'yml':
      return 'yaml';
    case 'md':
      return 'markdown';
    case 'sh':
    case 'bash':
      return 'bash';
    case 'sql':
      return 'sql';
    case 'dockerfile':
      return 'dockerfile';
    case 'dart':
      return 'dart';
    case 'fs':
    case 'fsx':
      return 'fsharp';
    case 'r':
      return 'r';
    case 'pl':
    case 'pm':
      return 'perl';
    case 'lua':
      return 'lua';
    case 'groovy':
      return 'groovy';
    case 'hs':
      return 'haskell';
    case 'ex':
    case 'exs':
      return 'elixir';
    case 'erl':
      return 'erlang';
    case 'clj':
    case 'cljs':
      return 'clojure';
    case 'ps1':
      return 'powershell';
    case 'vb':
      return 'vb';
    case 'coffee':
      return 'coffeescript';
    case 'tf':
    case 'tfvars':
      return 'hcl';
    case 'proto':
      return 'protobuf';
    case 'pug':
      return 'pug';
    case 'graphql':
    case 'gql':
      return 'graphql';
    case 'toml':
      return 'toml';
    default:
      return '';
  }
});
</file>

<file path="src/core/output/outputStyles/plainStyle.ts">
const PLAIN_SEPARATOR = '='.repeat(16);
const PLAIN_LONG_SEPARATOR = '='.repeat(64);

export const getPlainTemplate = () => {
  return `
{{{generationHeader}}}

{{#if fileSummaryEnabled}}
${PLAIN_LONG_SEPARATOR}
File Summary
${PLAIN_LONG_SEPARATOR}

Purpose:
--------
{{{summaryPurpose}}}

File Format:
------------
{{{summaryFileFormat}}}
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
{{{summaryUsageGuidelines}}}

Notes:
------
{{{summaryNotes}}}

Additional Info:
----------------
{{#if headerText}}
User Provided Header:
-----------------------
{{{headerText}}}
{{/if}}

{{/if}}
{{#if directoryStructureEnabled}}
${PLAIN_LONG_SEPARATOR}
Directory Structure
${PLAIN_LONG_SEPARATOR}
{{{treeString}}}

{{/if}}
${PLAIN_LONG_SEPARATOR}
Files
${PLAIN_LONG_SEPARATOR}

{{#each processedFiles}}
${PLAIN_SEPARATOR}
File: {{{this.path}}}
${PLAIN_SEPARATOR}
{{{this.content}}}

{{/each}}

{{#if instruction}}
${PLAIN_LONG_SEPARATOR}
Instruction
${PLAIN_LONG_SEPARATOR}
{{{instruction}}}
{{/if}}

`;
};
</file>

<file path="src/core/output/outputStyles/xmlStyle.ts">
export const getXmlTemplate = () => {
  return /* xml */ `
{{{generationHeader}}}

{{#if fileSummaryEnabled}}
<file_summary>
This section contains a summary of this file.

<purpose>
{{{summaryPurpose}}}
</purpose>

<file_format>
{{{summaryFileFormat}}}
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
{{{summaryUsageGuidelines}}}
</usage_guidelines>

<notes>
{{{summaryNotes}}}
</notes>

<additional_info>
{{#if headerText}}
<user_provided_header>
{{{headerText}}}
</user_provided_header>
{{/if}}

</additional_info>

</file_summary>

{{/if}}
{{#if directoryStructureEnabled}}
<directory_structure>
{{{treeString}}}
</directory_structure>

{{/if}}
<files>
This section contains the contents of the repository's files.

{{#each processedFiles}}
<file path="{{{this.path}}}">
{{{this.content}}}
</file>

{{/each}}
</files>

{{#if instruction}}
<instruction>
{{{instruction}}}
</instruction>
{{/if}}
`;
};
</file>

<file path="src/core/output/outputGenerate.ts">
import fs from 'node:fs/promises';
import path from 'node:path';
import { XMLBuilder } from 'fast-xml-parser';
import Handlebars from 'handlebars';
import type { RepomixConfigMerged } from '../../config/configSchema.js';
import { RepomixError } from '../../shared/errorHandle.js';
import { searchFiles } from '../file/fileSearch.js';
import { generateTreeString } from '../file/fileTreeGenerate.js';
import type { ProcessedFile } from '../file/fileTypes.js';
import type { OutputGeneratorContext } from './outputGeneratorTypes.js';
import {
  generateHeader,
  generateSummaryFileFormat,
  generateSummaryNotes,
  generateSummaryPurpose,
  generateSummaryUsageGuidelines,
} from './outputStyleDecorate.js';
import { getMarkdownTemplate } from './outputStyles/markdownStyle.js';
import { getPlainTemplate } from './outputStyles/plainStyle.js';
import { getXmlTemplate } from './outputStyles/xmlStyle.js';

interface RenderContext {
  readonly generationHeader: string;
  readonly summaryPurpose: string;
  readonly summaryFileFormat: string;
  readonly summaryUsageGuidelines: string;
  readonly summaryNotes: string;
  readonly headerText: string | undefined;
  readonly instruction: string;
  readonly treeString: string;
  readonly processedFiles: ReadonlyArray<ProcessedFile>;
  readonly fileSummaryEnabled: boolean;
  readonly directoryStructureEnabled: boolean;
  readonly escapeFileContent: boolean;
  readonly markdownCodeBlockDelimiter: string;
}

const calculateMarkdownDelimiter = (files: ReadonlyArray<ProcessedFile>): string => {
  const maxBackticks = files
    .flatMap((file) => file.content.match(/`+/g) ?? [])
    .reduce((max, match) => Math.max(max, match.length), 0);
  return '`'.repeat(Math.max(3, maxBackticks + 1));
};

const createRenderContext = (outputGeneratorContext: OutputGeneratorContext): RenderContext => {
  return {
    generationHeader: generateHeader(outputGeneratorContext.generationDate),
    summaryPurpose: generateSummaryPurpose(),
    summaryFileFormat: generateSummaryFileFormat(),
    summaryUsageGuidelines: generateSummaryUsageGuidelines(
      outputGeneratorContext.config,
      outputGeneratorContext.instruction,
    ),
    summaryNotes: generateSummaryNotes(outputGeneratorContext.config),
    headerText: outputGeneratorContext.config.output.headerText,
    instruction: outputGeneratorContext.instruction,
    treeString: outputGeneratorContext.treeString,
    processedFiles: outputGeneratorContext.processedFiles,
    fileSummaryEnabled: outputGeneratorContext.config.output.fileSummary,
    directoryStructureEnabled: outputGeneratorContext.config.output.directoryStructure,
    escapeFileContent: outputGeneratorContext.config.output.parsableStyle,
    markdownCodeBlockDelimiter: calculateMarkdownDelimiter(outputGeneratorContext.processedFiles),
  };
};

const generateParsableXmlOutput = async (renderContext: RenderContext): Promise<string> => {
  const xmlBuilder = new XMLBuilder({ ignoreAttributes: false });
  const xmlDocument = {
    repomix: {
      '#text': renderContext.generationHeader,
      file_summary: renderContext.fileSummaryEnabled
        ? {
            '#text': 'This section contains a summary of this file.',
            purpose: renderContext.summaryPurpose,
            file_format: `${renderContext.summaryFileFormat}
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file`,
            usage_guidelines: renderContext.summaryUsageGuidelines,
            notes: renderContext.summaryNotes,
            additional_info: {
              user_provided_header: renderContext.headerText,
            },
          }
        : undefined,
      directory_structure: renderContext.directoryStructureEnabled ? renderContext.treeString : undefined,
      files: {
        '#text': "This section contains the contents of the repository's files.",
        file: renderContext.processedFiles.map((file) => ({
          '#text': file.content,
          '@_path': file.path,
        })),
      },
      instruction: renderContext.instruction ? renderContext.instruction : undefined,
    },
  };
  try {
    return xmlBuilder.build(xmlDocument);
  } catch (error) {
    throw new RepomixError(
      `Failed to generate XML output: ${error instanceof Error ? error.message : 'Unknown error'}`,
    );
  }
};

const generateHandlebarOutput = async (config: RepomixConfigMerged, renderContext: RenderContext): Promise<string> => {
  let template: string;
  switch (config.output.style) {
    case 'xml':
      template = getXmlTemplate();
      break;
    case 'markdown':
      template = getMarkdownTemplate();
      break;
    case 'plain':
      template = getPlainTemplate();
      break;
    default:
      throw new RepomixError(`Unknown output style: ${config.output.style}`);
  }

  try {
    const compiledTemplate = Handlebars.compile(template);
    return `${compiledTemplate(renderContext).trim()}\n`;
  } catch (error) {
    throw new RepomixError(`Failed to compile template: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
};

export const generateOutput = async (
  rootDir: string,
  config: RepomixConfigMerged,
  processedFiles: ProcessedFile[],
  allFilePaths: string[],
): Promise<string> => {
  const outputGeneratorContext = await buildOutputGeneratorContext(rootDir, config, allFilePaths, processedFiles);
  const renderContext = createRenderContext(outputGeneratorContext);

  if (!config.output.parsableStyle) return generateHandlebarOutput(config, renderContext);
  switch (config.output.style) {
    case 'xml':
      return generateParsableXmlOutput(renderContext);
    case 'markdown':
      return generateHandlebarOutput(config, renderContext);
    default:
      return generateHandlebarOutput(config, renderContext);
  }
};

export const buildOutputGeneratorContext = async (
  rootDir: string,
  config: RepomixConfigMerged,
  allFilePaths: string[],
  processedFiles: ProcessedFile[],
): Promise<OutputGeneratorContext> => {
  let repositoryInstruction = '';

  if (config.output.instructionFilePath) {
    const instructionPath = path.resolve(config.cwd, config.output.instructionFilePath);
    try {
      repositoryInstruction = await fs.readFile(instructionPath, 'utf-8');
    } catch {
      throw new RepomixError(`Instruction file not found at ${instructionPath}`);
    }
  }

  let emptyDirPaths: string[] = [];
  if (config.output.includeEmptyDirectories) {
    try {
      const searchResult = await searchFiles(rootDir, config);
      emptyDirPaths = searchResult.emptyDirPaths;
    } catch (error) {
      if (error instanceof Error) {
        throw new RepomixError(`Failed to search for empty directories: ${error.message}`);
      }
    }
  }
  return {
    generationDate: new Date().toISOString(),
    treeString: generateTreeString(allFilePaths, emptyDirPaths),
    processedFiles,
    config,
    instruction: repositoryInstruction,
  };
};
</file>

<file path="src/core/output/outputGeneratorTypes.ts">
import type { RepomixConfigMerged } from '../../config/configSchema.js';
import type { ProcessedFile } from '../file/fileTypes.js';

export interface OutputGeneratorContext {
  generationDate: string;
  treeString: string;
  processedFiles: ProcessedFile[];
  config: RepomixConfigMerged;
  instruction: string;
}
</file>

<file path="src/core/output/outputStyleDecorate.ts">
import type { RepomixConfigMerged } from '../../config/configSchema.js';

export const generateHeader = (generationDate: string): string => {
  return `
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: ${generationDate}
`.trim();
};

export const generateSummaryPurpose = (): string => {
  return `
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
`.trim();
};

export const generateSummaryFileFormat = (): string => {
  return `
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
`.trim();
};

export const generateSummaryUsageGuidelines = (config: RepomixConfigMerged, repositoryInstruction: string): string => {
  return `
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
${config.output.headerText ? '- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.' : ''}
${repositoryInstruction ? '- Pay special attention to the Repository Instruction. These contain important context and guidelines specific to this project.' : ''}
`.trim();
};

export const generateSummaryNotes = (config: RepomixConfigMerged): string => {
  return `
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
${config.output.removeComments ? '- Code comments have been removed.\n' : ''}
${config.output.showLineNumbers ? '- Line numbers have been added to the beginning of each line.\n' : ''}
`.trim();
};
</file>

<file path="src/core/packager/copyToClipboardIfEnabled.ts">
import clipboard from 'clipboardy';
import type { RepomixConfigMerged } from '../../config/configSchema.js';
import { logger } from '../../shared/logger.js';
import type { RepomixProgressCallback } from '../../shared/types.js';

// Additionally copy to clipboard if flag is raised
export const copyToClipboardIfEnabled = async (
  output: string,
  progressCallback: RepomixProgressCallback,
  config: RepomixConfigMerged,
): Promise<undefined> => {
  if (config.output.copyToClipboard) {
    progressCallback('Copying to clipboard...');
    logger.trace('Copying output to clipboard');
    await clipboard.write(output);
  }
};
</file>

<file path="src/core/packager/writeOutputToDisk.ts">
import fs from 'node:fs/promises';
import path from 'node:path';
import type { RepomixConfigMerged } from '../../config/configSchema.js';
import { logger } from '../../shared/logger.js';

// Write output to file. path is relative to the cwd
export const writeOutputToDisk = async (output: string, config: RepomixConfigMerged): Promise<undefined> => {
  const outputPath = path.resolve(config.cwd, config.output.filePath);
  logger.trace(`Writing output to: ${outputPath}`);
  await fs.writeFile(outputPath, output);
};
</file>

<file path="src/core/security/filterOutUntrustedFiles.ts">
import type { RawFile } from '../file/fileTypes.js';
import type { SuspiciousFileResult } from './securityCheck.js';

export const filterOutUntrustedFiles = (
  rawFiles: RawFile[],
  suspiciousFilesResults: SuspiciousFileResult[],
): RawFile[] =>
  rawFiles.filter((rawFile) => !suspiciousFilesResults.some((result) => result.filePath === rawFile.path));
</file>

<file path="src/core/security/runSecurityCheckIfEnabled.ts">
import type { RepomixConfigMerged } from '../../config/configSchema.js';
import type { RepomixProgressCallback } from '../../shared/types.js';
import type { RawFile } from '../file/fileTypes.js';
import { type SuspiciousFileResult, runSecurityCheck } from './securityCheck.js';

export const runSecurityCheckIfEnabled = async (
  rawFiles: RawFile[],
  config: RepomixConfigMerged,
  progressCallback: RepomixProgressCallback,
  deps = {
    runSecurityCheck,
  },
): Promise<SuspiciousFileResult[]> => {
  if (config.security.enableSecurityCheck) {
    progressCallback('Running security check...');
    return await deps.runSecurityCheck(rawFiles, progressCallback);
  }
  return [];
};
</file>

<file path="src/core/security/securityCheck.ts">
import { setTimeout } from 'node:timers/promises';
import { lintSource } from '@secretlint/core';
import { creator } from '@secretlint/secretlint-rule-preset-recommend';
import type { SecretLintCoreConfig, SecretLintCoreResult } from '@secretlint/types';
import pMap from 'p-map';
import pc from 'picocolors';
import { logger } from '../../shared/logger.js';
import { getProcessConcurrency } from '../../shared/processConcurrency.js';
import type { RepomixProgressCallback } from '../../shared/types.js';
import type { RawFile } from '../file/fileTypes.js';

export interface SuspiciousFileResult {
  filePath: string;
  messages: string[];
}

export const runSecurityCheck = async (
  rawFiles: RawFile[],
  progressCallback: RepomixProgressCallback = () => {},
): Promise<SuspiciousFileResult[]> => {
  const secretLintConfig = createSecretLintConfig();

  const results = await pMap(
    rawFiles,
    async (rawFile, index) => {
      progressCallback(`Running security check... (${index + 1}/${rawFiles.length}) ${pc.dim(rawFile.path)}`);

      logger.trace(`Checking security on ${rawFile.path}`);

      const processStartAt = process.hrtime.bigint();
      const secretLintResult = await runSecretLint(rawFile.path, rawFile.content, secretLintConfig);
      const processEndAt = process.hrtime.bigint();

      logger.trace(
        `Checked security on ${rawFile.path}. Took: ${(Number(processEndAt - processStartAt) / 1e6).toFixed(2)}ms`,
      );

      // Sleep for a short time to prevent blocking the event loop
      await setTimeout(1);

      if (secretLintResult.messages.length > 0) {
        return {
          filePath: rawFile.path,
          messages: secretLintResult.messages.map((message) => message.message),
        };
      }

      return null;
    },
    {
      concurrency: getProcessConcurrency(),
    },
  );

  return results.filter((result): result is SuspiciousFileResult => result != null);
};

export const runSecretLint = async (
  filePath: string,
  content: string,
  config: SecretLintCoreConfig,
): Promise<SecretLintCoreResult> => {
  const result = await lintSource({
    source: {
      filePath: filePath,
      content: content,
      ext: filePath.split('.').pop() || '',
      contentType: 'text',
    },
    options: {
      config: config,
    },
  });

  if (result.messages.length > 0) {
    logger.trace(`Found ${result.messages.length} issues in ${filePath}`);
    logger.trace(result.messages.map((message) => `  - ${message.message}`).join('\n'));
  }

  return result;
};

export const createSecretLintConfig = (): SecretLintCoreConfig => ({
  rules: [
    {
      id: '@secretlint/secretlint-rule-preset-recommend',
      rule: creator,
    },
  ],
});
</file>

<file path="src/core/security/validateFileSafety.ts">
import type { RepomixConfigMerged } from '../../config/configSchema.js';
import { logger } from '../../shared/logger.js';
import type { RepomixProgressCallback } from '../../shared/types.js';
import type { RawFile } from '../file/fileTypes.js';
import { filterOutUntrustedFiles } from './filterOutUntrustedFiles.js';
import { runSecurityCheckIfEnabled } from './runSecurityCheckIfEnabled.js';

// marks which files are suspicious and which are safe
export const validateFileSafety = async (
  rawFiles: RawFile[],
  progressCallback: RepomixProgressCallback,
  config: RepomixConfigMerged,
  deps = {
    runSecurityCheckIfEnabled,
    filterOutUntrustedFiles,
  },
) => {
  const suspiciousFilesResults = await deps.runSecurityCheckIfEnabled(rawFiles, config, progressCallback);
  const safeRawFiles = deps.filterOutUntrustedFiles(rawFiles, suspiciousFilesResults);
  const safeFilePaths = safeRawFiles.map((file) => file.path);
  logger.trace('Safe files count:', safeRawFiles.length);

  return {
    safeRawFiles,
    safeFilePaths,
    suspiciousFilesResults,
  };
};
</file>

<file path="src/core/tokenCount/tokenCount.ts">
import { type Tiktoken, type TiktokenEncoding, get_encoding } from 'tiktoken';
import { logger } from '../../shared/logger.js';

export class TokenCounter {
  private encoding: Tiktoken;

  constructor(encodingName: TiktokenEncoding) {
    // Setup encoding with the specified model
    this.encoding = get_encoding(encodingName);
  }

  public countTokens(content: string, filePath?: string): number {
    try {
      return this.encoding.encode(content).length;
    } catch (error) {
      let message = '';
      if (error instanceof Error) {
        message = error.message;
      } else {
        message = String(error);
      }

      if (filePath) {
        logger.warn(`Failed to count tokens. path: ${filePath}, error: ${message}`);
      } else {
        logger.warn(`Failed to count tokens. error: ${message}`);
      }

      return 0;
    }
  }

  public free(): void {
    this.encoding.free();
  }
}
</file>

<file path="src/core/packager.ts">
import type { RepomixConfigMerged } from '../config/configSchema.js';
import type { RepomixProgressCallback } from '../shared/types.js';
import { collectFiles } from './file/fileCollect.js';
import { processFiles } from './file/fileProcess.js';
import { searchFiles } from './file/fileSearch.js';
import { calculateMetrics } from './metrics/calculateMetrics.js';
import { generateOutput } from './output/outputGenerate.js';
import { copyToClipboardIfEnabled } from './packager/copyToClipboardIfEnabled.js';
import { writeOutputToDisk } from './packager/writeOutputToDisk.js';
import type { SuspiciousFileResult } from './security/securityCheck.js';
import { validateFileSafety } from './security/validateFileSafety.js';

export interface PackResult {
  totalFiles: number;
  totalCharacters: number;
  totalTokens: number;
  fileCharCounts: Record<string, number>;
  fileTokenCounts: Record<string, number>;
  suspiciousFilesResults: SuspiciousFileResult[];
}

export const pack = async (
  rootDir: string,
  config: RepomixConfigMerged,
  progressCallback: RepomixProgressCallback = () => {},
  deps = {
    searchFiles,
    collectFiles,
    processFiles,
    generateOutput,
    validateFileSafety,
    writeOutputToDisk,
    copyToClipboardIfEnabled,
    calculateMetrics,
  },
): Promise<PackResult> => {
  progressCallback('Searching for files...');
  const { filePaths } = await deps.searchFiles(rootDir, config);

  progressCallback('Collecting files...');
  const rawFiles = await deps.collectFiles(filePaths, rootDir);

  const { safeFilePaths, safeRawFiles, suspiciousFilesResults } = await deps.validateFileSafety(
    rawFiles,
    progressCallback,
    config,
  );

  // Process files (remove comments, etc.)
  progressCallback('Processing files...');
  const processedFiles = await deps.processFiles(safeRawFiles, config, progressCallback);

  progressCallback('Generating output...');
  const output = await deps.generateOutput(rootDir, config, processedFiles, safeFilePaths);

  progressCallback('Writing output file...');
  await deps.writeOutputToDisk(output, config);

  await deps.copyToClipboardIfEnabled(output, progressCallback, config);

  const metrics = await deps.calculateMetrics(processedFiles, output, progressCallback, config);

  return {
    ...metrics,
    suspiciousFilesResults,
  };
};
</file>

<file path="src/shared/errorHandle.ts">
import { z } from 'zod';
import { logger } from './logger.js';

export class RepomixError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'RepomixError';
  }
}

export class RepomixConfigValidationError extends RepomixError {
  constructor(message: string) {
    super(message);
    this.name = 'RepomixConfigValidationError';
  }
}

export const handleError = (error: unknown): void => {
  if (error instanceof RepomixError) {
    logger.error(`Error: ${error.message}`);
  } else if (error instanceof Error) {
    logger.error(`Unexpected error: ${error.message}`);
    logger.debug('Stack trace:', error.stack);
  } else {
    logger.error('An unknown error occurred');
  }

  logger.info('For more help, please visit: https://github.com/yamadashy/repomix/issues');
};

export const rethrowValidationErrorIfZodError = (error: unknown, message: string): void => {
  if (error instanceof z.ZodError) {
    const zodErrorText = error.errors.map((err) => `[${err.path.join('.')}] ${err.message}`).join('\n  ');
    throw new RepomixConfigValidationError(
      `${message}\n\n  ${zodErrorText}\n\n  Please check the config file and try again.`,
    );
  }
};
</file>

<file path="src/shared/logger.ts">
import util from 'node:util';
import pc from 'picocolors';

class Logger {
  private isVerbose = false;

  setVerbose(value: boolean) {
    this.isVerbose = value;
  }

  error(...args: unknown[]) {
    console.error(pc.red(this.formatArgs(args)));
  }

  warn(...args: unknown[]) {
    console.log(pc.yellow(this.formatArgs(args)));
  }

  success(...args: unknown[]) {
    console.log(pc.green(this.formatArgs(args)));
  }

  info(...args: unknown[]) {
    console.log(pc.cyan(this.formatArgs(args)));
  }

  note(...args: unknown[]) {
    console.log(pc.dim(this.formatArgs(args)));
  }

  debug(...args: unknown[]) {
    if (this.isVerbose) {
      console.log(pc.blue(this.formatArgs(args)));
    }
  }

  trace(...args: unknown[]) {
    if (this.isVerbose) {
      console.log(pc.gray(this.formatArgs(args)));
    }
  }

  log(...args: unknown[]) {
    console.log(...args);
  }

  private formatArgs(args: unknown[]): string {
    return args
      .map((arg) => (typeof arg === 'object' ? util.inspect(arg, { depth: null, colors: true }) : arg))
      .join(' ');
  }
}

export const logger = new Logger();
</file>

<file path="src/shared/processConcurrency.ts">
import os from 'node:os';

export const getProcessConcurrency = () => {
  const cpuCount = typeof os.availableParallelism === 'function' ? os.availableParallelism() : os.cpus().length;

  // Use all available CPUs except one
  return Math.max(1, cpuCount - 1);
};
</file>

<file path="src/shared/types.ts">
export type RepomixProgressCallback = (message: string) => void;
</file>

<file path="src/index.ts">
// CLI
export { run as cli } from './cli/cliRun.js';
export type { CliOptions } from './cli/cliRun.js';

// Config
export type { RepomixConfigFile as RepomixConfig } from './config/configSchema.js';

// Init action
export { runInitAction } from './cli/actions/initAction.js';

// Default action
export { runDefaultAction } from './cli/actions/defaultAction.js';
export { pack } from './core/packager.js';

// Remote action
export { runRemoteAction } from './cli/actions/remoteAction.js';
export { isValidRemoteValue } from './cli/actions/remoteAction.js';
</file>

<file path="tests/cli/actions/defaultAction.test.ts">
import process from 'node:process';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { runDefaultAction } from '../../../src/cli/actions/defaultAction.js';
import type { CliOptions } from '../../../src/cli/cliRun.js';
import * as configLoader from '../../../src/config/configLoad.js';
import * as packageJsonParser from '../../../src/core/file/packageJsonParse.js';
import * as packager from '../../../src/core/packager.js';

vi.mock('../../../src/core/packager');
vi.mock('../../../src/config/configLoad');
vi.mock('../../../src/core/file/packageJsonParse');
vi.mock('../../../src/shared/logger');

describe('defaultAction', () => {
  beforeEach(() => {
    vi.resetAllMocks();
    vi.mocked(packageJsonParser.getVersion).mockResolvedValue('1.0.0');
    vi.mocked(configLoader.loadFileConfig).mockResolvedValue({});
    vi.mocked(configLoader.mergeConfigs).mockReturnValue({
      cwd: process.cwd(),
      output: {
        filePath: 'output.txt',
        style: 'plain',
        parsableStyle: false,
        fileSummary: true,
        directoryStructure: true,
        topFilesLength: 5,
        showLineNumbers: false,
        removeComments: false,
        removeEmptyLines: false,
        copyToClipboard: false,
      },
      ignore: {
        useGitignore: true,
        useDefaultPatterns: true,
        customPatterns: [],
      },
      include: [],
      security: {
        enableSecurityCheck: true,
      },
      tokenCount: {
        encoding: 'o200k_base',
      },
    });
    vi.mocked(packager.pack).mockResolvedValue({
      totalFiles: 10,
      totalCharacters: 1000,
      totalTokens: 200,
      fileCharCounts: {},
      fileTokenCounts: {},
      suspiciousFilesResults: [],
    });
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  it('should run the default command successfully', async () => {
    const options: CliOptions = {
      output: 'custom-output.txt',
      verbose: true,
    };

    await runDefaultAction('.', process.cwd(), options);

    expect(configLoader.loadFileConfig).toHaveBeenCalled();
    expect(configLoader.mergeConfigs).toHaveBeenCalled();
    expect(packager.pack).toHaveBeenCalled();
  });

  it('should handle custom include patterns', async () => {
    const options: CliOptions = {
      include: '*.js,*.ts',
    };

    await runDefaultAction('.', process.cwd(), options);

    expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
      process.cwd(),
      expect.anything(),
      expect.objectContaining({
        include: ['*.js', '*.ts'],
      }),
    );
  });

  it('should handle custom ignore patterns', async () => {
    const options: CliOptions = {
      ignore: 'node_modules,*.log',
    };

    await runDefaultAction('.', process.cwd(), options);

    expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
      process.cwd(),
      expect.anything(),
      expect.objectContaining({
        ignore: {
          customPatterns: ['node_modules', '*.log'],
        },
      }),
    );
  });

  it('should handle custom output style', async () => {
    const options: CliOptions = {
      style: 'xml',
    };

    await runDefaultAction('.', process.cwd(), options);

    expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
      process.cwd(),
      expect.anything(),
      expect.objectContaining({
        output: expect.objectContaining({
          style: 'xml',
        }),
      }),
    );
  });

  it('should handle errors gracefully', async () => {
    vi.mocked(packager.pack).mockRejectedValue(new Error('Test error'));

    const options: CliOptions = {};

    await expect(runDefaultAction('.', process.cwd(), options)).rejects.toThrow('Test error');
  });

  describe('parsableStyle flag', () => {
    it('should handle --parsable-style flag', async () => {
      const options: CliOptions = {
        parsableStyle: true,
      };

      await runDefaultAction('.', process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: {
            parsableStyle: true,
          },
        }),
      );
    });

    it('should handle explicit --no-parsable-style flag', async () => {
      const options: CliOptions = {
        parsableStyle: false,
      };

      await runDefaultAction('.', process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: {
            parsableStyle: false,
          },
        }),
      );
    });
  });

  describe('security check flag', () => {
    it('should handle --no-security-check flag', async () => {
      const options: CliOptions = {
        securityCheck: false,
      };

      await runDefaultAction('.', process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          security: {
            enableSecurityCheck: false,
          },
        }),
      );
    });

    it('should handle explicit --security-check flag', async () => {
      const options: CliOptions = {
        securityCheck: true,
      };

      await runDefaultAction('.', process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          security: {
            enableSecurityCheck: true,
          },
        }),
      );
    });
  });

  describe('fileSummary flag', () => {
    it('should handle --no-file-summary flag', async () => {
      const options: CliOptions = {
        fileSummary: false,
      };

      await runDefaultAction('.', process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: {
            fileSummary: false,
          },
        }),
      );
    });

    it('should handle explicit --file-summary flag', async () => {
      const options: CliOptions = {
        fileSummary: true,
      };

      await runDefaultAction('.', process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: {
            fileSummary: true,
          },
        }),
      );
    });
  });

  describe('directoryStructure flag', () => {
    it('should handle --no-directory-structure flag', async () => {
      const options: CliOptions = {
        directoryStructure: false,
      };

      await runDefaultAction('.', process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: {
            directoryStructure: false,
          },
        }),
      );
    });

    it('should handle explicit --directory-structure flag', async () => {
      const options: CliOptions = {
        directoryStructure: true,
      };

      await runDefaultAction('.', process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: {
            directoryStructure: true,
          },
        }),
      );
    });
  });

  describe('removeComments flag', () => {
    it('should handle --remove-comments flag', async () => {
      const options: CliOptions = {
        removeComments: true,
      };

      await runDefaultAction('.', process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: {
            removeComments: true,
          },
        }),
      );
    });

    it('should handle explicit --no-remove-comments flag', async () => {
      const options: CliOptions = {
        removeComments: false,
      };

      await runDefaultAction('.', process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: {
            removeComments: false,
          },
        }),
      );
    });
  });

  describe('removeEmptyLines flag', () => {
    it('should handle --remove-empty-lines flag', async () => {
      const options: CliOptions = {
        removeEmptyLines: true,
      };

      await runDefaultAction('.', process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: {
            removeEmptyLines: true,
          },
        }),
      );
    });

    it('should handle explicit --no-remove-empty-lines flag', async () => {
      const options: CliOptions = {
        removeEmptyLines: false,
      };

      await runDefaultAction('.', process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: {
            removeEmptyLines: false,
          },
        }),
      );
    });
  });
});
</file>

<file path="tests/cli/actions/initAction.test.ts">
import * as fs from 'node:fs/promises';
import path from 'node:path';
import * as prompts from '@clack/prompts';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { createConfigFile, createIgnoreFile } from '../../../src/cli/actions/initAction.js';
import { getGlobalDirectory } from '../../../src/config/globalDirectory.js';

vi.mock('node:fs/promises');
vi.mock('@clack/prompts');
vi.mock('../../../src/shared/folderUtils');
vi.mock('../../../src/config/globalDirectory.js');

describe('initAction', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  describe('createConfigFile', () => {
    it('should create a new local config file when one does not exist', async () => {
      vi.mocked(fs.access).mockRejectedValue(new Error('File does not exist'));
      vi.mocked(prompts.group).mockResolvedValue({
        outputFilePath: 'custom-output.txt',
        outputStyle: 'xml',
      });
      vi.mocked(prompts.confirm).mockResolvedValue(true);

      await createConfigFile('/test/dir', false);

      const configPath = path.resolve('/test/dir/repomix.config.json');

      console.log('configPath', configPath);

      expect(fs.writeFile).toHaveBeenCalledWith(configPath, expect.stringContaining('"filePath": "custom-output.txt"'));
      expect(fs.writeFile).toHaveBeenCalledWith(configPath, expect.stringContaining('"style": "xml"'));
    });

    it('should create a new global config file when one does not exist', async () => {
      vi.mocked(fs.access).mockRejectedValue(new Error('File does not exist'));
      vi.mocked(prompts.group).mockResolvedValue({
        outputFilePath: 'global-output.txt',
        outputStyle: 'plain',
      });
      vi.mocked(prompts.confirm).mockResolvedValue(true);
      vi.mocked(getGlobalDirectory).mockImplementation(() => '/global/repomix');

      await createConfigFile('/test/dir', true);

      const configPath = path.resolve('/global/repomix/repomix.config.json');

      expect(fs.mkdir).toHaveBeenCalledWith(path.dirname(configPath), { recursive: true });
      expect(fs.writeFile).toHaveBeenCalledWith(configPath, expect.stringContaining('"filePath": "global-output.txt"'));
      expect(fs.writeFile).toHaveBeenCalledWith(configPath, expect.stringContaining('"style": "plain"'));
    });

    it('should prompt to overwrite when config file already exists', async () => {
      vi.mocked(fs.access).mockResolvedValue(undefined);
      vi.mocked(prompts.confirm).mockResolvedValue(true);
      vi.mocked(prompts.group).mockResolvedValue({
        outputFilePath: 'new-output.txt',
        outputStyle: 'xml',
      });

      await createConfigFile('/test/dir', false);

      expect(prompts.confirm).toHaveBeenCalled();
      expect(fs.writeFile).toHaveBeenCalled();
    });

    it('should not overwrite when user chooses not to', async () => {
      vi.mocked(fs.access).mockResolvedValue(undefined);
      vi.mocked(prompts.confirm).mockResolvedValue(false);

      await createConfigFile('/test/dir', false);

      expect(prompts.confirm).toHaveBeenCalled();
      expect(fs.writeFile).not.toHaveBeenCalled();
    });

    it('should handle user cancellation', async () => {
      vi.mocked(fs.access).mockRejectedValue(new Error('File does not exist'));
      vi.mocked(prompts.group).mockImplementation(() => {
        throw new Error('User cancelled');
      });

      await createConfigFile('/test/dir', false);

      expect(fs.writeFile).not.toHaveBeenCalled();
    });
  });

  describe('createIgnoreFile', () => {
    it('should not create a new .repomixignore file when global flag is set', async () => {
      const result = await createIgnoreFile('/test/dir', true);

      expect(result).toBe(false);
      expect(fs.writeFile).not.toHaveBeenCalled();
    });

    it('should create a new .repomixignore file when one does not exist', async () => {
      vi.mocked(fs.access).mockRejectedValue(new Error('File does not exist'));
      vi.mocked(prompts.confirm).mockResolvedValue(true);

      await createIgnoreFile('/test/dir', false);

      const ignorePath = path.resolve('/test/dir/.repomixignore');

      expect(fs.writeFile).toHaveBeenCalledWith(
        ignorePath,
        expect.stringContaining('# Add patterns to ignore here, one per line'),
      );
    });

    it('should prompt to overwrite when .repomixignore file already exists', async () => {
      vi.mocked(fs.access).mockResolvedValue(undefined);
      vi.mocked(prompts.confirm)
        .mockResolvedValueOnce(true) // First call for creating the file
        .mockResolvedValueOnce(true); // Second call for overwriting

      await createIgnoreFile('/test/dir', false);

      expect(prompts.confirm).toHaveBeenCalledTimes(2);
      expect(fs.writeFile).toHaveBeenCalled();
    });

    it('should not overwrite when user chooses not to', async () => {
      vi.mocked(fs.access).mockResolvedValue(undefined);
      vi.mocked(prompts.confirm)
        .mockResolvedValueOnce(true) // First call for creating the file
        .mockResolvedValueOnce(false); // Second call for overwriting

      await createIgnoreFile('/test/dir', false);

      expect(prompts.confirm).toHaveBeenCalledTimes(2);
      expect(fs.writeFile).not.toHaveBeenCalled();
    });

    it('should return false when user chooses not to create .repomixignore', async () => {
      vi.mocked(prompts.confirm).mockResolvedValue(false);

      const result = await createIgnoreFile('/test/dir', false);

      expect(result).toBe(false);
      expect(fs.writeFile).not.toHaveBeenCalled();
    });

    it('should handle user cancellation', async () => {
      vi.mocked(prompts.confirm).mockResolvedValue(false);

      await createIgnoreFile('/test/dir', false);

      expect(fs.writeFile).not.toHaveBeenCalled();
    });
  });
});
</file>

<file path="tests/cli/actions/migrationAction.test.ts">
import * as fs from 'node:fs/promises';
import path from 'node:path';
import * as prompts from '@clack/prompts';
import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
import { runMigrationAction } from '../../../src/cli/actions/migrationAction.js';
import { logger } from '../../../src/shared/logger.js';

vi.mock('node:fs/promises');
vi.mock('@clack/prompts');
vi.mock('../../../src/shared/logger');

describe('migrationAction', () => {
  const mockRootDir = '/test/dir';
  const oldConfigPath = path.join(mockRootDir, 'repopack.config.json');
  const newConfigPath = path.join(mockRootDir, 'repomix.config.json');
  const oldIgnorePath = path.join(mockRootDir, '.repopackignore');
  const newIgnorePath = path.join(mockRootDir, '.repomixignore');
  const oldInstructionPath = path.join(mockRootDir, 'repopack-instruction.md');
  const newInstructionPath = path.join(mockRootDir, 'repomix-instruction.md');
  const gitignorePath = path.join(mockRootDir, '.gitignore');

  const mockOutputPaths = {
    oldTxt: path.join(mockRootDir, 'repopack-output.txt'),
    newTxt: path.join(mockRootDir, 'repomix-output.txt'),
    oldXml: path.join(mockRootDir, 'repopack-output.xml'),
    newXml: path.join(mockRootDir, 'repomix-output.xml'),
    oldMd: path.join(mockRootDir, 'repopack-output.md'),
    newMd: path.join(mockRootDir, 'repomix-output.md'),
  };

  beforeEach(() => {
    vi.resetAllMocks();
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  test('should migrate all files when they exist', async () => {
    // Mock file existence checks
    vi.mocked(fs.access).mockImplementation(async (path) => {
      if (
        path === oldConfigPath ||
        path === oldIgnorePath ||
        path === oldInstructionPath ||
        path === mockOutputPaths.oldTxt ||
        path === mockOutputPaths.oldXml
      ) {
        return Promise.resolve();
      }
      return Promise.reject(new Error('File not found'));
    });

    // Mock file content
    const mockConfigContent = JSON.stringify({
      output: {
        filePath: 'repopack-output.txt',
        instructionFilePath: 'repopack-instruction.md',
      },
    });
    const mockIgnoreContent = 'repopack-output.txt\n*.log';
    const mockInstructionContent = '# Repopack Instructions';
    const mockOutputContent = 'Repopack output content';

    vi.mocked(fs.readFile).mockImplementation(async (path) => {
      if (path === oldConfigPath) return mockConfigContent;
      if (path === oldIgnorePath) return mockIgnoreContent;
      if (path === oldInstructionPath) return mockInstructionContent;
      if (path === mockOutputPaths.oldTxt || path === mockOutputPaths.oldXml) {
        return mockOutputContent;
      }
      return '';
    });

    // Mock user confirmation
    vi.mocked(prompts.confirm).mockResolvedValue(true);

    // Run migration
    const result = await runMigrationAction(mockRootDir);

    // Verify results
    expect(result.configMigrated).toBe(true);
    expect(result.ignoreMigrated).toBe(true);
    expect(result.instructionMigrated).toBe(true);
    expect(result.outputFilesMigrated).toContain(mockOutputPaths.newTxt);
    expect(result.outputFilesMigrated).toContain(mockOutputPaths.newXml);
    expect(result.error).toBeUndefined();

    // Verify file operations for config
    expect(fs.writeFile).toHaveBeenCalledWith(
      newConfigPath,
      JSON.stringify(
        {
          output: {
            filePath: 'repomix-output.txt',
            instructionFilePath: 'repomix-instruction.md',
          },
        },
        null,
        2,
      ),
      'utf8',
    );

    // Verify other file operations
    expect(fs.writeFile).toHaveBeenCalledWith(newIgnorePath, 'repomix-output.txt\n*.log', 'utf8');
    expect(fs.writeFile).toHaveBeenCalledWith(newInstructionPath, '# Repomix Instructions', 'utf8');

    // Verify old files were removed
    expect(fs.unlink).toHaveBeenCalledWith(oldConfigPath);
    expect(fs.unlink).toHaveBeenCalledWith(oldIgnorePath);
    expect(fs.unlink).toHaveBeenCalledWith(oldInstructionPath);
    expect(fs.unlink).toHaveBeenCalledWith(mockOutputPaths.oldTxt);
    expect(fs.unlink).toHaveBeenCalledWith(mockOutputPaths.oldXml);
  });

  test('should update gitignore content when it exists and contains repopack references', async () => {
    // Mock file existence only for gitignore and oldConfig
    vi.mocked(fs.access).mockImplementation(async (path) => {
      if (path === gitignorePath || path === oldConfigPath) {
        return Promise.resolve();
      }
      return Promise.reject(new Error('File not found'));
    });

    // Mock file content only for gitignore
    const mockGitignoreContent = 'node_modules/\nrepopack-output.txt';
    vi.mocked(fs.readFile).mockImplementation(async (path) => {
      if (path === gitignorePath) return mockGitignoreContent;
      if (path === oldConfigPath) return '{}';
      return '';
    });

    // Mock user confirmation
    vi.mocked(prompts.confirm).mockResolvedValue(true);

    // Run migration
    await runMigrationAction(mockRootDir);

    // Verify gitignore was updated
    expect(fs.writeFile).toHaveBeenCalledWith(gitignorePath, 'node_modules/\nrepomix-output.txt', 'utf8');
    expect(logger.log).toHaveBeenCalledWith(expect.stringContaining('Updated repopack references in'));
  });

  test('should handle non-updated files correctly', async () => {
    // Mock file existence only for gitignore and oldConfig
    vi.mocked(fs.access).mockImplementation(async (path) => {
      if (path === gitignorePath || path === oldConfigPath) {
        return Promise.resolve();
      }
      return Promise.reject(new Error('File not found'));
    });

    // Mock file content with no repopack references
    vi.mocked(fs.readFile).mockImplementation(async (path) => {
      if (path === gitignorePath) return 'node_modules/\n*.log';
      if (path === oldConfigPath) return '{}';
      return '';
    });

    // Mock user confirmation
    vi.mocked(prompts.confirm).mockResolvedValue(true);

    // Run migration
    await runMigrationAction(mockRootDir);

    // Verify no gitignore update was performed
    expect(fs.writeFile).not.toHaveBeenCalledWith(gitignorePath, expect.any(String), expect.any(String));
    // Verify debug message was logged
    expect(logger.debug).toHaveBeenCalledWith(expect.stringContaining('No changes needed in'));
  });

  test('should skip migration when no old files exist', async () => {
    // Mock all files not existing
    vi.mocked(fs.access).mockRejectedValue(new Error('File not found'));

    // Run migration
    const result = await runMigrationAction(mockRootDir);

    // Verify no migration occurred
    expect(result.configMigrated).toBe(false);
    expect(result.ignoreMigrated).toBe(false);
    expect(result.instructionMigrated).toBe(false);
    expect(result.outputFilesMigrated).toHaveLength(0);
    expect(prompts.confirm).not.toHaveBeenCalled();
    expect(logger.debug).toHaveBeenCalledWith('No Repopack files found to migrate.');
  });

  test('should skip files when they already exist and user declines overwrite', async () => {
    // Mock old and new files existing
    vi.mocked(fs.access).mockResolvedValue(undefined);

    // Mock user confirming migration but declining overwrites
    vi.mocked(prompts.confirm)
      .mockResolvedValueOnce(true) // Migration confirmation
      .mockResolvedValue(false); // All overwrite confirmations

    // Run migration
    const result = await runMigrationAction(mockRootDir);

    // Verify nothing was migrated
    expect(result.configMigrated).toBe(false);
    expect(result.ignoreMigrated).toBe(false);
    expect(result.instructionMigrated).toBe(false);
    expect(result.outputFilesMigrated).toHaveLength(0);
    expect(logger.info).toHaveBeenCalledWith(expect.stringContaining('Skipping migration'));
  });
});
</file>

<file path="tests/cli/actions/remoteAction.test.ts">
import * as fs from 'node:fs/promises';
import path from 'node:path';
import { beforeEach, describe, expect, test, vi } from 'vitest';
import {
  copyOutputToCurrentDirectory,
  formatRemoteValueToUrl,
  isValidRemoteValue,
  runRemoteAction,
} from '../../../src/cli/actions/remoteAction.js';

vi.mock('node:fs/promises', async (importOriginal) => {
  const actual = await importOriginal<typeof import('node:fs/promises')>();
  return {
    ...actual,
    copyFile: vi.fn(),
  };
});
vi.mock('../../../src/shared/logger');

describe('remoteAction functions', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  describe('runRemoteAction', () => {
    test('should clone the repository', async () => {
      vi.mocked(fs.copyFile).mockResolvedValue(undefined);
      await runRemoteAction(
        'yamadashy/repomix',
        {},
        {
          isGitInstalled: async () => Promise.resolve(true),
          execGitShallowClone: async (url: string, directory: string) => {
            await fs.writeFile(path.join(directory, 'README.md'), 'Hello, world!');
          },
        },
      );
    });
  });

  describe('formatGitUrl', () => {
    test('should convert GitHub shorthand to full URL', () => {
      expect(formatRemoteValueToUrl('user/repo')).toBe('https://github.com/user/repo.git');
      expect(formatRemoteValueToUrl('user-name/repo-name')).toBe('https://github.com/user-name/repo-name.git');
      expect(formatRemoteValueToUrl('user_name/repo_name')).toBe('https://github.com/user_name/repo_name.git');
      expect(formatRemoteValueToUrl('a.b/a-b_c')).toBe('https://github.com/a.b/a-b_c.git');
    });

    test('should handle HTTPS URLs', () => {
      expect(formatRemoteValueToUrl('https://github.com/user/repo')).toBe('https://github.com/user/repo.git');
      expect(formatRemoteValueToUrl('https://github.com/user/repo.git')).toBe('https://github.com/user/repo.git');
    });

    test('should not modify SSH URLs', () => {
      const sshUrl = 'git@github.com:user/repo.git';
      expect(formatRemoteValueToUrl(sshUrl)).toBe(sshUrl);
    });
  });

  describe('copyOutputToCurrentDirectory', () => {
    test('should copy output file', async () => {
      const sourceDir = '/source/dir';
      const targetDir = '/target/dir';
      const fileName = 'output.txt';

      vi.mocked(fs.copyFile).mockResolvedValue();

      await copyOutputToCurrentDirectory(sourceDir, targetDir, fileName);

      expect(fs.copyFile).toHaveBeenCalledWith(path.join(sourceDir, fileName), path.join(targetDir, fileName));
    });

    test('should throw error when copy fails', async () => {
      const sourceDir = '/source/dir';
      const targetDir = '/target/dir';
      const fileName = 'output.txt';

      vi.mocked(fs.copyFile).mockRejectedValue(new Error('Permission denied'));

      await expect(copyOutputToCurrentDirectory(sourceDir, targetDir, fileName)).rejects.toThrow(
        'Failed to copy output file',
      );
    });
  });

  describe('isValidRemoteValue', () => {
    describe('GitHub shorthand format (user/repo)', () => {
      test('should accept valid repository names', () => {
        // Test cases for valid repository names with various allowed characters
        const validUrls = [
          'user/repo',
          'user123/repo-name',
          'org-name/repo_name',
          'user.name/repo.test',
          'user_name/repo_test',
          'a/b', // Minimum length case
          'user-name123/repo-test123.sub_123', // Complex case
        ];

        for (const url of validUrls) {
          expect(isValidRemoteValue(url), `URL should be valid: ${url}`).toBe(true);
        }
      });

      test('should reject invalid repository names', () => {
        // Test cases for invalid patterns and disallowed characters
        const invalidUrls = [
          '', // Empty string
          'user', // Missing slash
          '/repo', // Missing username
          'user/', // Missing repository name
          '-user/repo', // Starts with hyphen
          'user/-repo', // Repository starts with hyphen
          'user./repo', // Username ends with dot
          'user/repo.', // Repository ends with dot
          'user/repo#branch', // Contains invalid character
          'user/repo/extra', // Extra path segment
          'us!er/repo', // Contains invalid character
          'user/re*po', // Contains invalid character
          'user//repo', // Double slash
          '.user/repo', // Starts with dot
          'user/.repo', // Repository starts with dot
        ];

        for (const url of invalidUrls) {
          expect(isValidRemoteValue(url), `URL should be invalid: ${url}`).toBe(false);
        }
      });
    });

    describe('Full URL format', () => {
      test('should accept valid URLs', () => {
        // Test cases for standard URL formats
        const validUrls = [
          'https://example.com',
          'http://localhost',
          'https://github.com/user/repo',
          'https://gitlab.com/user/repo',
          'https://domain.com/path/to/something',
        ];

        for (const url of validUrls) {
          expect(isValidRemoteValue(url), `URL should be valid: ${url}`).toBe(true);
        }
      });

      test('should reject invalid URLs', () => {
        // Test cases for malformed URLs
        const invalidUrls = ['not-a-url', 'http://', 'https://', '://no-protocol.com', 'http://[invalid]'];

        for (const url of invalidUrls) {
          expect(isValidRemoteValue(url), `URL should be invalid: ${url}`).toBe(false);
        }
      });
    });
  });
});
</file>

<file path="tests/cli/actions/versionAction.test.ts">
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { runVersionAction } from '../../../src/cli/actions/versionAction.js';
import * as packageJsonParser from '../../../src/core/file/packageJsonParse.js';
import { logger } from '../../../src/shared/logger.js';

vi.mock('../../../src/core/file/packageJsonParse');

describe('versionAction', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  it('should print the correct version', async () => {
    vi.mocked(packageJsonParser.getVersion).mockResolvedValue('1.2.3');

    const loggerSpy = vi.spyOn(logger, 'log').mockImplementation(vi.fn());
    await runVersionAction();

    expect(packageJsonParser.getVersion).toHaveBeenCalled();
    expect(loggerSpy).toHaveBeenCalledWith('1.2.3');
  });
});
</file>

<file path="tests/cli/cliPrint.test.ts">
import path from 'node:path';
import { beforeEach, describe, expect, test, vi } from 'vitest';
import { printCompletion, printSecurityCheck, printSummary, printTopFiles } from '../../src/cli/cliPrint.js';
import type { SuspiciousFileResult } from '../../src/core/security/securityCheck.js';
import { logger } from '../../src/shared/logger.js';
import { createMockConfig, isWindows } from '../testing/testUtils.js';

vi.mock('../../src/shared/logger');
vi.mock('picocolors', () => ({
  default: {
    white: (str: string) => `WHITE:${str}`,
    dim: (str: string) => `DIM:${str}`,
    green: (str: string) => `GREEN:${str}`,
    yellow: (str: string) => `YELLOW:${str}`,
    red: (str: string) => `RED:${str}`,
    cyan: (str: string) => `CYAN:${str}`,
    underline: (str: string) => `UNDERLINE:${str}`,
  },
}));

describe('cliPrint', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  describe('printSummary', () => {
    test('should print summary with suspicious files and security check enabled', () => {
      const config = createMockConfig({
        security: { enableSecurityCheck: true },
      });
      const suspiciousFiles: SuspiciousFileResult[] = [
        { filePath: 'suspicious.txt', messages: ['Contains sensitive data'] },
      ];

      printSummary(10, 1000, 200, 'output.txt', suspiciousFiles, config);

      expect(logger.log).toHaveBeenCalledWith(expect.stringContaining('1 suspicious file(s) detected and excluded'));
    });

    test('should print summary with security check disabled', () => {
      const config = createMockConfig({
        security: { enableSecurityCheck: false },
      });

      printSummary(10, 1000, 200, 'output.txt', [], config);

      expect(logger.log).toHaveBeenCalledWith(expect.stringContaining('Security check disabled'));
    });
  });

  describe('printSecurityCheck', () => {
    test('should skip printing when security check is disabled', () => {
      const config = createMockConfig({
        security: { enableSecurityCheck: false },
      });

      printSecurityCheck('/root', [], config);
      expect(logger.log).not.toHaveBeenCalled();
    });

    test('should print message when no suspicious files found', () => {
      const config = createMockConfig({
        security: { enableSecurityCheck: true },
      });

      printSecurityCheck('/root', [], config);

      expect(logger.log).toHaveBeenCalledWith('WHITE:🔎 Security Check:');
      expect(logger.log).toHaveBeenCalledWith('DIM:──────────────────');
      expect(logger.log).toHaveBeenCalledWith('GREEN:✔ WHITE:No suspicious files detected.');
    });

    test('should print details of suspicious files when found', () => {
      const config = createMockConfig({
        security: { enableSecurityCheck: true },
      });
      const configRelativePath = path.join('config', 'secrets.txt');
      const suspiciousFiles: SuspiciousFileResult[] = [
        {
          filePath: path.join('/root', configRelativePath),
          messages: ['Contains API key', 'Contains password'],
        },
      ];

      printSecurityCheck('/root', suspiciousFiles, config);

      expect(logger.log).toHaveBeenCalledWith('YELLOW:1 suspicious file(s) detected and excluded from the output:');
      expect(logger.log).toHaveBeenCalledWith(`WHITE:1. WHITE:${configRelativePath}`);
      expect(logger.log).toHaveBeenCalledWith(expect.stringContaining('Contains API key'));
      expect(logger.log).toHaveBeenCalledWith(expect.stringContaining('Contains password'));
      expect(logger.log).toHaveBeenCalledWith(
        expect.stringContaining('Please review these files for potential sensitive information.'),
      );
    });
  });

  describe('printTopFiles', () => {
    test('should print top files sorted by character count', () => {
      const fileCharCounts = {
        'src/index.ts': 1000,
        'src/utils.ts': 500,
        'README.md': 2000,
      };
      const fileTokenCounts = {
        'src/index.ts': 200,
        'src/utils.ts': 100,
        'README.md': 400,
      };

      printTopFiles(fileCharCounts, fileTokenCounts, 2);

      expect(logger.log).toHaveBeenCalledWith(expect.stringContaining('Top 2 Files'));
      expect(logger.log).toHaveBeenCalledWith(expect.stringContaining('README.md'));
      expect(logger.log).toHaveBeenCalledWith(expect.stringContaining('src/index.ts'));
      expect(logger.log).not.toHaveBeenCalledWith(expect.stringContaining('src/utils.ts'));
    });

    test('should handle empty file list', () => {
      printTopFiles({}, {}, 5);

      expect(logger.log).toHaveBeenCalledWith(expect.stringContaining('Top 5 Files'));
    });
  });

  describe('printCompletion', () => {
    test('should print completion message', () => {
      printCompletion();

      expect(logger.log).toHaveBeenCalledWith('GREEN:🎉 All Done!');
      expect(logger.log).toHaveBeenCalledWith('WHITE:Your repository has been successfully packed.');
    });
  });
});
</file>

<file path="tests/cli/cliRun.test.ts">
import { beforeEach, describe, expect, test, vi } from 'vitest';
import * as defaultAction from '../../src/cli/actions/defaultAction.js';
import * as initAction from '../../src/cli/actions/initAction.js';
import * as remoteAction from '../../src/cli/actions/remoteAction.js';
import * as versionAction from '../../src/cli/actions/versionAction.js';
import { executeAction, run } from '../../src/cli/cliRun.js';
import type { RepomixConfigMerged } from '../../src/config/configSchema.js';
import type { PackResult } from '../../src/core/packager.js';
import { logger } from '../../src/shared/logger.js';

vi.mock('../../src/shared/logger', () => ({
  logger: {
    log: vi.fn(),
    trace: vi.fn(),
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
    success: vi.fn(),
    note: vi.fn(),
    setVerbose: vi.fn(),
  },
}));

vi.mock('commander', () => ({
  program: {
    description: vi.fn().mockReturnThis(),
    arguments: vi.fn().mockReturnThis(),
    option: vi.fn().mockReturnThis(),
    action: vi.fn().mockReturnThis(),
    parseAsync: vi.fn().mockResolvedValue(undefined),
  },
}));

vi.mock('../../src/cli/actions/defaultAction');
vi.mock('../../src/cli/actions/initAction');
vi.mock('../../src/cli/actions/remoteAction');
vi.mock('../../src/cli/actions/versionAction');

describe('cliRun', () => {
  beforeEach(() => {
    vi.resetAllMocks();

    vi.mocked(defaultAction.runDefaultAction).mockResolvedValue({
      config: {
        cwd: process.cwd(),
        output: {
          filePath: 'repomix-output.txt',
          style: 'plain',
          parsableStyle: false,
          fileSummary: true,
          directoryStructure: true,
          topFilesLength: 5,
          showLineNumbers: false,
          removeComments: false,
          removeEmptyLines: false,
          copyToClipboard: false,
        },
        include: [],
        ignore: {
          useGitignore: true,
          useDefaultPatterns: true,
          customPatterns: [],
        },
        security: {
          enableSecurityCheck: true,
        },
        tokenCount: {
          encoding: 'o200k_base',
        },
      } satisfies RepomixConfigMerged,
      packResult: {
        totalFiles: 0,
        totalCharacters: 0,
        totalTokens: 0,
        fileCharCounts: {},
        fileTokenCounts: {},
        suspiciousFilesResults: [],
      } satisfies PackResult,
    });
    vi.mocked(initAction.runInitAction).mockResolvedValue();
    vi.mocked(remoteAction.runRemoteAction).mockResolvedValue({
      config: {
        cwd: process.cwd(),
        output: {
          filePath: 'repomix-output.txt',
          style: 'plain',
          parsableStyle: false,
          fileSummary: true,
          directoryStructure: true,
          topFilesLength: 5,
          showLineNumbers: false,
          removeComments: false,
          removeEmptyLines: false,
          copyToClipboard: false,
        },
        include: [],
        ignore: {
          useGitignore: true,
          useDefaultPatterns: true,
          customPatterns: [],
        },
        security: {
          enableSecurityCheck: true,
        },
        tokenCount: {
          encoding: 'o200k_base',
        },
      } satisfies RepomixConfigMerged,
      packResult: {
        totalFiles: 0,
        totalCharacters: 0,
        totalTokens: 0,
        fileCharCounts: {},
        fileTokenCounts: {},
        suspiciousFilesResults: [],
      } satisfies PackResult,
    });
    vi.mocked(versionAction.runVersionAction).mockResolvedValue();
  });

  test('should run without arguments', async () => {
    await expect(run()).resolves.not.toThrow();
  });

  describe('executeAction', () => {
    test('should execute default action when no special options provided', async () => {
      await executeAction('.', process.cwd(), {});

      expect(defaultAction.runDefaultAction).toHaveBeenCalledWith('.', process.cwd(), expect.any(Object));
    });

    test('should enable verbose logging when verbose option is true', async () => {
      await executeAction('.', process.cwd(), { verbose: true });

      expect(logger.setVerbose).toHaveBeenCalledWith(true);
    });

    test('should execute version action when version option is true', async () => {
      await executeAction('.', process.cwd(), { version: true });

      expect(versionAction.runVersionAction).toHaveBeenCalled();
      expect(defaultAction.runDefaultAction).not.toHaveBeenCalled();
    });

    test('should execute init action when init option is true', async () => {
      await executeAction('.', process.cwd(), { init: true });

      expect(initAction.runInitAction).toHaveBeenCalledWith(process.cwd(), false);
      expect(defaultAction.runDefaultAction).not.toHaveBeenCalled();
    });

    test('should execute remote action when remote option is provided', async () => {
      await executeAction('.', process.cwd(), { remote: 'yamadashy/repomix' });

      expect(remoteAction.runRemoteAction).toHaveBeenCalledWith('yamadashy/repomix', expect.any(Object));
      expect(defaultAction.runDefaultAction).not.toHaveBeenCalled();
    });
  });

  describe('parsable style flag', () => {
    test('should disable parsable style by default', async () => {
      await executeAction('.', process.cwd(), {});

      expect(defaultAction.runDefaultAction).toHaveBeenCalledWith(
        '.',
        process.cwd(),
        expect.not.objectContaining({
          parsableStyle: false,
        }),
      );
    });

    test('should handle --parsable-style flag', async () => {
      await executeAction('.', process.cwd(), { parsableStyle: true });

      expect(defaultAction.runDefaultAction).toHaveBeenCalledWith(
        '.',
        process.cwd(),
        expect.objectContaining({
          parsableStyle: true,
        }),
      );
    });
  });

  describe('security check flag', () => {
    test('should enable security check by default', async () => {
      await executeAction('.', process.cwd(), {});

      expect(defaultAction.runDefaultAction).toHaveBeenCalledWith(
        '.',
        process.cwd(),
        expect.not.objectContaining({
          securityCheck: false,
        }),
      );
    });

    test('should handle --no-security-check flag', async () => {
      await executeAction('.', process.cwd(), { securityCheck: false });

      expect(defaultAction.runDefaultAction).toHaveBeenCalledWith(
        '.',
        process.cwd(),
        expect.objectContaining({
          securityCheck: false,
        }),
      );
    });

    test('should handle explicit --security-check flag', async () => {
      await executeAction('.', process.cwd(), { securityCheck: true });

      expect(defaultAction.runDefaultAction).toHaveBeenCalledWith(
        '.',
        process.cwd(),
        expect.objectContaining({
          securityCheck: true,
        }),
      );
    });
  });
});
</file>

<file path="tests/config/configLoad.test.ts">
import type { Stats } from 'node:fs';
import * as fs from 'node:fs/promises';
import path from 'node:path';
import process from 'node:process';
import { beforeEach, describe, expect, test, vi } from 'vitest';
import { loadFileConfig, mergeConfigs } from '../../src/config/configLoad.js';
import type { RepomixConfigCli, RepomixConfigFile } from '../../src/config/configSchema.js';
import { getGlobalDirectory } from '../../src/config/globalDirectory.js';
import { RepomixConfigValidationError } from '../../src/shared/errorHandle.js';
import { logger } from '../../src/shared/logger.js';

vi.mock('node:fs/promises');
vi.mock('../../src/shared/logger', () => ({
  logger: {
    trace: vi.fn(),
    note: vi.fn(),
  },
}));
vi.mock('../../src/config/globalDirectory', () => ({
  getGlobalDirectory: vi.fn(),
}));

describe('configLoad', () => {
  beforeEach(() => {
    vi.resetAllMocks();
    process.env = {};
  });

  describe('loadFileConfig', () => {
    test('should load and parse a valid local config file', async () => {
      const mockConfig = {
        output: { filePath: 'test-output.txt' },
        ignore: { useDefaultPatterns: true },
      };
      vi.mocked(fs.readFile).mockResolvedValue(JSON.stringify(mockConfig));
      vi.mocked(fs.stat).mockResolvedValue({ isFile: () => true } as Stats);

      const result = await loadFileConfig(process.cwd(), 'test-config.json');
      expect(result).toEqual(mockConfig);
    });

    test('should throw RepomixConfigValidationError for invalid config', async () => {
      const invalidConfig = {
        output: { filePath: 123, style: 'invalid' }, // Invalid filePath type and invalid style
        ignore: { useDefaultPatterns: 'not a boolean' }, // Invalid type
      };
      vi.mocked(fs.readFile).mockResolvedValue(JSON.stringify(invalidConfig));
      vi.mocked(fs.stat).mockResolvedValue({ isFile: () => true } as Stats);

      await expect(loadFileConfig(process.cwd(), 'test-config.json')).rejects.toThrow(RepomixConfigValidationError);
    });

    test('should load global config when local config is not found', async () => {
      const mockGlobalConfig = {
        output: { filePath: 'global-output.txt' },
        ignore: { useDefaultPatterns: false },
      };
      vi.mocked(getGlobalDirectory).mockReturnValue('/global/repomix');
      vi.mocked(fs.stat)
        .mockRejectedValueOnce(new Error('File not found')) // Local config
        .mockResolvedValueOnce({ isFile: () => true } as Stats); // Global config
      vi.mocked(fs.readFile).mockResolvedValue(JSON.stringify(mockGlobalConfig));

      const result = await loadFileConfig(process.cwd(), null);
      expect(result).toEqual(mockGlobalConfig);
      expect(fs.readFile).toHaveBeenCalledWith(path.join('/global/repomix', 'repomix.config.json'), 'utf-8');
    });

    test('should return an empty object if no config file is found', async () => {
      const loggerSpy = vi.spyOn(logger, 'note').mockImplementation(vi.fn());
      vi.mocked(getGlobalDirectory).mockReturnValue('/global/repomix');
      vi.mocked(fs.stat).mockRejectedValue(new Error('File not found'));

      const result = await loadFileConfig(process.cwd(), null);
      expect(result).toEqual({});

      expect(loggerSpy).toHaveBeenCalledWith(expect.stringContaining('No custom config found'));
    });

    test('should throw an error for invalid JSON', async () => {
      vi.mocked(fs.readFile).mockResolvedValue('invalid json');
      vi.mocked(fs.stat).mockResolvedValue({ isFile: () => true } as Stats);

      await expect(loadFileConfig(process.cwd(), 'test-config.json')).rejects.toThrow('Invalid JSON');
    });

    test('should parse config file with comments', async () => {
      const configWithComments = `{
        // Output configuration
        "output": {
          "filePath": "test-output.txt"
        },
        /* Ignore configuration */
        "ignore": {
          "useGitignore": true // Use .gitignore file
        }
      }`;

      vi.mocked(fs.readFile).mockResolvedValue(configWithComments);
      vi.mocked(fs.stat).mockResolvedValue({ isFile: () => true } as Stats);

      const result = await loadFileConfig(process.cwd(), 'test-config.json');
      expect(result).toEqual({
        output: { filePath: 'test-output.txt' },
        ignore: { useGitignore: true },
      });
    });
  });

  describe('mergeConfigs', () => {
    test('should correctly merge configs', () => {
      const fileConfig: RepomixConfigFile = {
        output: { filePath: 'file-output.txt' },
        ignore: { useDefaultPatterns: true, customPatterns: ['file-ignore'] },
      };
      const cliConfig: RepomixConfigCli = {
        output: { filePath: 'cli-output.txt' },
        ignore: { customPatterns: ['cli-ignore'] },
      };

      const result = mergeConfigs(process.cwd(), fileConfig, cliConfig);

      expect(result.output.filePath).toBe('cli-output.txt');
      expect(result.ignore.useDefaultPatterns).toBe(true);
      expect(result.ignore.customPatterns).toContain('file-ignore');
      expect(result.ignore.customPatterns).toContain('cli-ignore');
    });

    test('should throw RepomixConfigValidationError for invalid merged config', () => {
      const fileConfig: RepomixConfigFile = {
        output: { filePath: 'file-output.txt', style: 'plain' },
      };
      const cliConfig: RepomixConfigCli = {
        // @ts-ignore
        output: { style: 'invalid' }, // Invalid style
      };

      expect(() => mergeConfigs(process.cwd(), fileConfig, cliConfig)).toThrow(RepomixConfigValidationError);
    });
  });
});
</file>

<file path="tests/config/configSchema.test.ts">
import { outro } from '@clack/prompts';
import { describe, expect, it } from 'vitest';
import { custom, z } from 'zod';
import {
  repomixConfigBaseSchema,
  repomixConfigCliSchema,
  repomixConfigDefaultSchema,
  repomixConfigFileSchema,
  repomixConfigMergedSchema,
  repomixOutputStyleSchema,
} from '../../src/config/configSchema.js';

describe('configSchema', () => {
  describe('repomixOutputStyleSchema', () => {
    it('should accept valid output styles', () => {
      expect(repomixOutputStyleSchema.parse('plain')).toBe('plain');
      expect(repomixOutputStyleSchema.parse('xml')).toBe('xml');
    });

    it('should reject invalid output styles', () => {
      expect(() => repomixOutputStyleSchema.parse('invalid')).toThrow(z.ZodError);
    });
  });

  describe('repomixConfigBaseSchema', () => {
    it('should accept valid base config', () => {
      const validConfig = {
        output: {
          filePath: 'output.txt',
          style: 'plain',
          removeComments: true,
        },
        include: ['**/*.js'],
        ignore: {
          useGitignore: true,
          customPatterns: ['node_modules'],
        },
        security: {
          enableSecurityCheck: true,
        },
      };
      expect(repomixConfigBaseSchema.parse(validConfig)).toEqual(validConfig);
    });

    it('should accept empty object', () => {
      expect(repomixConfigBaseSchema.parse({})).toEqual({});
    });

    it('should reject invalid types', () => {
      const invalidConfig = {
        output: {
          filePath: 123, // Should be string
          style: 'invalid', // Should be 'plain' or 'xml'
        },
        include: 'not-an-array', // Should be an array
      };
      expect(() => repomixConfigBaseSchema.parse(invalidConfig)).toThrow(z.ZodError);
    });
  });

  describe('repomixConfigDefaultSchema', () => {
    it('should accept valid default config', () => {
      const validConfig = {
        output: {
          filePath: 'output.txt',
          style: 'plain',
          parsableStyle: false,
          fileSummary: true,
          directoryStructure: true,
          removeComments: false,
          removeEmptyLines: false,
          topFilesLength: 5,
          showLineNumbers: false,
          copyToClipboard: true,
        },
        include: [],
        ignore: {
          customPatterns: [],
          useGitignore: true,
          useDefaultPatterns: true,
        },
        security: {
          enableSecurityCheck: true,
        },
        tokenCount: {
          encoding: 'o200k_base',
        },
      };
      expect(repomixConfigDefaultSchema.parse(validConfig)).toEqual(validConfig);
    });

    it('should reject incomplete config', () => {
      const validConfig = {};
      expect(() => repomixConfigDefaultSchema.parse(validConfig)).not.toThrow();
    });
  });

  describe('repomixConfigFileSchema', () => {
    it('should accept valid file config', () => {
      const validConfig = {
        output: {
          filePath: 'custom-output.txt',
          style: 'xml',
        },
        ignore: {
          customPatterns: ['*.log'],
        },
      };
      expect(repomixConfigFileSchema.parse(validConfig)).toEqual(validConfig);
    });

    it('should accept partial config', () => {
      const partialConfig = {
        output: {
          filePath: 'partial-output.txt',
        },
      };
      expect(repomixConfigFileSchema.parse(partialConfig)).toEqual(partialConfig);
    });
  });

  describe('repomixConfigCliSchema', () => {
    it('should accept valid CLI config', () => {
      const validConfig = {
        output: {
          filePath: 'cli-output.txt',
          showLineNumbers: true,
        },
        include: ['src/**/*.ts'],
      };
      expect(repomixConfigCliSchema.parse(validConfig)).toEqual(validConfig);
    });

    it('should reject invalid CLI options', () => {
      const invalidConfig = {
        output: {
          filePath: 123, // Should be string
        },
      };
      expect(() => repomixConfigCliSchema.parse(invalidConfig)).toThrow(z.ZodError);
    });
  });

  describe('repomixConfigMergedSchema', () => {
    it('should accept valid merged config', () => {
      const validConfig = {
        cwd: '/path/to/project',
        output: {
          filePath: 'merged-output.txt',
          style: 'plain',
          parsableStyle: false,
          fileSummary: true,
          directoryStructure: true,
          removeComments: true,
          removeEmptyLines: false,
          topFilesLength: 10,
          showLineNumbers: true,
          copyToClipboard: false,
        },
        include: ['**/*.js', '**/*.ts'],
        ignore: {
          useGitignore: true,
          useDefaultPatterns: true,
          customPatterns: ['*.log'],
        },
        security: {
          enableSecurityCheck: true,
        },
        tokenCount: {
          encoding: 'o200k_base',
        },
      };
      expect(repomixConfigMergedSchema.parse(validConfig)).toEqual(validConfig);
    });

    it('should reject merged config missing required fields', () => {
      const invalidConfig = {
        output: {
          filePath: 'output.txt',
          // Missing required fields
        },
      };
      expect(() => repomixConfigMergedSchema.parse(invalidConfig)).toThrow(z.ZodError);
    });

    it('should reject merged config with invalid types', () => {
      const invalidConfig = {
        cwd: '/path/to/project',
        output: {
          filePath: 'output.txt',
          style: 'plain',
          removeComments: 'not-a-boolean', // Should be boolean
          removeEmptyLines: false,
          topFilesLength: '5', // Should be number
          showLineNumbers: false,
        },
        include: ['**/*.js'],
        ignore: {
          useGitignore: true,
          useDefaultPatterns: true,
        },
        security: {
          enableSecurityCheck: true,
        },
      };
      expect(() => repomixConfigMergedSchema.parse(invalidConfig)).toThrow(z.ZodError);
    });
  });
});
</file>

<file path="tests/config/globalDirectory.test.ts">
import os from 'node:os';
import path from 'node:path';
import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
import { getGlobalDirectory } from '../../src/config/globalDirectory.js';

vi.mock('node:os');

describe('getGlobalDirectory', () => {
  const originalPlatform = process.platform;
  const originalEnv = process.env;

  beforeEach(() => {
    vi.resetAllMocks();
    process.env = { ...originalEnv };
  });

  afterEach(() => {
    Object.defineProperty(process, 'platform', { value: originalPlatform });
    process.env = originalEnv;
  });

  describe('Windows platform', () => {
    test('should use LOCALAPPDATA when available', () => {
      Object.defineProperty(process, 'platform', { value: 'win32' });
      process.env.LOCALAPPDATA = 'C:\\Users\\Test\\AppData\\Local';

      const result = getGlobalDirectory();
      expect(result).toBe(path.join('C:\\Users\\Test\\AppData\\Local', 'Repomix'));
    });

    test('should fall back to homedir when LOCALAPPDATA is not available', () => {
      Object.defineProperty(process, 'platform', { value: 'win32' });
      process.env.LOCALAPPDATA = undefined;
      vi.mocked(os.homedir).mockReturnValue('C:\\Users\\Test');

      const result = getGlobalDirectory();
      expect(result).toBe(path.join('C:\\Users\\Test', 'AppData', 'Local', 'Repomix'));
    });
  });

  describe('Unix platforms', () => {
    test('should use XDG_CONFIG_HOME when available', () => {
      Object.defineProperty(process, 'platform', { value: 'linux' });
      process.env.XDG_CONFIG_HOME = '/custom/config';

      const result = getGlobalDirectory();
      expect(result).toBe(path.join('/custom/config', 'repomix'));
    });

    test('should fall back to ~/.config on Linux', () => {
      Object.defineProperty(process, 'platform', { value: 'linux' });
      process.env.XDG_CONFIG_HOME = undefined;
      vi.mocked(os.homedir).mockReturnValue('/home/test');

      const result = getGlobalDirectory();
      expect(result).toBe(path.join('/home/test', '.config', 'repomix'));
    });

    test('should fall back to ~/.config on macOS', () => {
      Object.defineProperty(process, 'platform', { value: 'darwin' });
      process.env.XDG_CONFIG_HOME = undefined;
      vi.mocked(os.homedir).mockReturnValue('/Users/test');

      const result = getGlobalDirectory();
      expect(result).toBe(path.join('/Users/test', '.config', 'repomix'));
    });
  });

  describe('Edge cases', () => {
    test('should handle empty homedir', () => {
      Object.defineProperty(process, 'platform', { value: 'linux' });
      process.env.XDG_CONFIG_HOME = undefined;
      vi.mocked(os.homedir).mockReturnValue('');

      const result = getGlobalDirectory();
      expect(result).toBe(path.join('', '.config', 'repomix'));
    });

    test('should handle unusual XDG_CONFIG_HOME paths', () => {
      Object.defineProperty(process, 'platform', { value: 'linux' });
      process.env.XDG_CONFIG_HOME = '////multiple///slashes///';

      const result = getGlobalDirectory();
      expect(result).toBe(path.join('////multiple///slashes///', 'repomix'));
    });
  });
});
</file>

<file path="tests/core/file/fileCollect.test.ts">
import * as fs from 'node:fs/promises';
import path from 'node:path';
import iconv from 'iconv-lite';
import { isBinary } from 'istextorbinary';
import jschardet from 'jschardet';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { collectFiles } from '../../../src/core/file/fileCollect.js';
import { logger } from '../../../src/shared/logger.js';

vi.mock('node:fs/promises');
vi.mock('istextorbinary');
vi.mock('jschardet');
vi.mock('iconv-lite');
vi.mock('../../../src/shared/logger');

describe('fileCollect', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  it('should collect non-binary files', async () => {
    const mockFilePaths = ['file1.txt', 'file2.txt'];
    const mockRootDir = '/root';

    vi.mocked(isBinary).mockReturnValue(false);
    vi.mocked(fs.readFile).mockResolvedValue(Buffer.from('file content'));
    vi.mocked(jschardet.detect).mockReturnValue({ encoding: 'utf-8', confidence: 0.99 });
    vi.mocked(iconv.decode).mockReturnValue('decoded content');

    const result = await collectFiles(mockFilePaths, mockRootDir);

    expect(result).toEqual([
      { path: 'file1.txt', content: 'decoded content' },
      { path: 'file2.txt', content: 'decoded content' },
    ]);
  });

  it('should skip binary files', async () => {
    const mockFilePaths = ['binary.bin', 'text.txt'];
    const mockRootDir = '/root';

    vi.mocked(isBinary).mockReturnValueOnce(true).mockReturnValueOnce(false);
    vi.mocked(fs.readFile).mockResolvedValue(Buffer.from('file content'));
    vi.mocked(jschardet.detect).mockReturnValue({ encoding: 'utf-8', confidence: 0.99 });
    vi.mocked(iconv.decode).mockReturnValue('decoded content');

    const result = await collectFiles(mockFilePaths, mockRootDir);

    expect(result).toEqual([{ path: 'text.txt', content: 'decoded content' }]);
    expect(logger.debug).toHaveBeenCalledWith(`Skipping binary file: ${path.resolve('/root/binary.bin')}`);
  });

  it('should handle file read errors', async () => {
    const mockFilePaths = ['error.txt'];
    const mockRootDir = '/root';

    vi.mocked(isBinary).mockReturnValue(false);
    vi.mocked(fs.readFile).mockRejectedValue(new Error('Read error'));

    const result = await collectFiles(mockFilePaths, mockRootDir);

    expect(result).toEqual([]);
    expect(logger.warn).toHaveBeenCalledWith(
      `Failed to read file: ${path.resolve('/root/error.txt')}`,
      expect.any(Error),
    );
  });
});
</file>

<file path="tests/core/file/fileManipulate.test.ts">
import { describe, expect, test } from 'vitest';
import { getFileManipulator } from '../../../src/core/file/fileManipulate.js';

describe('fileManipulate', () => {
  const testCases = [
    {
      name: 'C comment removal',
      ext: '.c',
      input: `
        // Single line comment
        int main() {
          /* Multi-line
             comment */
          return 0;
        }
      `,
      expected: `

        int main() {


          return 0;
        }
`,
    },
    {
      name: 'C# comment removal',
      ext: '.cs',
      input: `
        // Single line comment
        public class Test {
          /* Multi-line
             comment */
          public void Method() {}
        }
      `,
      expected: `

        public class Test {


          public void Method() {}
        }
`,
    },
    {
      name: 'CSS comment removal',
      ext: '.css',
      input: `
        /* Comment */
        body {
          color: red; /* Inline comment */
        }
      `,
      expected: `

        body {
          color: red;
        }
`,
    },
    {
      name: 'HTML comment removal',
      ext: '.html',
      input: '<div><!-- Comment -->Content</div>',
      expected: '<div>Content</div>',
    },
    {
      name: 'Java comment removal',
      ext: '.java',
      input: `
        // Single line comment
        public class Test {
          /* Multi-line
             comment */
          public void method() {}
        }
      `,
      expected: `

        public class Test {


          public void method() {}
        }
`,
    },
    {
      name: 'JavaScript comment removal',
      ext: '.js',
      input: `
        // Single line comment
        function test() {
          /* Multi-line
             comment */
          return true;
        }
      `,
      expected: `

        function test() {


          return true;
        }
`,
    },
    {
      name: 'Less comment removal',
      ext: '.less',
      input: `
        // Single line comment
        @variable: #888;
        /* Multi-line
           comment */
        body { color: @variable; }
      `,
      expected: `

        @variable: #888;


        body { color: @variable; }
`,
    },
    {
      name: 'PHP comment removal',
      ext: '.php',
      input: `
        <?php
        // Single line comment
        # Another single line comment
        function test() {
          /* Multi-line
             comment */
          return true;
        }
        ?>
      `,
      expected: `
        <?php


        function test() {


          return true;
        }
        ?>
`,
    },
    {
      name: 'Python comment, docstring removal',
      ext: '.py',
      input: `
        # Single line comment
        def test():
          '''
          docstring
          '''
          return True
        """
        Another docstring
        """
      `,
      expected: `

        def test():

          return True

`,
    },
    {
      name: 'Python docstring removal mixing string declaration',
      ext: '.py',
      input: `
        var = """
        string variable
        """
        """
        docstring
        """
      `,
      expected: `
        var = """
        string variable
        """

`,
    },
    {
      name: 'Python comment f-string is not removed',
      ext: '.py',
      input: `
        # Single line comment
        def test():
          f'f-string'
          f"""
          f-string
          """
          return True
      `,
      expected: `

        def test():
          f'f-string'
          f"""
          f-string
          """
          return True
`,
    },
    {
      name: 'Python comment multi-line string literal is not removed',
      ext: '.py',
      input: `
        def test():
          hoge = """
          multi-line
          string
          """
          return True
      `,
      expected: `
        def test():
          hoge = """
          multi-line
          string
          """
          return True
`,
    },
    {
      name: 'Python nested quotes',
      ext: '.py',
      input: `
        """
        '''
        docstring
        '''
        """
      `,
      expected: `

`,
    },
    {
      name: 'Python nested triple quotes with different types',
      ext: '.py',
      input: `
      def func():
        """
        Outer docstring
        '''
        Inner single quotes
        '''
        Still in outer docstring
        """
        return True
    `,
      expected: `
      def func():

        return True
`,
    },
    {
      name: 'Python inline comments',
      ext: '.py',
      input: `
      x = 5  # This is an inline comment
      y = 10  # Another inline comment
      z = x + y
    `,
      expected: `
      x = 5
      y = 10
      z = x + y
`,
    },
    {
      name: 'Python multi-line statement with string',
      ext: '.py',
      input: `
      long_string = "This is a long string that spans " \\
                    "multiple lines in the code, " \\
                    "but is actually a single string"
      # Comment after multi-line statement
    `,
      expected: `
      long_string = "This is a long string that spans " \\
                    "multiple lines in the code, " \\
                    "but is actually a single string"

`,
    },
    {
      name: 'Python docstring with triple quotes inside string literals',
      ext: '.py',
      input: `
      def func():
        """This is a docstring"""
        x = "This is not a docstring: '''"
        y = '"""This is also not a docstring: """'
        return x + y
    `,
      expected: `
      def func():

        x = "This is not a docstring: '''"
        y = '"""This is also not a docstring: """'
        return x + y
`,
    },
    {
      name: 'Python mixed comments and docstrings',
      ext: '.py',
      input: `
      # This is a comment
      def func():
        '''
        This is a docstring
        '''
        x = 5  # Inline comment
        """
        This is another docstring
        """
        # Another comment
        return x
    `,
      expected: `

      def func():

        x = 5


        return x
`,
    },
    {
      name: 'Python f-strings with triple quotes',
      ext: '.py',
      input: `
      x = 10
      y = 20
      f"""
      This f-string contains a calculation: {x + y}
      """
      # Comment after f-string
    `,
      expected: `
      x = 10
      y = 20
      f"""
      This f-string contains a calculation: {x + y}
      """

`,
    },
    {
      name: 'Python escaped hash in string',
      ext: '.py',
      input: `
      text = "This string contains an \# escaped hash"
      # This is a real comment
    `,
      expected: `
      text = "This string contains an \# escaped hash"

`,
    },
    {
      name: 'Python nested function with docstrings',
      ext: '.py',
      input: `
      def outer():
        """Outer docstring"""
        def inner():
          """Inner docstring"""
          pass
        return inner
    `,
      expected: `
      def outer():

        def inner():

          pass
        return inner
`,
    },
    {
      name: 'Python comment-like content in string',
      ext: '.py',
      input: `
      x = "This is not a # comment"
      y = 'Neither is this # comment'
      z = """
      This is not a # comment
      Neither is this # comment
      """
    `,
      expected: `
      x = "This is not a # comment"
      y = 'Neither is this # comment'
      z = """
      This is not a # comment
      Neither is this # comment
      """
`,
    },
    {
      name: 'Python docstring with backslashes',
      ext: '.py',
      input: `
      def func():
        """
        This docstring has \\ backslashes
        It shouldn't \\""" confuse the parser
        """
        return True
    `,
      expected: `
      def func():

        return True
`,
    },
    {
      name: 'Python mixed single and double quotes',
      ext: '.py',
      input: `
      x = '\"\"\""'  # This is not a docstring start
      y = "'''"  # Neither is this
      """But this is a docstring"""
    `,
      expected: `
      x = '\"\"\""'
      y = "'''"

`,
    },
    {
      name: 'Ruby comment removal',
      ext: '.rb',
      input: `
        # Single line comment
        def test
          =begin
          Multi-line comment
          =end
          true
        end
      `,
      expected: `

        def test



          true
        end
`,
    },
    {
      name: 'Sass comment removal',
      ext: '.sass',
      input: `
        // Single line comment
        $variable: #888
        /* Multi-line
           comment */
        body
          color: $variable
      `,
      expected: `

        $variable: #888


        body
          color: $variable
`,
    },
    {
      name: 'SCSS comment removal',
      ext: '.scss',
      input: `
        // Single line comment
        $variable: #888;
        /* Multi-line
           comment */
        body { color: $variable; }
      `,
      expected: `

        $variable: #888;


        body { color: $variable; }
`,
    },
    {
      name: 'SQL comment removal',
      ext: '.sql',
      input: `
        -- Single line comment
        SELECT * FROM table WHERE id = 1;
      `,
      expected: `

        SELECT * FROM table WHERE id = 1;
`,
    },
    {
      name: 'Swift comment removal',
      ext: '.swift',
      input: `
        // Single line comment
        func test() {
          /* Multi-line
             comment */
          return true
        }
      `,
      expected: `

        func test() {


          return true
        }
`,
    },
    {
      name: 'TypeScript comment removal',
      ext: '.ts',
      input: `
        // Single line comment
        function test(): boolean {
          /* Multi-line
             comment */
          return true;
        }
      `,
      expected: `

        function test(): boolean {


          return true;
        }
`,
    },
    {
      name: 'XML comment removal',
      ext: '.xml',
      input: '<root><!-- Comment --><element>Content</element></root>',
      expected: '<root><element>Content</element></root>',
    },
    {
      name: 'Dart comment removal',
      ext: '.dart',
      input: `
        // Single line comment
        void main() {
          /* Multi-line
             comment */
          print('Hello');
        }
      `,
      expected: `

        void main() {


          print('Hello');
        }
`,
    },
    {
      name: 'Go comment removal',
      ext: '.go',
      input: `
        // Single line comment
        func main() {
          /* Multi-line
             comment */
          fmt.Println("Hello")
        }
      `,
      expected: `

        func main() {


          fmt.Println("Hello")
        }
`,
    },
    {
      name: 'Kotlin comment removal',
      ext: '.kt',
      input: `
        // Single line comment
        fun main() {
          /* Multi-line
             comment */
          println("Hello")
        }
      `,
      expected: `

        fun main() {


          println("Hello")
        }
`,
    },
    {
      name: 'Rust comment removal',
      ext: '.rs',
      input: `
        // Single line comment
        fn main() {
          /* Multi-line
             comment */
          println!("Hello");
        }
      `,
      expected: `

        fn main() {


          println!("Hello");
        }
`,
    },
    {
      name: 'Shell script comment removal',
      ext: '.sh',
      input: `
        # Single line comment
        echo "Hello"
      `,
      expected: `

        echo "Hello"
`,
    },
    {
      name: 'YAML comment removal',
      ext: '.yml',
      input: `
        key: value  # Comment
        another_key: another_value
      `,
      expected: `
        key: value
        another_key: another_value
`,
    },
    {
      name: 'Vue file comment removal',
      ext: '.vue',
      input: `
        <template>
          <!-- HTML comment -->
          <div>{{ message }}</div>
        </template>
        <script>
        // JavaScript comment
        export default {
          data() {
            return {
              message: 'Hello'
            }
          }
        }
        </script>
        <style>
        /* CSS comment */
        .test { color: red; }
        </style>
      `,
      expected: `
        <template>

          <div>{{ message }}</div>
        </template>
        <script>

        export default {
          data() {
            return {
              message: 'Hello'
            }
          }
        }
        </script>
        <style>

        .test { color: red; }
        </style>
`,
    },
    {
      name: 'Svelte file comment removal',
      ext: '.svelte',
      input: `
        <!-- HTML comment -->
        <div>{message}</div>
        <script>
        // JavaScript comment
        let message = 'Hello';
        </script>
        <style>
        /* CSS comment */
        div { color: red; }
        </style>
      `,
      expected: `

        <div>{message}</div>
        <script>

        let message = 'Hello';
        </script>
        <style>

        div { color: red; }
        </style>
`,
    },
  ];

  for (const { name, ext, input, expected } of testCases) {
    test(name, () => {
      const manipulator = getFileManipulator(`test${ext}`);
      expect(manipulator?.removeComments(input)).toBe(expected);
    });
  }

  test('Unsupported file type', () => {
    const manipulator = getFileManipulator('test.unsupported');
    expect(manipulator).toBeNull();
  });
});
</file>

<file path="tests/core/file/filePathSort.test.ts">
import path from 'node:path';
import { describe, expect, test } from 'vitest';
import { sortPaths } from '../../../src/core/file/filePathSort.js';

describe('filePathSort', () => {
  const sep = path.sep;

  test('should sort directories before files', () => {
    const input = ['file.txt', `dir${sep}`, 'another_file.js', `another_dir${sep}`];
    const expected = [`another_dir${sep}`, `dir${sep}`, 'another_file.js', 'file.txt'];
    expect(sortPaths(input)).toEqual(expected);
  });

  test('should sort subdirectories correctly', () => {
    const input = [`dir${sep}subdir${sep}file.txt`, `dir${sep}file.js`, `dir${sep}subdir${sep}`, 'file.txt'];
    const expected = [`dir${sep}subdir${sep}`, `dir${sep}subdir${sep}file.txt`, `dir${sep}file.js`, 'file.txt'];
    expect(sortPaths(input)).toEqual(expected);
  });

  test('should sort files alphabetically within the same directory', () => {
    const input = [`dir${sep}c.txt`, `dir${sep}a.txt`, `dir${sep}b.txt`];
    const expected = [`dir${sep}a.txt`, `dir${sep}b.txt`, `dir${sep}c.txt`];
    expect(sortPaths(input)).toEqual(expected);
  });

  test('should handle empty input', () => {
    expect(sortPaths([])).toEqual([]);
  });

  test('should handle complex directory structure', () => {
    const input = [
      `src${sep}utils${sep}file3.ts`,
      `src${sep}index.ts`,
      `tests${sep}utils${sep}a.ts`,
      `src${sep}utils${sep}b.ts`,
      'package.json',
      'README.md',
      `src${sep}components${sep}Component.tsx`,
    ];
    const expected = [
      `src${sep}components${sep}Component.tsx`,
      `src${sep}utils${sep}b.ts`,
      `src${sep}utils${sep}file3.ts`,
      `src${sep}index.ts`,
      `tests${sep}utils${sep}a.ts`,
      'package.json',
      'README.md',
    ];
    expect(sortPaths(input)).toEqual(expected);
  });

  test('should handle paths with multiple separators', () => {
    const input = [`a${sep}b${sep}c`, `a${sep}b`, `a${sep}b${sep}`];
    const expected = [`a${sep}b`, `a${sep}b${sep}`, `a${sep}b${sep}c`];
    expect(sortPaths(input)).toEqual(expected);
  });

  test('should be case-insensitive', () => {
    const input = [`B${sep}`, `a${sep}`, 'C', 'd'];
    const expected = [`a${sep}`, `B${sep}`, 'C', 'd'];
    expect(sortPaths(input)).toEqual(expected);
  });
});
</file>

<file path="tests/core/file/fileProcess.test.ts">
import { describe, expect, it, vi } from 'vitest';
import { getFileManipulator } from '../../../src/core/file/fileManipulate.js';
import { processContent, processFiles } from '../../../src/core/file/fileProcess.js';
import type { RawFile } from '../../../src/core/file/fileTypes.js';
import { createMockConfig } from '../../testing/testUtils.js';

vi.mock('../../../src/core/file/fileManipulate');

describe('fileProcess', () => {
  describe('processFiles', () => {
    it('should process multiple files', async () => {
      const mockRawFiles: RawFile[] = [
        { path: 'file1.js', content: '// comment\nconst a = 1;' },
        { path: 'file2.js', content: '/* comment */\nconst b = 2;' },
      ];
      const config = createMockConfig({
        output: {
          removeComments: true,
          removeEmptyLines: true,
        },
      });

      vi.mocked(getFileManipulator).mockReturnValue({
        removeComments: (content: string) => content.replace(/\/\/.*|\/\*[\s\S]*?\*\//g, ''),
        removeEmptyLines: (content: string) => content.replace(/^\s*[\r\n]/gm, ''),
      });

      const result = await processFiles(mockRawFiles, config, () => {});

      expect(result).toEqual([
        { path: 'file1.js', content: 'const a = 1;' },
        { path: 'file2.js', content: 'const b = 2;' },
      ]);
    });
  });

  describe('processContent', () => {
    it('should remove comments and empty lines when configured', async () => {
      const content = '// comment\nconst a = 1;\n\n/* multi-line\ncomment */\nconst b = 2;';
      const filePath = 'test.js';
      const config = createMockConfig({
        output: {
          removeComments: true,
          removeEmptyLines: true,
        },
      });

      vi.mocked(getFileManipulator).mockReturnValue({
        removeComments: (content: string) => content.replace(/\/\/.*|\/\*[\s\S]*?\*\//g, ''),
        removeEmptyLines: (content: string) => content.replace(/^\s*[\r\n]/gm, ''),
      });

      const result = await processContent(content, filePath, config);

      expect(result).toBe('const a = 1;\nconst b = 2;');
    });

    it('should not remove comments or empty lines when not configured', async () => {
      const content = '// comment\nconst a = 1;\n\n/* multi-line\ncomment */\nconst b = 2;';
      const filePath = 'test.js';
      const config = createMockConfig({
        output: {
          removeComments: false,
          removeEmptyLines: false,
        },
      });

      const result = await processContent(content, filePath, config);

      expect(result).toBe(content.trim());
    });

    it('should handle files without a manipulator', async () => {
      const content = 'Some content';
      const filePath = 'unknown.ext';
      const config = createMockConfig({
        output: {
          removeComments: true,
          removeEmptyLines: true,
        },
      });

      vi.mocked(getFileManipulator).mockReturnValue(null);

      const result = await processContent(content, filePath, config);

      expect(result).toBe(content);
    });

    it('should add line numbers when showLineNumbers is true', async () => {
      const content = 'Line 1\nLine 2\nLine 3';
      const filePath = 'test.txt';
      const config = createMockConfig({
        output: {
          showLineNumbers: true,
          removeComments: false,
          removeEmptyLines: false,
        },
      });

      const result = await processContent(content, filePath, config);

      expect(result).toBe('1: Line 1\n2: Line 2\n3: Line 3');
    });

    it('should not add line numbers when showLineNumbers is false', async () => {
      const content = 'Line 1\nLine 2\nLine 3';
      const filePath = 'test.txt';
      const config = createMockConfig({
        output: {
          showLineNumbers: false,
          removeComments: false,
          removeEmptyLines: false,
        },
      });

      const result = await processContent(content, filePath, config);

      expect(result).toBe('Line 1\nLine 2\nLine 3');
    });

    it('should handle empty content when showLineNumbers is true', async () => {
      const content = '';
      const filePath = 'empty.txt';
      const config = createMockConfig({
        output: {
          showLineNumbers: true,
          removeComments: false,
          removeEmptyLines: false,
        },
      });

      const result = await processContent(content, filePath, config);

      expect(result).toBe('1: ');
    });

    it('should pad line numbers correctly for files with many lines', async () => {
      const content = Array(100).fill('Line').join('\n');
      const filePath = 'long.txt';
      const config = createMockConfig({
        output: {
          showLineNumbers: true,
          removeComments: false,
          removeEmptyLines: false,
        },
      });

      const result = await processContent(content, filePath, config);

      const lines = result.split('\n');
      expect(lines[0]).toBe('  1: Line');
      expect(lines[9]).toBe(' 10: Line');
      expect(lines[99]).toBe('100: Line');
    });
  });
});
</file>

<file path="tests/core/file/fileSearch.test.ts">
import type { Stats } from 'node:fs';
import * as fs from 'node:fs/promises';
import path from 'node:path';
import process from 'node:process';
import { globby } from 'globby';
import { minimatch } from 'minimatch';
import { beforeEach, describe, expect, test, vi } from 'vitest';
import {
  getIgnoreFilePatterns,
  getIgnorePatterns,
  parseIgnoreContent,
  searchFiles,
} from '../../../src/core/file/fileSearch.js';
import { createMockConfig, isWindows } from '../../testing/testUtils.js';

vi.mock('fs/promises');
vi.mock('globby');

describe('fileSearch', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  describe('getIgnoreFilePaths', () => {
    test('should return correct paths when .gitignore and .repomixignore exist', async () => {
      vi.mocked(fs.access).mockResolvedValue(undefined);
      const mockConfig = createMockConfig({
        ignore: {
          useGitignore: true,
          useDefaultPatterns: true,
          customPatterns: [],
        },
      });
      const filePatterns = await getIgnoreFilePatterns(mockConfig);
      expect(filePatterns).toEqual(['**/.gitignore', '**/.repomixignore']);
    });

    test('should not include .gitignore when useGitignore is false', async () => {
      vi.mocked(fs.access).mockResolvedValue(undefined);
      const mockConfig = createMockConfig({
        ignore: {
          useGitignore: false,
          useDefaultPatterns: true,
          customPatterns: [],
        },
      });
      const filePatterns = await getIgnoreFilePatterns(mockConfig);
      expect(filePatterns).toEqual(['**/.repomixignore']);
    });

    test('should handle empty directories when enabled', async () => {
      const mockConfig = createMockConfig({
        output: {
          includeEmptyDirectories: true,
        },
      });

      const mockFilePaths = ['src/file1.js', 'src/file2.js'];
      const mockEmptyDirs = ['src/empty', 'empty-root'];

      vi.mocked(globby).mockImplementation(async (_, options) => {
        if (options?.onlyDirectories) {
          return mockEmptyDirs;
        }
        return mockFilePaths;
      });

      vi.mocked(fs.readdir).mockResolvedValue([]);

      const result = await searchFiles('/mock/root', mockConfig);

      expect(result.filePaths).toEqual(mockFilePaths);
      expect(result.emptyDirPaths.sort()).toEqual(mockEmptyDirs.sort());
    });

    test('should not collect empty directories when disabled', async () => {
      const mockConfig = createMockConfig({
        output: {
          includeEmptyDirectories: false,
        },
      });

      const mockFilePaths = ['src/file1.js', 'src/file2.js'];

      vi.mocked(globby).mockImplementation(async (_, options) => {
        if (options?.onlyDirectories) {
          throw new Error('Should not search for directories when disabled');
        }
        return mockFilePaths;
      });

      const result = await searchFiles('/mock/root', mockConfig);

      expect(result.filePaths).toEqual(mockFilePaths);
      expect(result.emptyDirPaths).toEqual([]);
      expect(globby).toHaveBeenCalledTimes(1);
    });
  });

  describe('getIgnorePatterns', () => {
    test('should return default patterns when useDefaultPatterns is true', async () => {
      const mockConfig = createMockConfig({
        ignore: {
          useGitignore: true,
          useDefaultPatterns: true,
          customPatterns: [],
        },
      });

      const patterns = await getIgnorePatterns(process.cwd(), mockConfig);

      expect(patterns.length).toBeGreaterThan(0);
      expect(patterns).toContain('**/node_modules/**');
    });

    test('should include custom patterns', async () => {
      const mockConfig = createMockConfig({
        ignore: {
          useGitignore: true,
          useDefaultPatterns: false,
          customPatterns: ['*.custom', 'temp/'],
        },
      });

      const patterns = await getIgnorePatterns(process.cwd(), mockConfig);

      expect(patterns).toEqual(['repomix-output.txt', '*.custom', 'temp/']);
    });

    test('should combine default and custom patterns', async () => {
      const mockConfig = createMockConfig({
        ignore: {
          useGitignore: true,
          useDefaultPatterns: true,
          customPatterns: ['*.custom', 'temp/'],
        },
      });

      const patterns = await getIgnorePatterns(process.cwd(), mockConfig);

      expect(patterns).toContain('**/node_modules/**');
      expect(patterns).toContain('*.custom');
      expect(patterns).toContain('temp/');
    });
  });

  describe('parseIgnoreContent', () => {
    test('should correctly parse ignore content', () => {
      const content = `
# Comment
node_modules
*.log

.DS_Store
      `;

      const patterns = parseIgnoreContent(content);

      expect(patterns).toEqual(['node_modules', '*.log', '.DS_Store']);
    });

    test('should handle mixed line endings', () => {
      const content = 'node_modules\n*.log\r\n.DS_Store\r';

      const patterns = parseIgnoreContent(content);

      expect(patterns).toEqual(['node_modules', '*.log', '.DS_Store']);
    });
  });

  describe('filterFiles', () => {
    beforeEach(() => {
      vi.resetAllMocks();
    });

    test('should call globby with correct parameters', async () => {
      const mockConfig = createMockConfig({
        include: ['**/*.js'],
        ignore: {
          useGitignore: true,
          useDefaultPatterns: false,
          customPatterns: ['*.custom'],
        },
      });

      vi.mocked(globby).mockResolvedValue(['file1.js', 'file2.js']);
      vi.mocked(fs.access).mockResolvedValue(undefined);

      await searchFiles('/mock/root', mockConfig);

      expect(globby).toHaveBeenCalledWith(
        ['**/*.js'],
        expect.objectContaining({
          cwd: '/mock/root',
          ignore: expect.arrayContaining(['*.custom']),
          ignoreFiles: expect.arrayContaining(['**/.gitignore', '**/.repomixignore']),
          onlyFiles: true,
          absolute: false,
          dot: true,
          followSymbolicLinks: false,
        }),
      );
    });

    test.runIf(!isWindows)('Honor .gitignore files in subdirectories', async () => {
      const mockConfig = createMockConfig({
        include: ['**/*.js'],
        ignore: {
          useGitignore: true,
          useDefaultPatterns: false,
          customPatterns: [],
        },
      });

      const mockFileStructure = [
        'root/file1.js',
        'root/subdir/file2.js',
        'root/subdir/ignored.js',
        'root/another/file3.js',
      ];

      const mockGitignoreContent = {
        '/mock/root/.gitignore': '*.log',
        '/mock/root/subdir/.gitignore': 'ignored.js',
      };

      vi.mocked(globby).mockImplementation(async () => {
        // Simulate filtering files based on .gitignore
        return mockFileStructure.filter((file) => {
          const relativePath = file.replace('root/', '');
          const dir = path.dirname(relativePath);
          const gitignorePath = path.join('/mock/root', dir, '.gitignore');
          const gitignoreContent = mockGitignoreContent[gitignorePath as keyof typeof mockGitignoreContent];
          if (gitignoreContent && minimatch(path.basename(file), gitignoreContent)) {
            return false;
          }
          return true;
        });
      });

      vi.mocked(fs.readFile).mockImplementation(async (filePath) => {
        return mockGitignoreContent[filePath as keyof typeof mockGitignoreContent] || '';
      });

      const result = await searchFiles('/mock/root', mockConfig);
      expect(result.filePaths).toEqual(['root/another/file3.js', 'root/subdir/file2.js', 'root/file1.js']);
      expect(result.filePaths).not.toContain('root/subdir/ignored.js');
      expect(result.emptyDirPaths).toEqual([]);
    });

    test('should not apply .gitignore when useGitignore is false', async () => {
      const mockConfig = createMockConfig({
        include: ['**/*.js'],
        ignore: {
          useGitignore: false,
          useDefaultPatterns: false,
          customPatterns: [],
        },
      });

      const mockFileStructure = [
        'root/file1.js',
        'root/another/file3.js',
        'root/subdir/file2.js',
        'root/subdir/ignored.js',
      ];

      vi.mocked(globby).mockResolvedValue(mockFileStructure);

      const result = await searchFiles('/mock/root', mockConfig);

      expect(result.filePaths).toEqual(mockFileStructure);
      expect(result.filePaths).toContain('root/subdir/ignored.js');
      expect(result.emptyDirPaths).toEqual([]);
    });

    test('should handle git worktree correctly', async () => {
      // Mock .git file content for worktree
      const gitWorktreeContent = 'gitdir: /path/to/main/repo/.git/worktrees/feature-branch';

      // Mock fs.stat and fs.readFile for .git file
      vi.mocked(fs.stat).mockResolvedValue({
        isFile: () => true,
      } as Stats);
      vi.mocked(fs.readFile).mockResolvedValue(gitWorktreeContent);

      // Mock globby to return some test files
      vi.mocked(globby).mockResolvedValue(['file1.js', 'file2.js']);

      const mockConfig = createMockConfig({
        ignore: {
          useGitignore: true,
          useDefaultPatterns: true,
          customPatterns: [],
        },
      });

      const result = await searchFiles('/test/dir', mockConfig);

      // Check that globby was called with correct ignore patterns
      const globbyCall = vi.mocked(globby).mock.calls[0];
      const ignorePatterns = globbyCall[1]?.ignore as string[];

      // Verify .git file (not directory) is in ignore patterns
      expect(ignorePatterns).toContain('.git');
      // Verify .git/** is not in ignore patterns
      expect(ignorePatterns).not.toContain('.git/**');

      // Verify the files were returned correctly
      expect(result.filePaths).toEqual(['file1.js', 'file2.js']);
    });

    test('should handle regular git repository correctly', async () => {
      // Mock .git as a directory
      vi.mocked(fs.stat).mockResolvedValue({
        isFile: () => false,
      } as Stats);

      // Mock globby to return some test files
      vi.mocked(globby).mockResolvedValue(['file1.js', 'file2.js']);

      const mockConfig = createMockConfig({
        ignore: {
          useGitignore: true,
          useDefaultPatterns: true,
          customPatterns: [],
        },
      });

      const result = await searchFiles('/test/dir', mockConfig);

      // Check that globby was called with correct ignore patterns
      const globbyCall = vi.mocked(globby).mock.calls[0];
      const ignorePatterns = globbyCall[1]?.ignore as string[];

      // Verify .git/** is in ignore patterns for regular git repos
      expect(ignorePatterns).toContain('.git/**');
      // Verify just .git is not in ignore patterns
      expect(ignorePatterns).not.toContain('.git');

      // Verify the files were returned correctly
      expect(result.filePaths).toEqual(['file1.js', 'file2.js']);
    });
  });
});
</file>

<file path="tests/core/file/gitCommand.test.ts">
import { beforeEach, describe, expect, test, vi } from 'vitest';
import { execGitShallowClone, isGitInstalled } from '../../../src/core/file/gitCommand.js';
import { logger } from '../../../src/shared/logger.js';

vi.mock('../../../src/shared/logger');

describe('gitCommand', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  describe('isGitInstalled', () => {
    test('should return true when git is installed', async () => {
      const mockFileExecAsync = vi.fn().mockResolvedValue({ stdout: 'git version 2.34.1', stderr: '' });

      const result = await isGitInstalled({ execFileAsync: mockFileExecAsync });

      expect(result).toBe(true);
      expect(mockFileExecAsync).toHaveBeenCalledWith('git', ['--version']);
    });

    test('should return false when git command fails', async () => {
      const mockFileExecAsync = vi.fn().mockRejectedValue(new Error('Command not found: git'));

      const result = await isGitInstalled({ execFileAsync: mockFileExecAsync });

      expect(result).toBe(false);
      expect(mockFileExecAsync).toHaveBeenCalledWith('git', ['--version']);
      expect(logger.trace).toHaveBeenCalledWith('Git is not installed:', 'Command not found: git');
    });

    test('should return false when git command returns stderr', async () => {
      const mockFileExecAsync = vi.fn().mockResolvedValue({ stdout: '', stderr: 'git: command not found' });

      const result = await isGitInstalled({ execFileAsync: mockFileExecAsync });

      expect(result).toBe(false);
      expect(mockFileExecAsync).toHaveBeenCalledWith('git', ['--version']);
    });
  });

  describe('execGitShallowClone', () => {
    test('should execute without branch option if not specified by user', async () => {
      const mockFileExecAsync = vi.fn().mockResolvedValue({ stdout: '', stderr: '' });
      const url = 'https://github.com/user/repo.git';
      const directory = '/tmp/repo';
      const remoteBranch = undefined;

      await execGitShallowClone(url, directory, remoteBranch, { execFileAsync: mockFileExecAsync });

      expect(mockFileExecAsync).toHaveBeenCalledWith('git', ['clone', '--depth', '1', url, directory]);
    });

    test('should throw error when git clone fails', async () => {
      const mockFileExecAsync = vi.fn().mockRejectedValue(new Error('Authentication failed'));
      const url = 'https://github.com/user/repo.git';
      const directory = '/tmp/repo';
      const remoteBranch = undefined;

      await expect(
        execGitShallowClone(url, directory, remoteBranch, { execFileAsync: mockFileExecAsync }),
      ).rejects.toThrow('Authentication failed');

      expect(mockFileExecAsync).toHaveBeenCalledWith('git', ['clone', '--depth', '1', url, directory]);
    });

    test('should execute commands correctly when branch is specified', async () => {
      const mockFileExecAsync = vi.fn().mockResolvedValue({ stdout: '', stderr: '' });

      const url = 'https://github.com/user/repo.git';
      const directory = '/tmp/repo';
      const remoteBranch = 'main';

      await execGitShallowClone(url, directory, remoteBranch, { execFileAsync: mockFileExecAsync });

      expect(mockFileExecAsync).toHaveBeenCalledTimes(4);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(1, 'git', ['-C', directory, 'init']);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(2, 'git', ['-C', directory, 'remote', 'add', 'origin', url]);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(3, 'git', [
        '-C',
        directory,
        'fetch',
        '--depth',
        '1',
        'origin',
        remoteBranch,
      ]);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(4, 'git', ['-C', directory, 'checkout', 'FETCH_HEAD']);
    });

    test('should throw error when git fetch fails', async () => {
      const mockFileExecAsync = vi
        .fn()
        .mockResolvedValueOnce('Success on first call')
        .mockResolvedValueOnce('Success on second call')
        .mockRejectedValueOnce(new Error('Authentication failed'));

      const url = 'https://github.com/user/repo.git';
      const directory = '/tmp/repo';
      const remoteBranch = 'b188a6cb39b512a9c6da7235b880af42c78ccd0d';

      await expect(
        execGitShallowClone(url, directory, remoteBranch, { execFileAsync: mockFileExecAsync }),
      ).rejects.toThrow('Authentication failed');
      expect(mockFileExecAsync).toHaveBeenCalledTimes(3);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(1, 'git', ['-C', directory, 'init']);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(2, 'git', ['-C', directory, 'remote', 'add', 'origin', url]);
      expect(mockFileExecAsync).toHaveBeenLastCalledWith('git', [
        '-C',
        directory,
        'fetch',
        '--depth',
        '1',
        'origin',
        remoteBranch,
      ]);
    });

    test('should handle short SHA correctly', async () => {
      const url = 'https://github.com/user/repo.git';
      const directory = '/tmp/repo';
      const shortSha = 'ce9b621';
      const mockFileExecAsync = vi
        .fn()
        .mockResolvedValueOnce('Success on first call')
        .mockResolvedValueOnce('Success on second call')
        .mockRejectedValueOnce(
          new Error(
            `Command failed: git fetch --depth 1 origin ${shortSha}\nfatal: couldn't find remote ref ${shortSha}`,
          ),
        );

      await execGitShallowClone(url, directory, shortSha, { execFileAsync: mockFileExecAsync });

      expect(mockFileExecAsync).toHaveBeenCalledTimes(5);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(1, 'git', ['-C', directory, 'init']);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(2, 'git', ['-C', directory, 'remote', 'add', 'origin', url]);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(3, 'git', [
        '-C',
        directory,
        'fetch',
        '--depth',
        '1',
        'origin',
        shortSha,
      ]);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(4, 'git', ['-C', directory, 'fetch', 'origin']);
      expect(mockFileExecAsync).toHaveBeenLastCalledWith('git', ['-C', directory, 'checkout', shortSha]);
    });

    test("should throw error when remote ref is not found, and it's not due to short SHA", async () => {
      const url = 'https://github.com/user/repo.git';
      const directory = '/tmp/repo';
      const remoteBranch = 'b188a6cb39b512a9c6da7235b880af42c78ccd0d';
      const errMessage = `Command failed: git fetch --depth 1 origin ${remoteBranch}\nfatal: couldn't find remote ref ${remoteBranch}`;

      const mockFileExecAsync = vi
        .fn()
        .mockResolvedValueOnce('Success on first call')
        .mockResolvedValueOnce('Success on second call')
        .mockRejectedValueOnce(new Error(errMessage));

      await expect(
        execGitShallowClone(url, directory, remoteBranch, { execFileAsync: mockFileExecAsync }),
      ).rejects.toThrow(errMessage);
      expect(mockFileExecAsync).toHaveBeenCalledTimes(3);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(1, 'git', ['-C', directory, 'init']);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(2, 'git', ['-C', directory, 'remote', 'add', 'origin', url]);
      expect(mockFileExecAsync).toHaveBeenLastCalledWith('git', [
        '-C',
        directory,
        'fetch',
        '--depth',
        '1',
        'origin',
        remoteBranch,
      ]);
    });
  });
});
</file>

<file path="tests/core/file/packageJsonParse.test.ts">
import * as fs from 'node:fs/promises';
import path from 'node:path';
import * as url from 'node:url';
import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
import { getVersion } from '../../../src/core/file/packageJsonParse.js';
import { logger } from '../../../src/shared/logger.js';

vi.mock('fs/promises');
vi.mock('url');

describe('packageJsonParse', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  test('getVersion should return correct version from package.json', async () => {
    const mockPackageJson = {
      name: 'repomix',
      version: '1.2.3',
    };

    vi.mocked(url.fileURLToPath).mockReturnValue('/mock/path/to/src/core/file');
    vi.mocked(fs.readFile).mockResolvedValue(JSON.stringify(mockPackageJson));

    const version = await getVersion();

    expect(version).toBe('1.2.3');
    expect(url.fileURLToPath).toHaveBeenCalledWith(expect.any(URL));
    expect(fs.readFile).toHaveBeenCalledWith(
      path.join('/mock/path/to/src/core/file', '..', '..', '..', 'package.json'),
      'utf-8',
    );
  });

  test('getVersion should handle missing version in package.json', async () => {
    const mockPackageJson = {
      name: 'repomix',
    };

    const loggerSpy = vi.spyOn(logger, 'warn').mockImplementation(vi.fn());

    vi.mocked(url.fileURLToPath).mockReturnValue('/mock/path/to/src/core/file2');
    vi.mocked(fs.readFile).mockResolvedValue(JSON.stringify(mockPackageJson));

    const version = await getVersion();

    expect(loggerSpy).toHaveBeenCalledWith(expect.stringContaining('No version found in package.json'));

    expect(version).toBe('unknown');
  });
});
</file>

<file path="tests/core/file/permissionCheck.test.ts">
import { constants } from 'node:fs';
import * as fs from 'node:fs/promises';
import { platform } from 'node:os';
import { beforeEach, describe, expect, test, vi } from 'vitest';
import { PermissionError, checkDirectoryPermissions } from '../../../src/core/file/permissionCheck.js';

vi.mock('node:fs/promises');
vi.mock('node:os');

describe('permissionCheck', () => {
  const testDirPath = '/test/directory';

  beforeEach(() => {
    vi.resetAllMocks();
    vi.mocked(platform).mockReturnValue('linux');
  });

  describe('successful cases', () => {
    test('should return success when all permissions are available', async () => {
      // Mock successful readdir
      vi.mocked(fs.readdir).mockResolvedValue([]);

      // Mock successful access checks
      vi.mocked(fs.access).mockResolvedValue(undefined);

      const result = await checkDirectoryPermissions(testDirPath);

      expect(result).toEqual({
        hasPermission: true,
        details: {
          read: true,
          write: true,
          execute: true,
        },
      });

      // Verify all permission checks were called
      expect(fs.access).toHaveBeenCalledWith(testDirPath, constants.R_OK);
      expect(fs.access).toHaveBeenCalledWith(testDirPath, constants.W_OK);
      expect(fs.access).toHaveBeenCalledWith(testDirPath, constants.X_OK);
    });

    test('should pass with only required permissions', async () => {
      // Mock successful readdir
      vi.mocked(fs.readdir).mockResolvedValue([]);

      // Mock mixed permission check results
      vi.mocked(fs.access).mockImplementation(async (path, mode) => {
        if (mode === constants.R_OK || mode === constants.X_OK) {
          return Promise.resolve(undefined);
        }
        return Promise.reject(new Error('Permission denied'));
      });

      const result = await checkDirectoryPermissions(testDirPath);

      expect(result).toEqual({
        hasPermission: false,
        details: {
          read: true,
          write: false,
          execute: true,
        },
      });
    });
  });

  describe('error cases', () => {
    test('should handle EPERM error', async () => {
      const error = new Error('Permission denied');
      (error as NodeJS.ErrnoException).code = 'EPERM';
      vi.mocked(fs.readdir).mockRejectedValue(error);

      const result = await checkDirectoryPermissions(testDirPath);

      expect(result).toEqual({
        hasPermission: false,
        error: expect.any(PermissionError),
      });
      expect(result.error).toBeInstanceOf(PermissionError);
      expect(result.error?.message).toContain('Permission denied');
    });

    test('should handle EACCES error', async () => {
      const error = new Error('Access denied');
      (error as NodeJS.ErrnoException).code = 'EACCES';
      vi.mocked(fs.readdir).mockRejectedValue(error);

      const result = await checkDirectoryPermissions(testDirPath);

      expect(result).toEqual({
        hasPermission: false,
        error: expect.any(PermissionError),
      });
      expect(result.error).toBeInstanceOf(PermissionError);
      expect(result.error?.message).toContain('Permission denied');
    });

    test('should handle EISDIR error', async () => {
      const error = new Error('Is a directory');
      (error as NodeJS.ErrnoException).code = 'EISDIR';
      vi.mocked(fs.readdir).mockRejectedValue(error);

      const result = await checkDirectoryPermissions(testDirPath);

      expect(result).toEqual({
        hasPermission: false,
        error: expect.any(PermissionError),
      });
    });

    test('should handle non-Error objects', async () => {
      vi.mocked(fs.readdir).mockRejectedValue('String error');

      const result = await checkDirectoryPermissions(testDirPath);

      expect(result).toEqual({
        hasPermission: false,
        error: new Error('String error'),
      });
    });
  });

  describe('platform specific behavior', () => {
    test('should return macOS specific error message', async () => {
      // Mock platform as macOS
      vi.mocked(platform).mockReturnValue('darwin');

      const error = new Error('Permission denied');
      (error as NodeJS.ErrnoException).code = 'EACCES';
      vi.mocked(fs.readdir).mockRejectedValue(error);

      const result = await checkDirectoryPermissions(testDirPath);

      expect(result.error).toBeInstanceOf(PermissionError);
      expect(result.error?.message).toContain('macOS security restrictions');
      expect(result.error?.message).toContain('System Settings');
      expect(result.error?.message).toContain('Privacy & Security');
    });

    test('should return standard error message for non-macOS platforms', async () => {
      // Mock platform as Windows
      vi.mocked(platform).mockReturnValue('win32');

      const error = new Error('Permission denied');
      (error as NodeJS.ErrnoException).code = 'EACCES';
      vi.mocked(fs.readdir).mockRejectedValue(error);

      const result = await checkDirectoryPermissions(testDirPath);

      expect(result.error).toBeInstanceOf(PermissionError);
      expect(result.error?.message).toBe(`Permission denied: Cannot access '${testDirPath}'`);
      expect(result.error?.message).not.toContain('macOS security restrictions');
    });
  });

  describe('PermissionError class', () => {
    test('should create PermissionError with correct properties', () => {
      const message = 'Test error message';
      const path = '/test/path';
      const code = 'EACCES';

      const error = new PermissionError(message, path, code);

      expect(error).toBeInstanceOf(Error);
      expect(error.name).toBe('PermissionError');
      expect(error.message).toBe(message);
      expect(error.path).toBe(path);
      expect(error.code).toBe(code);
    });

    test('should create PermissionError without code', () => {
      const message = 'Test error message';
      const path = '/test/path';

      const error = new PermissionError(message, path);

      expect(error).toBeInstanceOf(Error);
      expect(error.name).toBe('PermissionError');
      expect(error.message).toBe(message);
      expect(error.path).toBe(path);
      expect(error.code).toBeUndefined();
    });
  });

  describe('edge cases', () => {
    test('should handle undefined error code', async () => {
      const error = new Error('Permission denied');
      vi.mocked(fs.readdir).mockRejectedValue(error);

      const result = await checkDirectoryPermissions(testDirPath);

      expect(result).toEqual({
        hasPermission: false,
        error: error,
      });
    });

    test('should handle partial permission checks failing', async () => {
      // Mock successful readdir
      vi.mocked(fs.readdir).mockResolvedValue([]);

      // Mock access to fail for write permission only
      vi.mocked(fs.access).mockImplementation(async (path, mode) => {
        if (mode === constants.W_OK) {
          throw new Error('Write permission denied');
        }
        return Promise.resolve(undefined);
      });

      const result = await checkDirectoryPermissions(testDirPath);

      expect(result).toEqual({
        hasPermission: false,
        details: {
          read: true,
          write: false,
          execute: true,
        },
      });
    });

    test('should handle all permission checks failing', async () => {
      // Mock successful readdir
      vi.mocked(fs.readdir).mockResolvedValue([]);

      // Mock all access checks to fail
      vi.mocked(fs.access).mockRejectedValue(new Error('Permission denied'));

      const result = await checkDirectoryPermissions(testDirPath);

      expect(result).toEqual({
        hasPermission: false,
        details: {
          read: false,
          write: false,
          execute: false,
        },
      });
    });
  });
});
</file>

<file path="tests/core/metrics/aggregateMetrics.test.ts">
import { describe, expect, it } from 'vitest';
import type { ProcessedFile } from '../../../src/core/file/fileTypes.js';
import { aggregateMetrics } from '../../../src/core/metrics/aggregateMetrics.js';
import type { FileMetrics } from '../../../src/core/metrics/calculateIndividualFileMetrics.js';
import type { TokenCounter } from '../../../src/core/tokenCount/tokenCount.js';

describe('aggregateMetrics', () => {
  it('should aggregate metrics correctly', () => {
    const fileMetrics: FileMetrics[] = [
      { path: 'file1.txt', charCount: 100, tokenCount: 10 },
      { path: 'file2.txt', charCount: 200, tokenCount: 20 },
    ];
    const processedFiles: ProcessedFile[] = [
      { path: 'file1.txt', content: 'a' },
      { path: 'file2.txt', content: 'b'.repeat(200) },
    ];
    const output = 'a'.repeat(300);
    const tokenCounter = {
      countTokens: (content: string) => content.length / 10,
    } as TokenCounter;

    const result = aggregateMetrics(fileMetrics, processedFiles, output, tokenCounter);

    expect(result).toEqual({
      totalFiles: 2,
      totalCharacters: 300,
      totalTokens: 30,
      fileCharCounts: {
        'file1.txt': 100,
        'file2.txt': 200,
      },
      fileTokenCounts: {
        'file1.txt': 10,
        'file2.txt': 20,
      },
    });
  });

  it('should handle empty file metrics', () => {
    const fileMetrics: FileMetrics[] = [];
    const processedFiles: ProcessedFile[] = [];
    const output = '';
    const tokenCounter = {
      countTokens: (content: string) => content.length / 10,
    } as TokenCounter;

    const result = aggregateMetrics(fileMetrics, processedFiles, output, tokenCounter);

    expect(result).toEqual({
      totalFiles: 0,
      totalCharacters: 0,
      totalTokens: 0,
      fileCharCounts: {},
      fileTokenCounts: {},
    });
  });
});
</file>

<file path="tests/core/metrics/calculateAllFileMetrics.test.ts">
import { type Mock, describe, expect, it, vi } from 'vitest';
import type { ProcessedFile } from '../../../src/core/file/fileTypes.js';
import { calculateAllFileMetrics } from '../../../src/core/metrics/calculateAllFileMetrics.js';
import { calculateIndividualFileMetrics } from '../../../src/core/metrics/calculateIndividualFileMetrics.js';
import type { TokenCounter } from '../../../src/core/tokenCount/tokenCount.js';
import type { RepomixProgressCallback } from '../../../src/shared/types.js';

vi.mock('../../../src/core/metrics/calculateIndividualFileMetrics.js');
vi.mock('../../shared/processConcurrency', () => ({
  getProcessConcurrency: () => 1,
}));

describe('calculateAllFileMetrics', () => {
  it('should calculate metrics for all files', async () => {
    const processedFiles: ProcessedFile[] = [
      { path: 'file1.txt', content: 'a'.repeat(100) },
      { path: 'file2.txt', content: 'b'.repeat(200) },
    ];
    const tokenCounter = {} as TokenCounter;
    const progressCallback: RepomixProgressCallback = vi.fn();

    (calculateIndividualFileMetrics as Mock).mockImplementation(
      (file, _index, _totalFiles, _tokenCounter, _progressCallback) => {
        return {
          path: file.path,
          charCount: file.content.length,
          tokenCount: file.content.length / 10,
        };
      },
    );

    const result = await calculateAllFileMetrics(processedFiles, tokenCounter, progressCallback);

    expect(calculateIndividualFileMetrics).toHaveBeenCalledTimes(2);
    expect(result).toEqual([
      { path: 'file1.txt', charCount: 100, tokenCount: 10 },
      { path: 'file2.txt', charCount: 200, tokenCount: 20 },
    ]);
  });
});
</file>

<file path="tests/core/metrics/calculateIndividualFileMetrics.test.ts">
import pc from 'picocolors';
import { describe, expect, it, vi } from 'vitest';
import type { ProcessedFile } from '../../../src/core/file/fileTypes.js';
import { calculateIndividualFileMetrics } from '../../../src/core/metrics/calculateIndividualFileMetrics.js';
import type { TokenCounter } from '../../../src/core/tokenCount/tokenCount.js';
import type { RepomixProgressCallback } from '../../../src/shared/types.js';

describe('calculateIndividualFileMetrics', () => {
  it('should calculate file metrics and report progress', async () => {
    const file: ProcessedFile = { path: 'file1.txt', content: 'a'.repeat(100) };
    const index = 0;
    const totalFiles = 1;
    const tokenCounter = {
      countTokens: vi.fn().mockReturnValue(10),
    } as unknown as TokenCounter;
    const progressCallback: RepomixProgressCallback = vi.fn();

    const result = await calculateIndividualFileMetrics(file, index, totalFiles, tokenCounter, progressCallback);

    expect(tokenCounter.countTokens).toHaveBeenCalledWith(file.content, file.path);
    expect(progressCallback).toHaveBeenCalledWith(`Calculating metrics... (1/1) ${pc.dim('file1.txt')}`);
    expect(result).toEqual({
      path: 'file1.txt',
      charCount: 100,
      tokenCount: 10,
    });
  });
});
</file>

<file path="tests/core/metrics/calculateMetrics.test.ts">
import { type Mock, describe, expect, it, vi } from 'vitest';
import type { ProcessedFile } from '../../../src/core/file/fileTypes.js';
import { aggregateMetrics } from '../../../src/core/metrics/aggregateMetrics.js';
import { calculateAllFileMetrics } from '../../../src/core/metrics/calculateAllFileMetrics.js';
import { calculateMetrics } from '../../../src/core/metrics/calculateMetrics.js';
import { TokenCounter } from '../../../src/core/tokenCount/tokenCount.js';
import type { RepomixProgressCallback } from '../../../src/shared/types.js';
import { createMockConfig } from '../../testing/testUtils.js';

vi.mock('../../../src/core/tokenCount/tokenCount.js');
vi.mock('../../../src/core/metrics/aggregateMetrics.js');
vi.mock('../../../src/core/metrics/calculateAllFileMetrics.js');

describe('calculateMetrics', () => {
  it('should calculate metrics and return the result', async () => {
    const processedFiles: ProcessedFile[] = [
      { path: 'file1.txt', content: 'a'.repeat(100) },
      { path: 'file2.txt', content: 'b'.repeat(200) },
    ];
    const output = 'a'.repeat(300);
    const progressCallback: RepomixProgressCallback = vi.fn();

    const mockTokenCounter = {
      countTokens: vi.fn(),
      free: vi.fn(),
    };
    (TokenCounter as unknown as Mock).mockImplementation(() => mockTokenCounter);

    const fileMetrics = [
      { path: 'file1.txt', charCount: 100, tokenCount: 10 },
      { path: 'file2.txt', charCount: 200, tokenCount: 20 },
    ];
    (calculateAllFileMetrics as unknown as Mock).mockResolvedValue(fileMetrics);

    const aggregatedResult = {
      totalFiles: 2,
      totalCharacters: 300,
      totalTokens: 30,
      fileCharCounts: {
        'file1.txt': 100,
        'file2.txt': 200,
      },
      fileTokenCounts: {
        'file1.txt': 10,
        'file2.txt': 20,
      },
    };
    (aggregateMetrics as unknown as Mock).mockReturnValue(aggregatedResult);

    const config = createMockConfig();

    const result = await calculateMetrics(processedFiles, output, progressCallback, config);

    expect(progressCallback).toHaveBeenCalledWith('Calculating metrics...');
    expect(calculateAllFileMetrics).toHaveBeenCalledWith(processedFiles, mockTokenCounter, progressCallback);
    expect(aggregateMetrics).toHaveBeenCalledWith(fileMetrics, processedFiles, output, mockTokenCounter);
    expect(mockTokenCounter.free).toHaveBeenCalled();
    expect(result).toEqual(aggregatedResult);
  });
});
</file>

<file path="tests/core/output/outputStyles/markdownStyle.test.ts">
import Handlebars from 'handlebars';
import { describe, expect, test } from 'vitest';
import { getMarkdownTemplate } from '../../../../src/core/output/outputStyles/markdownStyle.js';

describe('markdownStyle', () => {
  describe('getMarkdownTemplate', () => {
    test('should return valid markdown template', () => {
      const template = getMarkdownTemplate();
      expect(template).toContain('# File Summary');
      expect(template).toContain('# Directory Structure');
      expect(template).toContain('# Files');
      expect(template).toContain('{{#if instruction}}');
      expect(template).toContain('# Instruction');
    });

    test('should correctly render template with basic data', () => {
      const template = getMarkdownTemplate();
      const compiledTemplate = Handlebars.compile(template);
      const data = {
        generationHeader: 'Generated Test Header',
        summaryPurpose: 'Test Purpose',
        summaryFileFormat: 'Test Format',
        summaryUsageGuidelines: 'Test Guidelines',
        summaryNotes: 'Test Notes',
        treeString: 'src/\n  index.ts',
        processedFiles: [
          {
            path: 'src/index.ts',
            content: 'console.log("Hello");',
          },
        ],
        fileSummaryEnabled: true,
        directoryStructureEnabled: true,
      };

      const result = compiledTemplate(data);

      expect(result).toContain('Generated Test Header');
      expect(result).toContain('Test Purpose');
      expect(result).toContain('Test Format');
      expect(result).toContain('Test Guidelines');
      expect(result).toContain('Test Notes');
      expect(result).toContain('src/\n  index.ts');
      expect(result).toContain('## File: src/index.ts');
      expect(result).toContain('console.log("Hello");');
    });

    test('should render optional header text when provided', () => {
      const template = getMarkdownTemplate();
      const compiledTemplate = Handlebars.compile(template);
      const data = {
        headerText: 'Custom Header Text',
        processedFiles: [],
        fileSummaryEnabled: true,
        directoryStructureEnabled: true,
      };

      const result = compiledTemplate(data);

      expect(result).toContain('### User Provided Header');
      expect(result).toContain('Custom Header Text');
    });

    test('should not render header section when headerText is not provided', () => {
      const template = getMarkdownTemplate();
      const compiledTemplate = Handlebars.compile(template);
      const data = {
        processedFiles: [],
        fileSummaryEnabled: true,
        directoryStructureEnabled: true,
      };

      const result = compiledTemplate(data);

      expect(result).not.toContain('### User Provided Header');
    });

    test('should render instruction section when provided', () => {
      const template = getMarkdownTemplate();
      const compiledTemplate = Handlebars.compile(template);
      const data = {
        instruction: 'Custom Instruction Text',
        processedFiles: [],
        fileSummaryEnabled: true,
        directoryStructureEnabled: true,
      };

      const result = compiledTemplate(data);

      expect(result).toContain('# Instruction');
      expect(result).toContain('Custom Instruction Text');
    });
  });

  describe('getFileExtension helper', () => {
    // Helper to get extension mapping result
    const getExtension = (filePath: string): string => {
      const helper = Handlebars.helpers.getFileExtension as Handlebars.HelperDelegate;
      return helper(filePath) as string;
    };

    // JavaScript variants
    test('should handle JavaScript related extensions', () => {
      expect(getExtension('file.js')).toBe('javascript');
      expect(getExtension('file.jsx')).toBe('javascript');
      expect(getExtension('file.ts')).toBe('typescript');
      expect(getExtension('file.tsx')).toBe('typescript');
    });

    // Web technologies
    test('should handle web technology extensions', () => {
      expect(getExtension('file.html')).toBe('html');
      expect(getExtension('file.css')).toBe('css');
      expect(getExtension('file.scss')).toBe('scss');
      expect(getExtension('file.sass')).toBe('scss');
      expect(getExtension('file.vue')).toBe('vue');
    });

    // Backend languages
    test('should handle backend language extensions', () => {
      expect(getExtension('file.py')).toBe('python');
      expect(getExtension('file.rb')).toBe('ruby');
      expect(getExtension('file.php')).toBe('php');
      expect(getExtension('file.java')).toBe('java');
      expect(getExtension('file.go')).toBe('go');
    });

    // System programming languages
    test('should handle system programming language extensions', () => {
      expect(getExtension('file.c')).toBe('cpp');
      expect(getExtension('file.cpp')).toBe('cpp');
      expect(getExtension('file.rs')).toBe('rust');
      expect(getExtension('file.swift')).toBe('swift');
      expect(getExtension('file.kt')).toBe('kotlin');
    });

    // Configuration and data format files
    test('should handle configuration and data format extensions', () => {
      expect(getExtension('file.json')).toBe('json');
      expect(getExtension('file.json5')).toBe('json5');
      expect(getExtension('file.xml')).toBe('xml');
      expect(getExtension('file.yaml')).toBe('yaml');
      expect(getExtension('file.yml')).toBe('yaml');
      expect(getExtension('file.toml')).toBe('toml');
    });

    // Shell and scripting
    test('should handle shell and scripting extensions', () => {
      expect(getExtension('file.sh')).toBe('bash');
      expect(getExtension('file.bash')).toBe('bash');
      expect(getExtension('file.ps1')).toBe('powershell');
    });

    // Database and query languages
    test('should handle database related extensions', () => {
      expect(getExtension('file.sql')).toBe('sql');
      expect(getExtension('file.graphql')).toBe('graphql');
      expect(getExtension('file.gql')).toBe('graphql');
    });

    // Functional programming languages
    test('should handle functional programming language extensions', () => {
      expect(getExtension('file.fs')).toBe('fsharp');
      expect(getExtension('file.fsx')).toBe('fsharp');
      expect(getExtension('file.hs')).toBe('haskell');
      expect(getExtension('file.clj')).toBe('clojure');
      expect(getExtension('file.cljs')).toBe('clojure');
    });

    // Other languages and tools
    test('should handle other programming language extensions', () => {
      expect(getExtension('file.scala')).toBe('scala');
      expect(getExtension('file.dart')).toBe('dart');
      expect(getExtension('file.ex')).toBe('elixir');
      expect(getExtension('file.exs')).toBe('elixir');
      expect(getExtension('file.erl')).toBe('erlang');
      expect(getExtension('file.coffee')).toBe('coffeescript');
    });

    // Infrastructure and templating
    test('should handle infrastructure and templating extensions', () => {
      expect(getExtension('file.tf')).toBe('hcl');
      expect(getExtension('file.tfvars')).toBe('hcl');
      expect(getExtension('file.dockerfile')).toBe('dockerfile');
      expect(getExtension('file.pug')).toBe('pug');
      expect(getExtension('file.proto')).toBe('protobuf');
    });

    // Miscellaneous
    test('should handle miscellaneous file extensions', () => {
      expect(getExtension('file.md')).toBe('markdown');
      expect(getExtension('file.r')).toBe('r');
      expect(getExtension('file.pl')).toBe('perl');
      expect(getExtension('file.pm')).toBe('perl');
      expect(getExtension('file.lua')).toBe('lua');
      expect(getExtension('file.groovy')).toBe('groovy');
      expect(getExtension('file.vb')).toBe('vb');
    });

    // Edge cases
    test('should handle edge cases', () => {
      expect(getExtension('file')).toBe(''); // No extension
      expect(getExtension('.gitignore')).toBe(''); // Dotfile
      expect(getExtension('file.unknown')).toBe(''); // Unknown extension
      expect(getExtension('path/to/file.js')).toBe('javascript'); // Path with directory
    });
  });
});
</file>

<file path="tests/core/output/outputStyles/plainStyle.test.ts">
import process from 'node:process';
import { beforeEach, describe, expect, test, vi } from 'vitest';
import { generateOutput } from '../../../../src/core/output/outputGenerate.js';
import { createMockConfig } from '../../../testing/testUtils.js';

vi.mock('fs/promises');

describe('plainStyle', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  test('generateOutput for plain should include user-provided header text', async () => {
    const mockConfig = createMockConfig({
      output: {
        filePath: 'output.txt',
        style: 'plain',
        headerText: 'Custom header text',
        topFilesLength: 2,
        showLineNumbers: false,
        removeComments: false,
        removeEmptyLines: false,
      },
    });

    const output = await generateOutput(process.cwd(), mockConfig, [], []);

    expect(output).toContain('File Summary');
    expect(output).toContain('Directory Structure');
    expect(output).toContain('Custom header text');
    expect(output).toContain('Files');
  });
});
</file>

<file path="tests/core/output/outputStyles/xmlStyle.test.ts">
import process from 'node:process';
import { beforeEach, describe, expect, test, vi } from 'vitest';
import { generateOutput } from '../../../../src/core/output/outputGenerate.js';
import { createMockConfig } from '../../../testing/testUtils.js';

vi.mock('fs/promises');

describe('xmlStyle', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  test('generateOutput for xml should include user-provided header text', async () => {
    const mockConfig = createMockConfig({
      output: {
        filePath: 'output.txt',
        style: 'xml',
        headerText: 'Custom header text',
        topFilesLength: 2,
        showLineNumbers: false,
        removeComments: false,
        removeEmptyLines: false,
      },
    });

    const output = await generateOutput(process.cwd(), mockConfig, [], []);

    expect(output).toContain('file_summary');
    expect(output).toContain('directory_structure');
    expect(output).toContain('Custom header text');
    expect(output).toContain('files');
  });
});
</file>

<file path="tests/core/output/outputGenerate.test.ts">
import process from 'node:process';
import { XMLParser } from 'fast-xml-parser';
import { describe, expect, test } from 'vitest';
import type { ProcessedFile } from '../../../src/core/file/fileTypes.js';
import { generateOutput } from '../../../src/core/output/outputGenerate.js';
import { createMockConfig } from '../../testing/testUtils.js';

describe('outputGenerate', () => {
  test('generateOutput should write correct content to file (plain style)', async () => {
    const mockConfig = createMockConfig({
      output: {
        filePath: 'output.txt',
        style: 'plain',
        topFilesLength: 2,
        showLineNumbers: false,
        removeComments: false,
        removeEmptyLines: false,
      },
    });
    const mockProcessedFiles: ProcessedFile[] = [
      { path: 'file1.txt', content: 'content1' },
      { path: 'dir/file2.txt', content: 'content2' },
    ];

    const output = await generateOutput(process.cwd(), mockConfig, mockProcessedFiles, []);

    expect(output).toContain('File Summary');
    expect(output).toContain('File: file1.txt');
    expect(output).toContain('content1');
    expect(output).toContain('File: dir/file2.txt');
    expect(output).toContain('content2');
  });

  test('generateOutput should write correct content to file (parsable xml style)', async () => {
    const mockConfig = createMockConfig({
      output: {
        filePath: 'output.txt',
        style: 'xml',
        parsableStyle: true,
        topFilesLength: 2,
        showLineNumbers: false,
        removeComments: false,
        removeEmptyLines: false,
      },
    });
    const mockProcessedFiles: ProcessedFile[] = [
      { path: 'file1.txt', content: '<div>foo</div>' },
      { path: 'dir/file2.txt', content: 'if (a && b)' },
    ];

    const output = await generateOutput(process.cwd(), mockConfig, mockProcessedFiles, []);

    const parser = new XMLParser({ ignoreAttributes: false });
    const parsedOutput = parser.parse(output);

    expect(parsedOutput.repomix.file_summary).not.toBeUndefined();
    expect(parsedOutput.repomix.files.file).toEqual([
      { '#text': mockProcessedFiles[0].content, '@_path': mockProcessedFiles[0].path },
      { '#text': mockProcessedFiles[1].content, '@_path': mockProcessedFiles[1].path },
    ]);
  });

  test('generateOutput should write correct content to file (parsable markdown style)', async () => {
    const mockConfig = createMockConfig({
      output: {
        filePath: 'output.txt',
        style: 'markdown',
        parsableStyle: true,
        topFilesLength: 2,
        showLineNumbers: false,
        removeComments: false,
        removeEmptyLines: false,
      },
    });
    const mockProcessedFiles: ProcessedFile[] = [
      { path: 'file1.txt', content: 'content1' },
      { path: 'dir/file2.txt', content: '```\ncontent2\n```' },
    ];

    const output = await generateOutput(process.cwd(), mockConfig, mockProcessedFiles, []);

    expect(output).toContain('# File Summary');
    expect(output).toContain('## File: file1.txt');
    expect(output).toContain('````\ncontent1\n````');
    expect(output).toContain('## File: dir/file2.txt');
    expect(output).toContain('````\n```\ncontent2\n```\n````');
  });
});
</file>

<file path="tests/core/packager/copyToClipboardIfEnabled.test.ts">
import clipboard from 'clipboardy';
import { logger } from 'handlebars';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import { copyToClipboardIfEnabled } from '../../../src/core/packager/copyToClipboardIfEnabled.js';
import type { RepomixProgressCallback } from '../../../src/shared/types.js';

vi.mock('clipboardy');
vi.mock('../../shared/logger');

describe('copyToClipboardIfEnabled', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  it('should copy output to clipboard if flag enabled in config', async () => {
    const output = 'test output';
    const config: RepomixConfigMerged = {
      output: { copyToClipboard: true },
    } as RepomixConfigMerged;
    const progressCallback: RepomixProgressCallback = vi.fn();

    await copyToClipboardIfEnabled(output, progressCallback, config);

    expect(progressCallback).toHaveBeenCalledWith('Copying to clipboard...');
    expect(clipboard.write).toHaveBeenCalledWith(output);
  });

  it('should not copy output to clipboard if flag disabled in config', async () => {
    const output = 'test output';
    const config: RepomixConfigMerged = {
      output: { copyToClipboard: false },
    } as RepomixConfigMerged;
    const progressCallback: RepomixProgressCallback = vi.fn();

    await copyToClipboardIfEnabled(output, progressCallback, config);

    expect(progressCallback).not.toHaveBeenCalled();
    expect(clipboard.write).not.toHaveBeenCalled();
  });
});
</file>

<file path="tests/core/packager/writeOutputToDisk.test.ts">
import fs from 'node:fs/promises';
import path from 'node:path';
import { describe, expect, it, vi } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import { writeOutputToDisk } from '../../../src/core/packager/writeOutputToDisk.js';

vi.mock('node:fs/promises');
vi.mock('../../shared/logger');

describe('writeOutputToDisk', () => {
  it('should write output to the specified file path', async () => {
    const output = 'test output';
    const config: RepomixConfigMerged = {
      cwd: '/test/directory',
      output: { filePath: 'output.txt' },
    } as RepomixConfigMerged;

    const outputPath = path.resolve(config.cwd, config.output.filePath);

    await writeOutputToDisk(output, config);

    expect(fs.writeFile).toHaveBeenCalledWith(outputPath, output);
  });
});
</file>

<file path="tests/core/security/filterOutUntrustedFiles.test.ts">
import { describe, expect, it } from 'vitest';
import type { RawFile } from '../../../src/core/file/fileTypes.js';
import { filterOutUntrustedFiles } from '../../../src/core/security/filterOutUntrustedFiles.js';
import type { SuspiciousFileResult } from '../../../src/core/security/securityCheck.js';

describe('filterOutUntrustedFiles', () => {
  it('should filter out untrusted files', () => {
    const rawFiles: RawFile[] = [
      { path: 'file1.txt', content: 'content 1' },
      { path: 'file2.txt', content: 'content 2' },
      { path: 'file3.txt', content: 'content 3' },
    ];
    const suspiciousFilesResults: SuspiciousFileResult[] = [
      { filePath: 'file2.txt', messages: ['something suspicious.'] },
    ];
    const expectedGoodFiles = [rawFiles[0], rawFiles[2]];

    const result = filterOutUntrustedFiles(rawFiles, suspiciousFilesResults);

    expect(result).toEqual(expectedGoodFiles);
  });

  it('should return all files if no suspicious files', () => {
    const rawFiles: RawFile[] = [
      { path: 'file1.txt', content: 'content 1' },
      { path: 'file2.txt', content: 'content 2' },
      { path: 'file3.txt', content: 'content 3' },
    ];
    const suspiciousFilesResults: SuspiciousFileResult[] = [];

    const result = filterOutUntrustedFiles(rawFiles, suspiciousFilesResults);

    expect(result).toEqual(rawFiles);
  });
});
</file>

<file path="tests/core/security/runSecurityCheckIfEnabled.test.ts">
import { describe, expect, it, vi } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import type { RawFile } from '../../../src/core/file/fileTypes.js';
import { runSecurityCheckIfEnabled } from '../../../src/core/security/runSecurityCheckIfEnabled.js';
import type { SuspiciousFileResult } from '../../../src/core/security/securityCheck.js';
import type { RepomixProgressCallback } from '../../../src/shared/types.js';

describe('runSecurityCheckIfEnabled', () => {
  it('should run security check if enabled in config', async () => {
    const rawFiles: RawFile[] = [
      { path: 'file1.txt', content: 'contents1' },
      { path: 'file2.txt', content: 'contents2' },
    ];
    const config: RepomixConfigMerged = {
      security: { enableSecurityCheck: true },
    } as RepomixConfigMerged;
    const progressCallback: RepomixProgressCallback = vi.fn();
    const checkSecurity = vi.fn().mockResolvedValue([{ filePath: 'file1.txt' }] as SuspiciousFileResult[]);

    const result = await runSecurityCheckIfEnabled(rawFiles, config, progressCallback, {
      runSecurityCheck: checkSecurity,
    });

    expect(progressCallback).toHaveBeenCalledWith('Running security check...');
    expect(checkSecurity).toHaveBeenCalledWith(rawFiles, progressCallback);
    expect(result).toEqual([{ filePath: 'file1.txt' }]);
  });

  it('should not run security check if disabled in config', async () => {
    const rawFiles: RawFile[] = [
      { path: 'file1.txt', content: 'contents1' },
      { path: 'file2.txt', content: 'contents2' },
    ];
    const config: RepomixConfigMerged = {
      security: { enableSecurityCheck: false },
    } as RepomixConfigMerged;
    const progressCallback: RepomixProgressCallback = vi.fn();
    const checkSecurity = vi.fn();

    const result = await runSecurityCheckIfEnabled(rawFiles, config, progressCallback, {
      runSecurityCheck: checkSecurity,
    });

    expect(progressCallback).not.toHaveBeenCalled();
    expect(checkSecurity).not.toHaveBeenCalled();
    expect(result).toEqual([]);
  });
});
</file>

<file path="tests/core/security/securityCheck.test.ts">
import type { SecretLintCoreConfig } from '@secretlint/types';
import { describe, expect, test } from 'vitest';
import { createSecretLintConfig, runSecretLint } from '../../../src/core/security/securityCheck.js';

describe('securityCheck', () => {
  const config: SecretLintCoreConfig = createSecretLintConfig();

  test('should detect sensitive information', async () => {
    // Sensitive content with secrets from https://secretlint.github.io/
    // secretlint-disable
    const sensitiveContent = `
# Secretlint Demo

URL: https://user:pass@example.com

GitHub Token: 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

SendGrid: "SG.APhb3zgjtx3hajdas1TjBB.H7Sgbba3afgKSDyB442aDK0kpGO3SD332313-L5528Kewhere"

AWS_SECRET_ACCESS_KEY = wJalrXUtnFEMI/K7MDENG/bPxRfiCYSECRETSKEY

Slack:
xoxa-23984754863-2348975623103
xoxb-23984754863-2348975623103
xoxo-23984754863-2348975623103

Private Key:

-----BEGIN RSA PRIVATE KEY-----
MIICWwIBAAKBgQCYdGaf5uYMsilGHfnx/zxXtihdGFr3hCWwebHGhgEAVn0xlsTd
1QwoKi+rpI1O6hzyVOuoQtboODsONGRlHbNl6yJ936Yhmr8PiNwpA5qIxZAdmFv2
tqEllWr0dGPPm3B/2NbjuMpSiJNAcBQa46X++doG5yNMY8NCgTsjBZIBKwIDAQAB
AoGAN+Pkg5aIm/rsurHeoeMqYhV7srVtE/S0RIA4tkkGMPOELhvRzGmAbXEZzNkk
nNujBQww4JywYK3MqKZ4b8F1tMG3infs1w8V7INAYY/c8HzfrT3f+MVxijoKV2Fl
JlUXCclztoZhxAxhCR+WC1Upe1wIrWNwad+JA0Vws/mwrEECQQDxiT/Q0lK+gYaa
+riFeZmOaqwhlFlYNSK2hCnLz0vbnvnZE5ITQoV+yiy2+BhpMktNFsYNCfb0pdKN
D87x+jr7AkEAoZWITvqErh1RbMCXd26QXZEfZyrvVZMpYf8BmWFaBXIbrVGme0/Q
d7amI6B8Vrowyt+qgcUk7rYYaA39jYB7kQJAdaX2sY5gw25v1Dlfe5Q5WYdYBJsv
0alAGUrS2PVF69nJtRS1SDBUuedcVFsP+N2IlCoNmfhKk+vZXOBgWrkZ1QJAGJlE
FAntUvhhofW72VG6ppPmPPV7VALARQvmOWxpoPSbJAqPFqyy5tamejv/UdCshuX/
9huGINUV6BlhJT6PEQJAF/aqQTwZqJdwwJqYEQArSmyOW7UDAlQMmKMofjBbeBvd
H4PSJT5bvaEhxRj7QCwonoX4ZpV0beTnzloS55Z65g==
-----END RSA PRIVATE KEY-----
    `;
    // secretlint-enable

    const secretLintResult = await runSecretLint('test.md', sensitiveContent, config);
    const isSuspicious = secretLintResult.messages.length > 0;
    expect(isSuspicious).toBe(true);
  });

  test('should not detect sensitive information in normal content', async () => {
    const normalContent = `
# Normal Content

This is a regular markdown file with no sensitive information.

Here's some code:

\`\`\`javascript
function greet(name) {
  console.log(\`Hello, \${name}!\`);
}
\`\`\`

And here's a list:

1. Item 1
2. Item 2
3. Item 3

That's all!
    `;

    const secretLintResult = await runSecretLint('normal.md', normalContent, config);
    const isSuspicious = secretLintResult.messages.length > 0;
    expect(isSuspicious).toBe(false);
  });
});
</file>

<file path="tests/core/security/validateFileSafety.test.ts">
import { describe, expect, it, vi } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import type { RawFile } from '../../../src/core/file/fileTypes.js';
import type { SuspiciousFileResult } from '../../../src/core/security/securityCheck.js';
import { validateFileSafety } from '../../../src/core/security/validateFileSafety.js';
import type { RepomixProgressCallback } from '../../../src/shared/types.js';

describe('validateFileSafety', () => {
  it('should validate file safety and return safe files and paths', async () => {
    const rawFiles: RawFile[] = [
      { path: 'file1.txt', content: 'content1' },
      { path: 'file2.txt', content: 'content2' },
      { path: 'file3.txt', content: 'content3' },
    ];
    const safeRawFiles = [rawFiles[0], rawFiles[1]];
    const config: RepomixConfigMerged = {
      security: { enableSecurityCheck: true },
    } as RepomixConfigMerged;
    const progressCallback: RepomixProgressCallback = vi.fn();
    const suspiciousFilesResults: SuspiciousFileResult[] = [
      { filePath: 'file2.txt', messages: ['something suspicious.'] },
    ];
    const deps = {
      runSecurityCheckIfEnabled: vi.fn().mockResolvedValue(suspiciousFilesResults),
      filterOutUntrustedFiles: vi.fn().mockReturnValue(safeRawFiles),
    };

    const result = await validateFileSafety(rawFiles, progressCallback, config, deps);

    expect(deps.runSecurityCheckIfEnabled).toHaveBeenCalledWith(rawFiles, config, progressCallback);
    expect(deps.filterOutUntrustedFiles).toHaveBeenCalledWith(rawFiles, suspiciousFilesResults);
    expect(result).toEqual({
      safeRawFiles,
      safeFilePaths: ['file1.txt', 'file2.txt'],
      suspiciousFilesResults,
    });
  });
});
</file>

<file path="tests/core/tokenCount/tokenCount.test.ts">
import { type Tiktoken, get_encoding } from 'tiktoken';
import { type Mock, afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
import { TokenCounter } from '../../../src/core/tokenCount/tokenCount.js';
import { logger } from '../../../src/shared/logger.js';

vi.mock('tiktoken', () => ({
  get_encoding: vi.fn(),
}));

vi.mock('../../../src/shared/logger');

describe('TokenCounter', () => {
  let tokenCounter: TokenCounter;
  let mockEncoder: {
    encode: Mock;
    free: Mock;
  };

  beforeEach(() => {
    // Initialize mock encoder
    mockEncoder = {
      encode: vi.fn(),
      free: vi.fn(),
    };

    // Setup mock encoder behavior
    vi.mocked(get_encoding).mockReturnValue(mockEncoder as unknown as Tiktoken);

    // Create new TokenCounter instance
    tokenCounter = new TokenCounter('o200k_base');
  });

  afterEach(() => {
    tokenCounter.free();
    vi.resetAllMocks();
  });

  test('should initialize with o200k_base encoding', () => {
    expect(get_encoding).toHaveBeenCalledWith('o200k_base');
  });

  test('should correctly count tokens for simple text', () => {
    const text = 'Hello, world!';
    const mockTokens = [123, 456, 789]; // Example token IDs
    mockEncoder.encode.mockReturnValue(mockTokens);

    const count = tokenCounter.countTokens(text);

    expect(count).toBe(3); // Length of mockTokens
    expect(mockEncoder.encode).toHaveBeenCalledWith(text);
  });

  test('should handle empty string', () => {
    mockEncoder.encode.mockReturnValue([]);

    const count = tokenCounter.countTokens('');

    expect(count).toBe(0);
    expect(mockEncoder.encode).toHaveBeenCalledWith('');
  });

  test('should handle multi-line text', () => {
    const text = 'Line 1\nLine 2\nLine 3';
    const mockTokens = [1, 2, 3, 4, 5, 6];
    mockEncoder.encode.mockReturnValue(mockTokens);

    const count = tokenCounter.countTokens(text);

    expect(count).toBe(6);
    expect(mockEncoder.encode).toHaveBeenCalledWith(text);
  });

  test('should handle special characters', () => {
    const text = '!@#$%^&*()_+';
    const mockTokens = [1, 2, 3];
    mockEncoder.encode.mockReturnValue(mockTokens);

    const count = tokenCounter.countTokens(text);

    expect(count).toBe(3);
    expect(mockEncoder.encode).toHaveBeenCalledWith(text);
  });

  test('should handle unicode characters', () => {
    const text = '你好，世界！🌍';
    const mockTokens = [1, 2, 3, 4];
    mockEncoder.encode.mockReturnValue(mockTokens);

    const count = tokenCounter.countTokens(text);

    expect(count).toBe(4);
    expect(mockEncoder.encode).toHaveBeenCalledWith(text);
  });

  test('should handle code snippets', () => {
    const text = `
      function hello() {
        console.log("Hello, world!");
      }
    `;
    const mockTokens = Array(10).fill(1); // 10 tokens
    mockEncoder.encode.mockReturnValue(mockTokens);

    const count = tokenCounter.countTokens(text);

    expect(count).toBe(10);
    expect(mockEncoder.encode).toHaveBeenCalledWith(text);
  });

  test('should handle markdown text', () => {
    const text = `
      # Heading
      ## Subheading
      * List item 1
      * List item 2
      
      **Bold text** and _italic text_
    `;
    const mockTokens = Array(15).fill(1); // 15 tokens
    mockEncoder.encode.mockReturnValue(mockTokens);

    const count = tokenCounter.countTokens(text);

    expect(count).toBe(15);
    expect(mockEncoder.encode).toHaveBeenCalledWith(text);
  });

  test('should handle very long text', () => {
    const text = 'a'.repeat(10000);
    const mockTokens = Array(100).fill(1); // 100 tokens
    mockEncoder.encode.mockReturnValue(mockTokens);

    const count = tokenCounter.countTokens(text);

    expect(count).toBe(100);
    expect(mockEncoder.encode).toHaveBeenCalledWith(text);
  });

  test('should properly handle encoding errors without file path', () => {
    const error = new Error('Encoding error');
    mockEncoder.encode.mockImplementation(() => {
      throw error;
    });

    const count = tokenCounter.countTokens('test content');

    expect(count).toBe(0);
    expect(logger.warn).toHaveBeenCalledWith('Failed to count tokens. error: Encoding error');
  });

  test('should properly handle encoding errors with file path', () => {
    const error = new Error('Encoding error');
    mockEncoder.encode.mockImplementation(() => {
      throw error;
    });

    const count = tokenCounter.countTokens('test content', 'test.txt');

    expect(count).toBe(0);
    expect(logger.warn).toHaveBeenCalledWith('Failed to count tokens. path: test.txt, error: Encoding error');
  });

  test('should free encoder resources on cleanup', () => {
    tokenCounter.free();
    expect(mockEncoder.free).toHaveBeenCalled();
  });
});
</file>

<file path="tests/core/packager.test.ts">
import path from 'node:path';
import { beforeEach, describe, expect, test, vi } from 'vitest';
import { pack } from '../../src/core/packager.js';
import { TokenCounter } from '../../src/core/tokenCount/tokenCount.js';
import { createMockConfig } from '../testing/testUtils.js';

vi.mock('node:fs/promises');
vi.mock('fs/promises');
vi.mock('../../src/core/tokenCount/tokenCount');
vi.mock('clipboardy', () => ({
  default: {
    write: vi.fn(),
  },
}));

describe('packager', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  test('pack should orchestrate packing files and generating output', async () => {
    const file2Path = path.join('dir1', 'file2.txt');
    const mockRawFiles = [
      { path: 'file1.txt', content: 'raw content 1' },
      { path: file2Path, content: 'raw content 2' },
    ];
    const mockSafeRawFiles = [
      { path: 'file1.txt', content: 'safed content 1' },
      { path: file2Path, content: 'safed content 2' },
    ];
    const mockProcessedFiles = [
      { path: 'file1.txt', content: 'processed content 1' },
      { path: file2Path, content: 'processed content 2' },
    ];
    const mockOutput = 'mock output';
    const mockFilePaths = ['file1.txt', file2Path];

    const mockDeps = {
      searchFiles: vi.fn().mockResolvedValue({
        filePaths: mockFilePaths,
        emptyDirPaths: [],
      }),
      collectFiles: vi.fn().mockResolvedValue(mockRawFiles),
      processFiles: vi.fn().mockReturnValue(mockProcessedFiles),
      validateFileSafety: vi.fn().mockResolvedValue({
        safeFilePaths: mockFilePaths,
        safeRawFiles: mockSafeRawFiles,
        suspiciousFileResults: [],
      }),
      generateOutput: vi.fn().mockResolvedValue(mockOutput),
      writeOutputToDisk: vi.fn().mockResolvedValue(undefined),
      copyToClipboardIfEnabled: vi.fn().mockResolvedValue(undefined),
      calculateMetrics: vi.fn().mockResolvedValue({
        totalFiles: 2,
        totalCharacters: 11,
        totalTokens: 10,
        fileCharCounts: {
          'file1.txt': 19,
          [file2Path]: 19,
        },
        fileTokenCounts: {
          'file1.txt': 10,
          [file2Path]: 10,
        },
      }),
    };

    vi.mocked(TokenCounter.prototype.countTokens).mockReturnValue(10);

    const mockConfig = createMockConfig();
    const progressCallback = vi.fn();
    const result = await pack('root', mockConfig, progressCallback, mockDeps);

    expect(mockDeps.searchFiles).toHaveBeenCalledWith('root', mockConfig);
    expect(mockDeps.collectFiles).toHaveBeenCalledWith(mockFilePaths, 'root');
    expect(mockDeps.validateFileSafety).toHaveBeenCalled();
    expect(mockDeps.processFiles).toHaveBeenCalled();
    expect(mockDeps.writeOutputToDisk).toHaveBeenCalled();
    expect(mockDeps.generateOutput).toHaveBeenCalled();
    expect(mockDeps.calculateMetrics).toHaveBeenCalled();

    expect(mockDeps.validateFileSafety).toHaveBeenCalledWith(mockRawFiles, progressCallback, mockConfig);
    expect(mockDeps.processFiles).toHaveBeenCalledWith(mockSafeRawFiles, mockConfig, progressCallback);
    expect(mockDeps.generateOutput).toHaveBeenCalledWith('root', mockConfig, mockProcessedFiles, mockFilePaths);
    expect(mockDeps.writeOutputToDisk).toHaveBeenCalledWith(mockOutput, mockConfig);
    expect(mockDeps.copyToClipboardIfEnabled).toHaveBeenCalledWith(mockOutput, progressCallback, mockConfig);
    expect(mockDeps.calculateMetrics).toHaveBeenCalledWith(
      mockProcessedFiles,
      mockOutput,
      progressCallback,
      mockConfig,
    );

    // Check the result of pack function
    expect(result.totalFiles).toBe(2);
    expect(result.totalCharacters).toBe(11);
    expect(result.totalTokens).toBe(10);
    expect(result.fileCharCounts).toEqual({
      'file1.txt': 19,
      [file2Path]: 19,
    });
    expect(result.fileTokenCounts).toEqual({
      'file1.txt': 10,
      [file2Path]: 10,
    });
  });
});
</file>

<file path="tests/integration-tests/packager.test.ts">
import fs from 'node:fs/promises';
import os from 'node:os';
import path from 'node:path';
import process from 'node:process';
import { afterEach, beforeEach, describe, expect, test } from 'vitest';
import { loadFileConfig, mergeConfigs } from '../../src/config/configLoad.js';
import type { RepomixConfigFile, RepomixConfigMerged, RepomixOutputStyle } from '../../src/config/configSchema.js';
import { pack } from '../../src/core/packager.js';
import { isWindows } from '../testing/testUtils.js';

const fixturesDir = path.join(__dirname, 'fixtures', 'packager');
const inputsDir = path.join(fixturesDir, 'inputs');
const outputsDir = path.join(fixturesDir, 'outputs');

describe.runIf(!isWindows)('packager integration', () => {
  const testCases = [
    { desc: 'simple plain style', input: 'simple-project', output: 'simple-project-output.txt', config: {} },
    {
      desc: 'simple xml style',
      input: 'simple-project',
      output: 'simple-project-output.xml',
      config: { output: { style: 'xml', filePath: 'simple-project-output.xml' } },
    },
  ];

  let tempDir: string;

  beforeEach(async () => {
    // Create a temporary directory for each test
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'repomix-test-'));
  });

  afterEach(async () => {
    // Clean up the temporary directory after each test
    await fs.rm(tempDir, { recursive: true, force: true });
  });

  for (const { desc, input, output, config } of testCases) {
    test(`should correctly pack ${desc}`, async () => {
      const inputDir = path.join(inputsDir, input);
      const expectedOutputPath = path.join(outputsDir, output);
      const actualOutputPath = path.join(tempDir, output);

      const fileConfig: RepomixConfigFile = await loadFileConfig(inputDir, null);
      const mergedConfig: RepomixConfigMerged = mergeConfigs(process.cwd(), fileConfig, {
        output: {
          filePath: actualOutputPath,
          style: (config.output?.style || 'plain') as RepomixOutputStyle,
        },
      });

      // Run the pack function
      await pack(inputDir, mergedConfig);

      // Read the actual and expected outputs
      let actualOutput = await fs.readFile(actualOutputPath, 'utf-8');
      let expectedOutput = await fs.readFile(expectedOutputPath, 'utf-8');

      actualOutput = actualOutput.replace(/^Generated by Repomix on:.*\n/gm, '');
      expectedOutput = expectedOutput.replace(/^Generated by Repomix on:.*\n/gm, '');

      // Compare the outputs
      expect(actualOutput).toBe(expectedOutput);

      // Optionally, update the expected output if explicitly requested
      if (process.env.UPDATE_EXPECTED_OUTPUT) {
        await fs.writeFile(expectedOutputPath, actualOutput);
        console.log(`Updated expected output for ${desc}`);
      }
    });
  }
});
</file>

<file path="tests/shared/logger.test.ts">
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { logger } from '../../src/shared/logger.js';

vi.mock('picocolors', () => ({
  default: {
    red: vi.fn((str) => `RED:${str}`),
    yellow: vi.fn((str) => `YELLOW:${str}`),
    green: vi.fn((str) => `GREEN:${str}`),
    cyan: vi.fn((str) => `CYAN:${str}`),
    dim: vi.fn((str) => `DIM:${str}`),
    blue: vi.fn((str) => `BLUE:${str}`),
    gray: vi.fn((str) => `GRAY:${str}`),
  },
}));

describe('logger', () => {
  beforeEach(() => {
    vi.spyOn(console, 'error').mockImplementation(vi.fn());
    vi.spyOn(console, 'log').mockImplementation(vi.fn());
    logger.setVerbose(false);
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should log error messages', () => {
    logger.error('Error message');
    expect(console.error).toHaveBeenCalledWith('RED:Error message');
  });

  it('should log warning messages', () => {
    logger.warn('Warning message');
    expect(console.log).toHaveBeenCalledWith('YELLOW:Warning message');
  });

  it('should log success messages', () => {
    logger.success('Success message');
    expect(console.log).toHaveBeenCalledWith('GREEN:Success message');
  });

  it('should log info messages', () => {
    logger.info('Info message');
    expect(console.log).toHaveBeenCalledWith('CYAN:Info message');
  });

  it('should log note messages', () => {
    logger.note('Note message');
    expect(console.log).toHaveBeenCalledWith('DIM:Note message');
  });

  it('should log log messages', () => {
    logger.log('Note message');
    expect(console.log).toHaveBeenCalledWith('Note message');
  });

  it('should not log debug messages when verbose is false', () => {
    logger.debug('Debug message');
    expect(console.log).not.toHaveBeenCalled();
  });

  it('should log debug messages when verbose is true', () => {
    logger.setVerbose(true);
    logger.debug('Debug message');
    expect(console.log).toHaveBeenCalledWith('BLUE:Debug message');
  });

  it('should not log trace messages when verbose is false', () => {
    logger.trace('Trace message');
    expect(console.log).not.toHaveBeenCalled();
  });

  it('should log trace messages when verbose is true', () => {
    logger.setVerbose(true);
    logger.trace('Trace message');
    expect(console.log).toHaveBeenCalledWith('GRAY:Trace message');
  });

  it('should format object arguments correctly', () => {
    const obj = { key: 'value' };
    logger.info('Object:', obj);
    expect(console.log).toHaveBeenCalledWith(expect.stringContaining('CYAN:Object: '));
  });

  it('should handle multiple arguments', () => {
    logger.info('Multiple', 'arguments', 123);
    expect(console.log).toHaveBeenCalledWith('CYAN:Multiple arguments 123');
  });
});
</file>

<file path="tests/testing/testUtils.ts">
import os from 'node:os';
import process from 'node:process';
import { type RepomixConfigMerged, defaultConfig } from '../../src/config/configSchema.js';

type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends (infer U)[]
    ? DeepPartial<U>[]
    : T[P] extends readonly (infer U)[]
      ? readonly DeepPartial<U>[]
      : T[P] extends object
        ? DeepPartial<T[P]>
        : T[P];
};

export const createMockConfig = (config: DeepPartial<RepomixConfigMerged> = {}): RepomixConfigMerged => {
  return {
    cwd: process.cwd(),
    output: {
      ...defaultConfig.output,
      ...config.output,
    },
    ignore: {
      ...defaultConfig.ignore,
      ...config.ignore,
      customPatterns: [...(defaultConfig.ignore.customPatterns || []), ...(config.ignore?.customPatterns || [])],
    },
    include: [...(defaultConfig.include || []), ...(config.include || [])],
    security: {
      ...defaultConfig.security,
      ...config.security,
    },
    tokenCount: {
      ...defaultConfig.tokenCount,
      ...config.tokenCount,
    },
  };
};

export const isWindows = os.platform() === 'win32';
export const isMac = os.platform() === 'darwin';
export const isLinux = os.platform() === 'linux';
</file>

<file path="website/client/.vitepress/config/configEnUs.ts">
import { defineConfig } from 'vitepress';

export const configEnUs = defineConfig({
  lang: 'en-US',
  description: 'Pack your codebase into AI-friendly formats',
  themeConfig: {
    nav: [
      // guide
      { text: 'Guide', link: '/guide/' },
      { text: 'Join Discord', link: 'https://discord.gg/wNYzTwZFku' },
    ],
    sidebar: {
      '/guide/': [
        {
          text: 'Guide',
          items: [
            { text: 'Getting Started', link: '/guide/' },
            { text: 'Installation', link: '/guide/installation' },
            { text: 'Basic Usage', link: '/guide/usage' },
            { text: 'Prompt Examples', link: '/guide/prompt-examples' },
            { text: 'Output Formats', link: '/guide/output' },
            { text: 'Command Line Options', link: '/guide/command-line-options' },
            { text: 'Remote Repository Processing', link: '/guide/remote-repository-processing' },
            { text: 'Configuration', link: '/guide/configuration' },
            { text: 'Custom Instructions', link: '/guide/custom-instructions' },
            { text: 'Comment Removal', link: '/guide/comment-removal' },
            { text: 'Security', link: '/guide/security' },
            {
              text: 'Tips & Tricks',
              items: [{ text: 'Best Practices', link: '/guide/tips/best-practices' }],
            },
            {
              text: 'Development',
              items: [
                { text: 'Contributing', link: '/guide/development/' },
                { text: 'Setup', link: '/guide/development/setup' },
              ],
            },
          ],
        },
      ],
    },
  },
});
</file>

<file path="website/client/.vitepress/config/configEs.ts">
import { type DefaultTheme, defineConfig } from 'vitepress';

export const configEs = defineConfig({
  lang: 'es',
  description: 'Empaqueta tu código en formatos compatibles con la inteligencia artificial',
  themeConfig: {
    nav: [
      // guía
      { text: 'Guía', link: '/es/guide/' },
      { text: 'Únete a Discord', link: 'https://discord.gg/wNYzTwZFku' },
    ],
    sidebar: {
      '/es/guide/': [
        {
          text: 'Guía',
          items: [
            { text: 'Introducción', link: '/es/guide/' },
            { text: 'Instalación', link: '/es/guide/installation' },
            { text: 'Uso Básico', link: '/es/guide/usage' },
            { text: 'Ejemplos de Prompt', link: '/es/guide/prompt-examples' },
            { text: 'Formatos de Salida', link: '/es/guide/output' },
            { text: 'Opciones de Línea de Comando', link: '/es/guide/command-line-options' },
            { text: 'Procesamiento de Repositorios Remotos', link: '/es/guide/remote-repository-processing' },
            { text: 'Configuración', link: '/es/guide/configuration' },
            { text: 'Instrucciones Personalizadas', link: '/es/guide/custom-instructions' },
            { text: 'Eliminación de Comentarios', link: '/es/guide/comment-removal' },
            { text: 'Seguridad', link: '/es/guide/security' },
            {
              text: 'Consejos y Trucos',
              items: [{ text: 'Mejores Prácticas', link: '/es/guide/tips/best-practices' }],
            },
            {
              text: 'Desarrollo',
              items: [
                { text: 'Contribuir', link: '/es/guide/development/' },
                { text: 'Configuración Inicial', link: '/es/guide/development/setup' },
              ],
            },
          ],
        },
      ],
    },
  },
});

export const configEsSearch: DefaultTheme.LocalSearchOptions['locales'] = {
  es: {
    translations: {
      button: {
        buttonText: 'Buscar',
        buttonAriaLabel: 'Buscar',
      },
      modal: {
        noResultsText: 'Sin resultados',
        resetButtonTitle: 'Restablecer búsqueda',
        backButtonTitle: 'Volver',
        displayDetails: 'Mostrar detalles',
        footer: {
          selectText: 'Seleccionar',
          navigateText: 'Navegar',
          closeText: 'Cerrar',
        },
      },
    },
  },
};
</file>

<file path="website/client/.vitepress/config/configJa.ts">
import { type DefaultTheme, defineConfig } from 'vitepress';

export const configJa = defineConfig({
  lang: 'ja',
  description: 'コードベースをAIフレンドリーな形式にパッケージング',
  themeConfig: {
    nav: [
      { text: '使い方', link: '/ja/guide/' },
      { text: 'Discordに参加', link: 'https://discord.gg/wNYzTwZFku' },
    ],
    sidebar: {
      '/ja/guide/': [
        {
          text: '使い方',
          items: [
            { text: 'はじめに', link: '/ja/guide/' },
            { text: 'インストール', link: '/ja/guide/installation' },
            { text: '基本的な使い方', link: '/ja/guide/usage' },
            { text: 'プロンプト例', link: '/ja/guide/prompt-examples' },
            { text: '出力フォーマット', link: '/ja/guide/output' },
            { text: 'コマンドラインオプション', link: '/ja/guide/command-line-options' },
            { text: 'リモートリポジトリの処理', link: '/ja/guide/remote-repository-processing' },
            { text: '設定', link: '/ja/guide/configuration' },
            { text: 'カスタム指示', link: '/ja/guide/custom-instructions' },
            { text: 'コメントの削除', link: '/ja/guide/comment-removal' },
            { text: 'セキュリティ', link: '/ja/guide/security' },
            {
              text: 'ヒント＆テクニック',
              items: [{ text: 'ベストプラクティス', link: '/ja/guide/tips/best-practices' }],
            },
            {
              text: '開発',
              items: [
                { text: '開発への貢献', link: '/ja/guide/development/' },
                { text: '環境構築', link: '/ja/guide/development/setup' },
              ],
            },
          ],
        },
      ],
    },
  },
});

export const configJaSearch: DefaultTheme.LocalSearchOptions['locales'] = {
  ja: {
    translations: {
      button: {
        buttonText: '検索',
        buttonAriaLabel: '検索',
      },
      modal: {
        noResultsText: '検索結果がありません',
        resetButtonTitle: '検索をリセット',
        backButtonTitle: '前に戻る',
        displayDetails: '詳細を表示',
        footer: {
          selectText: '選択',
          navigateText: '移動',
          closeText: '閉じる',
        },
      },
    },
  },
};
</file>

<file path="website/client/.vitepress/config/configKo.ts">
import { type DefaultTheme, defineConfig } from 'vitepress';

export const configKo = defineConfig({
  lang: 'ko-KR',
  description: '코드베이스를 AI 친화적인 형식으로 패키징',
  themeConfig: {
    nav: [
      { text: '가이드', link: '/ko/guide/' },
      { text: 'Discord 참여', link: 'https://discord.gg/wNYzTwZFku' },
    ],
    sidebar: {
      '/ko/guide/': [
        {
          text: '가이드',
          items: [
            { text: '시작하기', link: '/ko/guide/' },
            { text: '설치', link: '/ko/guide/installation' },
            { text: '기본 사용법', link: '/ko/guide/usage' },
            { text: '프롬프트 예제', link: '/ko/guide/prompt-examples' },
            { text: '출력 형식', link: '/ko/guide/output' },
            { text: '명령행 옵션', link: '/ko/guide/command-line-options' },
            { text: '원격 저장소 처리', link: '/ko/guide/remote-repository-processing' },
            { text: '설정', link: '/ko/guide/configuration' },
            { text: '사용자 지정 지시사항', link: '/ko/guide/custom-instructions' },
            { text: '주석 제거', link: '/ko/guide/comment-removal' },
            { text: '보안', link: '/ko/guide/security' },
            {
              text: '팁과 요령',
              items: [{ text: '모범 사례', link: '/ko/guide/tips/best-practices' }],
            },
            {
              text: '개발',
              items: [
                { text: '기여하기', link: '/ko/guide/development/' },
                { text: '환경 설정', link: '/ko/guide/development/setup' },
              ],
            },
          ],
        },
      ],
    },
  },
});

export const configKoSearch: DefaultTheme.LocalSearchOptions['locales'] = {
  ko: {
    translations: {
      button: {
        buttonText: '검색',
        buttonAriaLabel: '검색',
      },
      modal: {
        noResultsText: '결과 없음',
        resetButtonTitle: '검색 재설정',
        backButtonTitle: '뒤로',
        displayDetails: '세부 정보 표시',
        footer: {
          selectText: '선택',
          navigateText: '이동',
          closeText: '닫기',
        },
      },
    },
  },
};
</file>

<file path="website/client/.vitepress/config/configPtBr.ts">
import { type DefaultTheme, defineConfig } from 'vitepress';

export const configPtBr = defineConfig({
  lang: 'pt-br',
  description: 'Empacote seu código em formatos compatíveis com IA',
  themeConfig: {
    nav: [
      // guia
      { text: 'Guia', link: '/pt-br/guide/' },
      { text: 'Entrar no Discord', link: 'https://discord.gg/wNYzTwZFku' },
    ],
    sidebar: {
      '/pt-br/guide/': [
        {
          text: 'Guia',
          items: [
            { text: 'Introdução', link: '/pt-br/guide/' },
            { text: 'Instalação', link: '/pt-br/guide/installation' },
            { text: 'Uso Básico', link: '/pt-br/guide/usage' },
            { text: 'Exemplos de Prompt', link: '/pt-br/guide/prompt-examples' },
            { text: 'Formatos de Saída', link: '/pt-br/guide/output' },
            { text: 'Opções de Linha de Comando', link: '/pt-br/guide/command-line-options' },
            { text: 'Processamento de Repositórios Remotos', link: '/pt-br/guide/remote-repository-processing' },
            { text: 'Configuração', link: '/pt-br/guide/configuration' },
            { text: 'Instruções Personalizadas', link: '/pt-br/guide/custom-instructions' },
            { text: 'Remoção de Comentários', link: '/pt-br/guide/comment-removal' },
            { text: 'Segurança', link: '/pt-br/guide/security' },
            {
              text: 'Dicas e Truques',
              items: [{ text: 'Melhores Práticas', link: '/pt-br/guide/tips/best-practices' }],
            },
            {
              text: 'Desenvolvimento',
              items: [
                { text: 'Contribuindo', link: '/pt-br/guide/development/' },
                { text: 'Configuração Inicial', link: '/pt-br/guide/development/setup' },
              ],
            },
          ],
        },
      ],
    },
  },
});

export const configPtBrSearch: DefaultTheme.LocalSearchOptions['locales'] = {
  'pt-br': {
    translations: {
      button: {
        buttonText: 'Pesquisar',
        buttonAriaLabel: 'Pesquisar',
      },
      modal: {
        noResultsText: 'Sem resultados',
        resetButtonTitle: 'Redefinir pesquisa',
        backButtonTitle: 'Voltar',
        displayDetails: 'Mostrar detalhes',
        footer: {
          selectText: 'Selecionar',
          navigateText: 'Navegar',
          closeText: 'Fechar',
        },
      },
    },
  },
};
</file>

<file path="website/client/.vitepress/config/configShard.ts">
import { defineConfig } from 'vitepress';
import { configEsSearch } from './configEs';
import { configJaSearch } from './configJa';
import { configKoSearch } from './configKo';
import { configPtBrSearch } from './configPtBr';
import { configZhCnSearch } from './configZhCn';

const googleAnalyticsTag = 'G-7PTT4PLC69';

export const configShard = defineConfig({
  title: 'Repomix',

  srcDir: 'src',

  rewrites: {
    // rewrite to `en` locale
    'en/:rest*': ':rest*',
  },

  lastUpdated: true,
  cleanUrls: true,
  metaChunk: true,

  sitemap: {
    hostname: 'https://repomix.com/',
  },

  // Shared configuration
  themeConfig: {
    logo: { src: '/images/repomix-logo.svg', width: 24, height: 24 },
    search: {
      provider: 'local',
      options: {
        locales: {
          ...configJaSearch,
          ...configZhCnSearch,
          ...configKoSearch,
          ...configPtBrSearch,
          ...configEsSearch,
        },
      },
    },
    socialLinks: [
      { icon: 'discord', link: 'https://discord.gg/wNYzTwZFku' },
      { icon: 'github', link: 'https://github.com/yamadashy/repomix' },
    ],
    footer: {
      message: 'Released under the MIT License.',
      copyright: 'Copyright © 2024 Kazuki Yamada',
    },
    // Language selection
    langMenuLabel: 'Languages',
  },

  head: [
    // Favicon
    ['link', { rel: 'icon', href: '/images/repomix-logo.svg' }],

    // OGP
    ['meta', { property: 'og:type', content: 'website' }],
    ['meta', { property: 'og:title', content: 'Repomix' }],
    ['meta', { property: 'og:site_name', content: 'Repomix' }],
    ['meta', { property: 'og:image', content: 'https://repomix.com/images/og-image-large.png' }],
    ['meta', { property: 'og:url', content: 'https://repomix.com' }],
    ['meta', { property: 'og:description', content: 'Pack your codebase into AI-friendly formats' }],
    ['meta', { name: 'twitter:card', content: 'summary_large_image' }],
    ['meta', { property: 'twitter:domain', content: 'https://repomix.com' }],
    ['meta', { property: 'twitter:url', content: 'https://repomix.com' }],
    ['meta', { name: 'twitter:title', content: 'Repomix' }],
    ['meta', { name: 'twitter:description', content: 'Pack your codebase into AI-friendly formats' }],
    ['meta', { name: 'twitter:image', content: 'https://repomix.com/images/og-image-large.png' }],
    ['meta', { name: 'thumbnail', content: 'https://repomix.com/images/og-image-large.png' }],

    // PWA
    ['meta', { name: 'theme-color', content: '#f97316' }],

    // Google Analytics
    [
      'script',
      {
        async: true,
        src: `https://www.googletagmanager.com/gtag/js?id=${googleAnalyticsTag}`,
      },
    ],
    [
      'script',
      {},
      `window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', '${googleAnalyticsTag}');`,
    ],
  ],
});
</file>

<file path="website/client/.vitepress/config/configZhCn.ts">
import { type DefaultTheme, defineConfig } from 'vitepress';

export const configZhCn = defineConfig({
  lang: 'zh-cn',
  description: '将代码库打包成AI友好的格式',
  themeConfig: {
    nav: [
      { text: '指南', link: '/zh-cn/guide/' },
      { text: '加入Discord', link: 'https://discord.gg/wNYzTwZFku' },
    ],
    sidebar: {
      '/zh-cn/guide/': [
        {
          text: '指南',
          items: [
            { text: '入门指南', link: '/zh-cn/guide/' },
            { text: '安装', link: '/zh-cn/guide/installation' },
            { text: '基本用法', link: '/zh-cn/guide/usage' },
            { text: '提示示例', link: '/zh-cn/guide/prompt-examples' },
            { text: '输出格式', link: '/zh-cn/guide/output' },
            { text: '命令行选项', link: '/zh-cn/guide/command-line-options' },
            { text: '远程仓库处理', link: '/zh-cn/guide/remote-repository-processing' },
            { text: '配置', link: '/zh-cn/guide/configuration' },
            { text: '自定义指令', link: '/zh-cn/guide/custom-instructions' },
            { text: '注释移除', link: '/zh-cn/guide/comment-removal' },
            { text: '安全性', link: '/zh-cn/guide/security' },
            {
              text: '技巧与窍门',
              items: [{ text: '最佳实践', link: '/zh-cn/guide/tips/best-practices' }],
            },
            {
              text: '开发',
              items: [
                { text: '参与贡献', link: '/zh-cn/guide/development/' },
                { text: '环境搭建', link: '/zh-cn/guide/development/setup' },
              ],
            },
          ],
        },
      ],
    },
  },
});

export const configZhCnSearch: DefaultTheme.LocalSearchOptions['locales'] = {
  'zh-cn': {
    translations: {
      button: {
        buttonText: '搜索',
        buttonAriaLabel: '搜索',
      },
      modal: {
        noResultsText: '无结果',
        resetButtonTitle: '重置搜索',
        backButtonTitle: '返回',
        displayDetails: '显示详情',
        footer: {
          selectText: '选择',
          navigateText: '导航',
          closeText: '关闭',
        },
      },
    },
  },
};
</file>

<file path="website/client/.vitepress/theme/component.d.ts">
declare module '*.vue' {
  import type { DefineComponent } from 'vue';
  // biome-ignore lint lint/suspicious/noExplicitAny: Vue component
  const component: DefineComponent<{}, {}, any>;
  export default component;
}
</file>

<file path="website/client/.vitepress/theme/custom.css">
:root {
  --vp-c-brand-1: #f97316;
  --vp-c-brand-2: #ea580c;
  --vp-c-brand-3: #c2410c;
  --vp-c-brand-soft: rgba(249, 115, 22, 0.1);

  --vp-home-hero-name-color: transparent;
  --vp-home-hero-name-background: linear-gradient(120deg, #f97316 30%, #ffb25c);

  --vp-home-hero-image-background-image: linear-gradient(-45deg, rgba(249, 115, 22, 0.3) 30%, rgba(249, 115, 22, 0.1));
  --vp-home-hero-image-filter: blur(96px);
}

.hero-description__accent {
  color: var(--vp-c-brand-1);
}
.cli-section {
  padding-top: 64px;
  margin-bottom: 32px;
  max-width: 800px;
  margin-left: auto;
  margin-right: auto;
}

.cli-section h2 {
  font-size: 2rem;
  font-weight: 600;
  margin-bottom: 1.5rem;
  background: linear-gradient(120deg, #f97316 30%, #ffb25c);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}
</file>

<file path="website/client/.vitepress/theme/index.ts">
import type { Theme } from 'vitepress';
import DefaultTheme from 'vitepress/theme';
import { h } from 'vue';
import Home from '../../components/Home.vue';
import './custom.css';

export default {
  extends: DefaultTheme,
  Layout: () => {
    return h(DefaultTheme.Layout, null, {
      'home-hero-after': () => h(Home),
    });
  },
} satisfies Theme;
</file>

<file path="website/client/.vitepress/theme/style.css">
/**
 * Customize default theme styling by overriding CSS variables:
 * https://github.com/vuejs/vitepress/blob/main/src/client/theme-default/styles/vars.css
 */

/**
 * Colors
 *
 * Each colors have exact same color scale system with 3 levels of solid
 * colors with different brightness, and 1 soft color.
 *
 * - `XXX-1`: The most solid color used mainly for colored text. It must
 *   satisfy the contrast ratio against when used on top of `XXX-soft`.
 *
 * - `XXX-2`: The color used mainly for hover state of the button.
 *
 * - `XXX-3`: The color for solid background, such as bg color of the button.
 *   It must satisfy the contrast ratio with pure white (#ffffff) text on
 *   top of it.
 *
 * - `XXX-soft`: The color used for subtle background such as custom container
 *   or badges. It must satisfy the contrast ratio when putting `XXX-1` colors
 *   on top of it.
 *
 *   The soft color must be semi transparent alpha channel. This is crucial
 *   because it allows adding multiple "soft" colors on top of each other
 *   to create a accent, such as when having inline code block inside
 *   custom containers.
 *
 * - `default`: The color used purely for subtle indication without any
 *   special meanings attached to it such as bg color for menu hover state.
 *
 * - `brand`: Used for primary brand colors, such as link text, button with
 *   brand theme, etc.
 *
 * - `tip`: Used to indicate useful information. The default theme uses the
 *   brand color for this by default.
 *
 * - `warning`: Used to indicate warning to the users. Used in custom
 *   container, badges, etc.
 *
 * - `danger`: Used to show error, or dangerous message to the users. Used
 *   in custom container, badges, etc.
 * -------------------------------------------------------------------------- */

:root {
  --vp-c-default-1: var(--vp-c-gray-1);
  --vp-c-default-2: var(--vp-c-gray-2);
  --vp-c-default-3: var(--vp-c-gray-3);
  --vp-c-default-soft: var(--vp-c-gray-soft);

  --vp-c-brand-1: var(--vp-c-indigo-1);
  --vp-c-brand-2: var(--vp-c-indigo-2);
  --vp-c-brand-3: var(--vp-c-indigo-3);
  --vp-c-brand-soft: var(--vp-c-indigo-soft);

  --vp-c-tip-1: var(--vp-c-brand-1);
  --vp-c-tip-2: var(--vp-c-brand-2);
  --vp-c-tip-3: var(--vp-c-brand-3);
  --vp-c-tip-soft: var(--vp-c-brand-soft);

  --vp-c-warning-1: var(--vp-c-yellow-1);
  --vp-c-warning-2: var(--vp-c-yellow-2);
  --vp-c-warning-3: var(--vp-c-yellow-3);
  --vp-c-warning-soft: var(--vp-c-yellow-soft);

  --vp-c-danger-1: var(--vp-c-red-1);
  --vp-c-danger-2: var(--vp-c-red-2);
  --vp-c-danger-3: var(--vp-c-red-3);
  --vp-c-danger-soft: var(--vp-c-red-soft);
}

/**
 * Component: Button
 * -------------------------------------------------------------------------- */

:root {
  --vp-button-brand-border: transparent;
  --vp-button-brand-text: var(--vp-c-white);
  --vp-button-brand-bg: var(--vp-c-brand-3);
  --vp-button-brand-hover-border: transparent;
  --vp-button-brand-hover-text: var(--vp-c-white);
  --vp-button-brand-hover-bg: var(--vp-c-brand-2);
  --vp-button-brand-active-border: transparent;
  --vp-button-brand-active-text: var(--vp-c-white);
  --vp-button-brand-active-bg: var(--vp-c-brand-1);
}

/**
 * Component: Home
 * -------------------------------------------------------------------------- */

:root {
  --vp-home-hero-name-color: transparent;
  --vp-home-hero-name-background: -webkit-linear-gradient(120deg, #bd34fe 30%, #41d1ff);

  --vp-home-hero-image-background-image: linear-gradient(-45deg, #bd34fe 50%, #47caff 50%);
  --vp-home-hero-image-filter: blur(44px);
}

@media (min-width: 640px) {
  :root {
    --vp-home-hero-image-filter: blur(56px);
  }
}

@media (min-width: 960px) {
  :root {
    --vp-home-hero-image-filter: blur(68px);
  }
}

/**
 * Component: Custom Block
 * -------------------------------------------------------------------------- */

:root {
  --vp-custom-block-tip-border: transparent;
  --vp-custom-block-tip-text: var(--vp-c-text-1);
  --vp-custom-block-tip-bg: var(--vp-c-brand-soft);
  --vp-custom-block-tip-code-bg: var(--vp-c-brand-soft);
}

/**
 * Component: Algolia
 * -------------------------------------------------------------------------- */

.DocSearch {
  --docsearch-primary-color: var(--vp-c-brand-1) !important;
}
</file>

<file path="website/client/.vitepress/config.ts">
import { defineConfig } from 'vitepress';
import { configEnUs } from './config/configEnUs';
import { configEs } from './config/configEs';
import { configJa } from './config/configJa';
import { configKo } from './config/configKo';
import { configPtBr } from './config/configPtBr';
import { configShard } from './config/configShard';
import { configZhCn } from './config/configZhCn';

export default defineConfig({
  ...configShard,
  locales: {
    root: { label: 'English', ...configEnUs },
    'zh-cn': { label: '简体中文', ...configZhCn },
    ja: { label: '日本語', ...configJa },
    es: { label: 'Español', ...configEs },
    'pt-br': { label: 'Português', ...configPtBr },
    ko: { label: '한국어', ...configKo },
  },
});
</file>

<file path="website/client/components/api/client.ts">
export interface PackOptions {
  removeComments: boolean;
  removeEmptyLines: boolean;
  showLineNumbers: boolean;
  fileSummary?: boolean;
  directoryStructure?: boolean;
  includePatterns?: string;
  ignorePatterns?: string;
}

export interface PackRequest {
  url: string;
  format: 'xml' | 'markdown' | 'plain';
  options: PackOptions;
  signal?: AbortSignal;
}

export interface PackResult {
  content: string;
  format: string;
  metadata: {
    repository: string;
    timestamp: string;
    summary: {
      totalFiles: number;
      totalCharacters: number;
      totalTokens: number;
    };
    topFiles: {
      path: string;
      charCount: number;
    }[];
  };
}

export interface ErrorResponse {
  error: string;
}

export class ApiError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ApiError';
  }
}

const API_BASE_URL = import.meta.env.PROD ? 'https://api.repomix.com' : 'http://localhost:8080';

export async function packRepository(request: PackRequest): Promise<PackResult> {
  const response = await fetch(`${API_BASE_URL}/api/pack`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(request),
    signal: request.signal,
  });

  const data = await response.json();

  if (!response.ok) {
    throw new ApiError((data as ErrorResponse).error);
  }

  return data as PackResult;
}

// TODO: Share this validation logic with repomix core (src/cli/actions/remoteAction.ts)
export function isValidRemoteValue(remoteValue: string): boolean {
  // Check the short form of the GitHub URL. e.g. yamadashy/repomix
  const namePattern = '[a-zA-Z0-9](?:[a-zA-Z0-9._-]*[a-zA-Z0-9])?';
  const shortFormRegex = new RegExp(`^${namePattern}/${namePattern}$`);
  if (shortFormRegex.test(remoteValue)) {
    return true;
  }

  // Check the direct form of the GitHub URL. e.g.  https://github.com/yamadashy/repomix or https://gist.github.com/yamadashy/1234567890abcdef
  try {
    new URL(remoteValue);
    return true;
  } catch (error) {
    return false;
  }
}
</file>

<file path="website/client/components/utils/analytics.ts">
// Analytics event categories
export const AnalyticsCategory = {
  REPOSITORY: 'repository',
  FORMAT: 'format',
  OPTIONS: 'options',
  OUTPUT: 'output',
} as const;

// Analytics event actions
export const AnalyticsAction = {
  // Repository events
  PACK_START: 'pack_start',
  PACK_SUCCESS: 'pack_success',
  PACK_SUCCESS_FILES: 'pack_success_files',
  PACK_SUCCESS_CHARS: 'pack_success_chars',
  PACK_ERROR: 'pack_error',

  // Format events
  FORMAT_CHANGE: 'format_change',

  // Options events
  TOGGLE_REMOVE_COMMENTS: 'toggle_remove_comments',
  TOGGLE_REMOVE_EMPTY_LINES: 'toggle_remove_empty_lines',
  TOGGLE_LINE_NUMBERS: 'toggle_line_numbers',
  TOGGLE_FILE_SUMMARY: 'toggle_file_summary',
  TOGGLE_DIRECTORY_STRUCTURE: 'toggle_directory_structure',
  UPDATE_INCLUDE_PATTERNS: 'update_include_patterns',
  UPDATE_IGNORE_PATTERNS: 'update_ignore_patterns',

  // Output events
  COPY_OUTPUT: 'copy_output',
  DOWNLOAD_OUTPUT: 'download_output',
} as const;

export type AnalyticsCategoryType = (typeof AnalyticsCategory)[keyof typeof AnalyticsCategory];
export type AnalyticsActionType = (typeof AnalyticsAction)[keyof typeof AnalyticsAction];

// Google Analytics event tracking interface
interface GAEventParams {
  category: AnalyticsCategoryType;
  action: AnalyticsActionType;
  label?: string;
  value?: number;
}

// Track an event using gtag
export function trackEvent({ category, action, label, value }: GAEventParams): void {
  if (typeof window === 'undefined' || !window.gtag) {
    return;
  }

  window.gtag('event', action, {
    event_category: category,
    event_label: label,
    value: value,
  });
}

// Analytics utility functions for specific events
export const analyticsUtils = {
  // Repository events
  trackPackStart(repoUrl: string): void {
    trackEvent({
      category: AnalyticsCategory.REPOSITORY,
      action: AnalyticsAction.PACK_START,
      label: repoUrl,
    });
  },

  trackPackSuccess(repoUrl: string, totalFiles: number, totalChars: number): void {
    trackEvent({
      category: AnalyticsCategory.REPOSITORY,
      action: AnalyticsAction.PACK_SUCCESS_FILES,
      label: `${repoUrl}_files`,
      value: totalFiles,
    });
    trackEvent({
      category: AnalyticsCategory.REPOSITORY,
      action: AnalyticsAction.PACK_SUCCESS_CHARS,
      label: `${repoUrl}_chars`,
      value: totalChars,
    });
  },

  trackPackError(repoUrl: string, error: string): void {
    trackEvent({
      category: AnalyticsCategory.REPOSITORY,
      action: AnalyticsAction.PACK_ERROR,
      label: `${repoUrl} - ${error}`,
    });
  },

  // Format events
  trackFormatChange(format: string): void {
    trackEvent({
      category: AnalyticsCategory.FORMAT,
      action: AnalyticsAction.FORMAT_CHANGE,
      label: format,
    });
  },

  // Options events
  trackOptionToggle(action: AnalyticsActionType, enabled: boolean): void {
    trackEvent({
      category: AnalyticsCategory.OPTIONS,
      action: action,
      label: enabled ? 'enabled' : 'disabled',
    });
  },

  trackIncludePatternsUpdate(patterns: string): void {
    trackEvent({
      category: AnalyticsCategory.OPTIONS,
      action: AnalyticsAction.UPDATE_INCLUDE_PATTERNS,
      label: patterns,
    });
  },

  trackIgnorePatternsUpdate(patterns: string): void {
    trackEvent({
      category: AnalyticsCategory.OPTIONS,
      action: AnalyticsAction.UPDATE_IGNORE_PATTERNS,
      label: patterns,
    });
  },

  // Output events
  trackCopyOutput(format: string): void {
    trackEvent({
      category: AnalyticsCategory.OUTPUT,
      action: AnalyticsAction.COPY_OUTPUT,
      label: format,
    });
  },

  trackDownloadOutput(format: string): void {
    trackEvent({
      category: AnalyticsCategory.OUTPUT,
      action: AnalyticsAction.DOWNLOAD_OUTPUT,
      label: format,
    });
  },
};

// Type definitions for window.gtag
declare global {
  interface Window {
    gtag: (
      command: 'event',
      action: string,
      params: {
        event_category: string;
        event_label?: string;
        value?: number;
      },
    ) => void;
  }
}
</file>

<file path="website/client/components/Hero.vue">
<script setup>
import { useData } from 'vitepress';

const { site } = useData();
</script>

<template>
  <section class="hero">
    <h1 class="hero-title">
      {{ site.title }}
    </h1>
    <p class="hero-description">
      Pack your codebase into <span class="hero-description__accent">AI-friendly</span> formats
    </p>
  </section>
</template>

<style scoped>
.hero {
  text-align: center;
  padding: 20px 20px;
  max-width: 960px;
  margin: 0 auto;
}

.hero-title {
  font-size: 64px;
  font-weight: 700;
  line-height: 1.2;
  margin-bottom: 24px;
  background: -webkit-linear-gradient(0deg, #f97316 30%, #ffb25c);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.hero-description {
  font-size: 32px;
  font-weight: 600;
  line-height: 1.4;
  margin-bottom: 16px;
  color: var(--vp-c-text-1);
}

.hero-description__accent {
  color: var(--vp-c-brand-1);
}

.hero-tagline {
  font-size: 18px;
  color: var(--vp-c-text-2);
  margin: 0;
}

@media (max-width: 768px) {
  .hero-title {
    font-size: 48px;
  }

  .hero-description {
    font-size: 24px;
  }

  .hero-tagline {
    font-size: 16px;
  }
}
</style>
</file>

<file path="website/client/components/Home.vue">
<script setup>
import Hero from './Hero.vue';
import TryIt from './TryIt.vue';
</script>

<template>
  <div class="home">
    <Hero />
    <TryIt />
  </div>
</template>

<style scoped>
.home {
  padding-bottom: 60px;
}
</style>
</file>

<file path="website/client/components/ResultViewer.vue">
<script setup lang="ts">
import { Copy, Download } from 'lucide-vue-next';
import { computed, ref } from 'vue';
import type { PackResult } from './api/client';
import { analyticsUtils } from './utils/analytics';

const props = defineProps<{
  result: PackResult | null;
  loading: boolean;
  error: string | null;
}>();

const copied = ref(false);

const formattedTimestamp = computed(() => {
  if (!props.result) return '';
  return new Date(props.result.metadata.timestamp).toLocaleString();
});

async function copyToClipboard(event: Event) {
  event.stopPropagation();
  event.preventDefault();

  if (!props.result) return;

  try {
    await navigator.clipboard.writeText(props.result.content);
    copied.value = true;
    // Track copy event
    analyticsUtils.trackCopyOutput(props.result.format);
    setTimeout(() => {
      copied.value = false;
    }, 2000);
  } catch (err) {
    console.error('Failed to copy:', err);
  }
}

function downloadResult(event: Event) {
  event.stopPropagation();
  event.preventDefault();

  if (!props.result) return;

  const blob = new Blob([props.result.content], { type: 'text/plain' });
  const url = window.URL.createObjectURL(blob);
  const a = document.createElement('a');
  let extension = 'txt';

  switch (props.result.format) {
    case 'markdown':
      extension = 'md';
      break;
    case 'xml':
      extension = 'xml';
      break;
  }

  a.href = url;
  a.download = `repomix-output.${extension}`;
  document.body.appendChild(a);
  a.click();

  // Track download event
  analyticsUtils.trackDownloadOutput(props.result.format);

  window.URL.revokeObjectURL(url);
  document.body.removeChild(a);
}
</script>

<template>
  <div class="result-viewer">
    <div v-if="loading" class="loading">
      <div class="spinner"></div>
      <p>Processing repository...</p>
    </div>

    <div v-else-if="error" class="error">
      <p>{{ error }}</p>
    </div>

    <div v-else-if="result" class="content-wrapper">
      <div class="metadata-panel">
        <div class="metadata-section">
          <h3>Repository Info</h3>
          <dl>
            <dt>Repository</dt>
            <dd>{{ result.metadata.repository }}</dd>
            <dt>Generated At</dt>
            <dd>{{ formattedTimestamp }}</dd>
            <dt>Format</dt>
            <dd>{{ result.format }}</dd>
          </dl>
        </div>

        <div class="metadata-section">
          <h3>Pack Summary</h3>
          <dl v-if="result.metadata.summary">
            <dt>Total Files</dt>
            <dd>{{ result.metadata.summary.totalFiles.toLocaleString() }} files</dd>
            <dt>Total Size</dt>
            <dd>{{ result.metadata.summary.totalCharacters.toLocaleString() }} chars</dd>
            <dt>Total Tokens</dt>
            <dd>{{ result.metadata.summary.totalTokens.toLocaleString() }} tokens</dd>
          </dl>
        </div>

        <div class="metadata-section" v-if="result.metadata.topFiles">
          <h3>Top {{ result.metadata.topFiles.length }} Files</h3>
          <ol class="top-files-list">
            <li v-for="file in result.metadata.topFiles" :key="file.path">
              <div class="file-path">{{ file.path }}</div>
              <div class="file-stats">
                {{ file.charCount.toLocaleString() }} chars
              </div>
            </li>
          </ol>
        </div>
      </div>

      <div class="output-panel">
        <div class="output-actions">
          <button
              class="action-button"
              @click="copyToClipboard"
              :class="{ copied }"
          >
            <Copy size="16" />
            {{ copied ? 'Copied!' : 'Copy' }}
          </button>
          <button
              class="action-button"
              @click="downloadResult"
          >
            <Download size="16" />
            Download
          </button>
        </div>
        <pre><code>{{ result.content }}</code></pre>
      </div>
    </div>
  </div>
</template>

<style scoped>
.result-viewer {
  margin-top: 24px;
  border: 1px solid var(--vp-c-border);
  border-radius: 8px;
  overflow: hidden;
}

.loading {
  padding: 48px;
  text-align: center;
}

.spinner {
  width: 40px;
  height: 40px;
  margin: 0 auto 16px;
  border: 3px solid var(--vp-c-brand-1);
  border-radius: 50%;
  border-top-color: transparent;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.error {
  padding: 24px;
  color: var(--vp-c-danger-1);
  text-align: center;
}

.content-wrapper {
  display: grid;
  grid-template-columns: 300px 1fr;
  height: 500px;
}

.metadata-panel {
  padding: 16px;
  border-right: 1px solid var(--vp-c-border);
  background: var(--vp-c-bg-soft);
  overflow-y: auto;
}

.metadata-section {
  margin-bottom: 24px;
}

.metadata-section:last-child {
  margin-bottom: 0;
}

.metadata-section h3 {
  font-size: 14px;
  font-weight: 600;
  margin: 0 0 12px;
  color: var(--vp-c-text-1);
}

dl {
  margin: 0;
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 8px;
  font-size: 13px;
}

dt {
  color: var(--vp-c-text-2);
  font-weight: 500;
}

dd {
  margin: 0;
  color: var(--vp-c-text-1);
  text-transform: lowercase;
}

.top-files-list {
  margin: 0;
  padding: 0 0 0 0;
  font-size: 13px;
}

.top-files-list li {
  margin-bottom: 8px;
  border-left: 2px solid var(--vp-c-divider);
  padding-left: 8px;
}

.file-path {
  color: var(--vp-c-text-1);
  margin-bottom: 2px;
  word-break: break-all;
}

.file-stats {
  font-size: 12px;
  color: var(--vp-c-text-2);
}

.output-panel {
  display: flex;
  flex-direction: column;
  height: 100%;
  max-height: 500px;
  background: var(--vp-c-bg);
  overflow: hidden;
}

.output-actions {
  display: flex;
  gap: 8px;
  padding: 12px;
  background: var(--vp-c-bg);
  border-bottom: 1px solid var(--vp-c-border);
  flex-shrink: 0;
}

.action-button {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  border: 1px solid var(--vp-c-border);
  border-radius: 6px;
  background: var(--vp-c-bg-soft);
  color: var(--vp-c-text-1);
  cursor: pointer;
  transition: all 0.2s ease;
}

.action-button:hover {
  border-color: var(--vp-c-brand-1);
}

.action-button.copied {
  background: var(--vp-c-brand-1);
  color: white;
  border-color: var(--vp-c-brand-1);
}

pre {
  margin: 0;
  padding: 16px;
  font-size: 13px;
  line-height: 1.5;
  height: 100%;
  overflow: auto;
  flex: 1;
}

code {
  font-family: var(--vp-font-family-mono);
  color: var(--vp-c-text-1);
  white-space: pre;
  word-wrap: normal;
}

@media (max-width: 768px) {
  .content-wrapper {
    grid-template-columns: 1fr;
    height: auto;
  }

  .metadata-panel {
    border-right: none;
    border-bottom: 1px solid var(--vp-c-border);
  }

  .output-panel {
    height: 500px;
  }
}
</style>
</file>

<file path="website/client/components/TryIt.vue">
<script setup lang="ts">
import { AlertTriangle } from 'lucide-vue-next';
import { computed, ref } from 'vue';
import ResultViewer from './ResultViewer.vue';
import { isValidRemoteValue, packRepository } from './api/client';
import type { PackResult } from './api/client';
import { AnalyticsAction, analyticsUtils } from './utils/analytics';

// Form input states
const url = ref('');
const format = ref<'xml' | 'markdown' | 'plain'>('xml');
const removeComments = ref(false);
const removeEmptyLines = ref(false);
const showLineNumbers = ref(false);
const fileSummary = ref(true);
const directoryStructure = ref(true);
const includePatterns = ref('');
const ignorePatterns = ref('');

// Processing states
const loading = ref(false);
const error = ref<string | null>(null);
const result = ref<PackResult | null>(null);
const hasExecuted = ref(false);

// URL validation
const isValidUrl = computed(() => {
  if (!url.value) return false;
  return isValidRemoteValue(url.value.trim());
});

const TIMEOUT_MS = 30000;
let currentRequest: AbortController | null = null;

async function handleSubmit() {
  if (!isValidUrl.value) return;

  // Cancel any pending request
  if (currentRequest) {
    currentRequest.abort();
  }
  currentRequest = new AbortController();

  loading.value = true;
  error.value = null;
  result.value = null;
  hasExecuted.value = true;

  const processedUrl = url.value.trim();

  // Track pack start
  analyticsUtils.trackPackStart(processedUrl);

  try {
    const timeoutId = setTimeout(() => {
      if (currentRequest) {
        currentRequest.abort();
        throw new Error('Request timed out');
      }
    }, TIMEOUT_MS);

    const response = await packRepository({
      url: processedUrl,
      format: format.value,
      options: {
        removeComments: removeComments.value,
        removeEmptyLines: removeEmptyLines.value,
        showLineNumbers: showLineNumbers.value,
        fileSummary: fileSummary.value,
        directoryStructure: directoryStructure.value,
        includePatterns: includePatterns.value ? includePatterns.value.trim() : undefined,
        ignorePatterns: ignorePatterns.value ? ignorePatterns.value.trim() : undefined,
      },
      signal: currentRequest.signal,
    });

    clearTimeout(timeoutId);

    // Set result
    result.value = {
      content: response.content,
      format: response.format,
      metadata: {
        repository: response.metadata.repository,
        timestamp: response.metadata.timestamp,
        summary: response.metadata.summary,
        topFiles: response.metadata.topFiles,
      },
    };

    // Track successful pack
    if (response.metadata.summary) {
      analyticsUtils.trackPackSuccess(
        processedUrl,
        response.metadata.summary.totalFiles,
        response.metadata.summary.totalCharacters,
      );
    }
  } catch (err: unknown) {
    const errorMessage = err instanceof Error ? err.message : 'An unexpected error occurred';
    if (errorMessage === 'AbortError') {
      error.value = 'Request was cancelled';
      return;
    }
    error.value = errorMessage;
    analyticsUtils.trackPackError(processedUrl, errorMessage);
    console.error('Error processing repository:', err);
  } finally {
    loading.value = false;
    currentRequest = null;
  }
}

// Event handlers with analytics
function handleFormatChange(newFormat: 'xml' | 'markdown' | 'plain') {
  format.value = newFormat;
  analyticsUtils.trackFormatChange(newFormat);
}

function handleRemoveCommentsToggle(enabled: boolean) {
  removeComments.value = enabled;
  analyticsUtils.trackOptionToggle(AnalyticsAction.TOGGLE_REMOVE_COMMENTS, enabled);
}

function handleRemoveEmptyLinesToggle(enabled: boolean) {
  removeEmptyLines.value = enabled;
  analyticsUtils.trackOptionToggle(AnalyticsAction.TOGGLE_REMOVE_EMPTY_LINES, enabled);
}

function handleShowLineNumbersToggle(enabled: boolean) {
  showLineNumbers.value = enabled;
  analyticsUtils.trackOptionToggle(AnalyticsAction.TOGGLE_LINE_NUMBERS, enabled);
}

function handleFileSummaryToggle(enabled: boolean) {
  fileSummary.value = enabled;
  analyticsUtils.trackOptionToggle(AnalyticsAction.TOGGLE_FILE_SUMMARY, enabled);
}

function handleDirectoryStructureToggle(enabled: boolean) {
  directoryStructure.value = enabled;
  analyticsUtils.trackOptionToggle(AnalyticsAction.TOGGLE_DIRECTORY_STRUCTURE, enabled);
}

function handleIncludePatternsUpdate(patterns: string) {
  includePatterns.value = patterns;
  analyticsUtils.trackIncludePatternsUpdate(patterns);
}

function handleIgnorePatternsUpdate(patterns: string) {
  ignorePatterns.value = patterns;
  analyticsUtils.trackIgnorePatternsUpdate(patterns);
}

// Handle URL input and form submission
function handleUrlInput(event: Event) {
  const input = event.target as HTMLInputElement;
  url.value = input.value;
}

function handleKeydown(event: KeyboardEvent) {
  if (event.key === 'Enter' && isValidUrl.value && !loading.value) {
    handleSubmit();
  }
}
</script>

<template>
  <div class="container">
    <form
        class="try-it-container"
        @submit.prevent="handleSubmit"
    >
      <div class="input-group">
        <div class="url-input-container">
          <input
              :value="url"
              @input="handleUrlInput"
              @keydown="handleKeydown"
              type="text"
              placeholder="GitHub repository URL or user/repo (e.g., yamadashy/repomix)"
              class="repository-input"
              :class="{ 'invalid': url && !isValidUrl }"
              aria-label="GitHub repository URL"
          />
          <button
              type="submit"
              class="pack-button"
              :disabled="!isValidUrl || loading"
              aria-label="Pack repository"
          >
            {{ loading ? 'Processing...' : 'Pack' }}
            <svg v-if="!loading"
                 class="pack-button-icon"
                 width="20"
                 height="20"
                 viewBox="96.259 93.171 300 300"
            >
              <g transform="matrix(1.160932, 0, 0, 1.160932, 97.635941, 94.725143)">
                <path
                    fill="currentColor"
                    d="M 128.03 -1.486 L 21.879 65.349 L 21.848 190.25 L 127.979 256.927 L 234.2 190.27 L 234.197 65.463 L 128.03 -1.486 Z M 208.832 70.323 L 127.984 121.129 L 47.173 70.323 L 128.144 19.57 L 208.832 70.323 Z M 39.669 86.367 L 119.188 136.415 L 119.255 230.529 L 39.637 180.386 L 39.669 86.367 Z M 136.896 230.506 L 136.887 136.575 L 216.469 86.192 L 216.417 180.46 L 136.896 230.506 Z M 136.622 230.849"
                />
              </g>
            </svg>
          </button>
        </div>

        <div v-if="url && !isValidUrl" class="url-warning">
          <AlertTriangle class="warning-icon" size="16" />
          <span>Please enter a valid GitHub repository URL (e.g., yamadashy/repomix)</span>
        </div>
      </div>

      <div class="options-container">
        <div class="left-column">
          <div class="option-section">
            <p class="option-label">Output Format</p>
            <div class="format-buttons">
              <button
                  class="format-button"
                  :class="{ active: format === 'xml' }"
                  @click="handleFormatChange('xml')"
                  type="button"
              >
                XML
              </button>
              <button
                  class="format-button"
                  :class="{ active: format === 'markdown' }"
                  @click="handleFormatChange('markdown')"
                  type="button"
              >
                Markdown
              </button>
              <button
                  class="format-button"
                  :class="{ active: format === 'plain' }"
                  @click="handleFormatChange('plain')"
                  type="button"
              >
                Plain
              </button>
            </div>
          </div>

          <div class="option-section">
            <p class="option-label">Include Patterns  (using <a href="https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax" target="_blank" rel="noopener noreferrer">glob patterns</a>)</p>
            <input
                v-model="includePatterns"
                @input="handleIncludePatternsUpdate($event.target.value)"
                type="text"
                class="repository-input"
                placeholder="Comma-separated patterns to include. e.g., src/**/*.ts"
                aria-label="Include patterns"
            />
          </div>

          <div class="option-section">
            <p class="option-label">Ignore Patterns</p>
            <input
                v-model="ignorePatterns"
                @input="handleIgnorePatternsUpdate($event.target.value)"
                type="text"
                class="repository-input"
                placeholder="Comma-separated patterns to ignore. e.g., **/*.test.ts,README.md"
                aria-label="Ignore patterns"
            />
          </div>
        </div>

        <div class="right-column">
          <div class="option-section">
            <p class="option-label">Output Options</p>
            <div class="checkbox-group">
              <label class="checkbox-label">
                <input
                    v-model="fileSummary"
                    @change="handleFileSummaryToggle($event.target.checked)"
                    type="checkbox"
                    class="checkbox-input"
                />
                <span>Include File Summary</span>
              </label>
              <label class="checkbox-label">
                <input
                    v-model="directoryStructure"
                    @change="handleDirectoryStructureToggle($event.target.checked)"
                    type="checkbox"
                    class="checkbox-input"
                />
                <span>Include Directory Structure</span>
              </label>
              <label class="checkbox-label">
                <input
                    v-model="removeComments"
                    @change="handleRemoveCommentsToggle($event.target.checked)"
                    type="checkbox"
                    class="checkbox-input"
                />
                <span>Remove Comments</span>
              </label>
              <label class="checkbox-label">
                <input
                    v-model="removeEmptyLines"
                    @change="handleRemoveEmptyLinesToggle($event.target.checked)"
                    type="checkbox"
                    class="checkbox-input"
                />
                <span>Remove Empty Lines</span>
              </label>
              <label class="checkbox-label">
                <input
                    v-model="showLineNumbers"
                    @change="handleShowLineNumbersToggle($event.target.checked)"
                    type="checkbox"
                    class="checkbox-input"
                />
                <span>Show Line Numbers</span>
              </label>
            </div>
          </div>
        </div>
      </div>

      <div v-if="hasExecuted">
        <ResultViewer
            :result="result"
            :loading="loading"
            :error="error"
        />
      </div>
    </form>
  </div>
</template>

<style scoped>
.container {
  padding: 0 20px;
  margin: 0 auto;
  max-width: 960px;
}

.try-it-container {
  background: var(--vp-c-bg-soft);
  border: 1px solid var(--vp-c-border);
  border-radius: 12px;
  padding: 24px;
}

.url-input-container {
  display: flex;
  gap: 12px;
}

.repository-input {
  flex: 1;
  padding: 12px 16px;
  font-size: 16px;
  border: 1px solid var(--vp-c-border);
  border-radius: 8px;
  background: var(--vp-c-bg);
  color: var(--vp-c-text-1);
  transition: border-color 0.2s;
}

.repository-input:focus {
  outline: none;
  border-color: var(--vp-c-brand-1);
}

.repository-input.invalid {
  border-color: var(--vp-c-danger-1);
}

.url-warning {
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 6px;
  color: var(--vp-c-warning-1);
  font-size: 14px;
}

.warning-icon {
  flex-shrink: 0;
  color: var(--vp-c-warning-1);
}

.pack-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 12px 24px;
  font-size: 16px;
  font-weight: 500;
  background: var(--vp-c-brand-1);
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.pack-button:hover:not(:disabled) {
  background: var(--vp-c-brand-2);
}

.pack-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.pack-button-icon {
  font-size: 20px;
  line-height: 1;
}

.input-group {
  margin-bottom: 24px;
}

.options-container {
  display: grid;
  grid-template-columns: 60% 40%;
  gap: 24px;
  margin-bottom: 24px;
}

.left-column,
.right-column {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.option-section {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.option-section input {
  padding: 8px 12px;
  font-size: 16px;
  border: 1px solid var(--vp-c-border);
  border-radius: 8px;
  background: var(--vp-c-bg);
  color: var(--vp-c-text-1);
  transition: border-color 0.2s;
}

.option-label {
  font-size: 14px;
  font-weight: 500;
  margin: 0;
  color: var(--vp-c-text-2);
}

.option-label a {
  color: var(--vp-c-brand-1);
}

.option-label a:hover {
  text-decoration: underline;
}

.format-buttons {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
}

.format-button {
  padding: 8px 16px;
  font-size: 14px;
  border: 1px solid var(--vp-c-border);
  border-radius: 6px;
  background: var(--vp-c-bg);
  color: var(--vp-c-text-1);
  cursor: pointer;
  transition: all 0.2s ease;
}

.format-button:hover {
  border-color: var(--vp-c-brand-1);
}

.format-button.active {
  background: var(--vp-c-brand-1);
  border-color: var(--vp-c-brand-1);
  color: white;
}

.checkbox-group {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.checkbox-label {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  font-size: 14px;
  color: var(--vp-c-text-1);
}

.checkbox-input {
  width: 16px;
  height: 16px;
  accent-color: var(--vp-c-brand-1);
}

@media (max-width: 640px) {
  .url-input-container {
    flex-direction: column;
  }

  .options-container {
    grid-template-columns: 1fr;
    gap: 24px;
  }

  .left-column,
  .right-column {
    gap: 24px;
  }
}
</style>
</file>

<file path="website/client/src/en/guide/development/index.md">
# Contributing to Repomix

## Quick Start

```bash
git clone https://github.com/yamadashy/repomix.git
cd repomix
npm install
```

## Development Commands

```bash
# Run CLI
npm run cli-run

# Run tests
npm run test
npm run test-coverage

# Lint code
npm run lint
```

## Code Style

- Use [Biome](https://biomejs.dev/) for linting and formatting
- Dependency injection for testability
- Keep files under 250 lines
- Add tests for new features

## Pull Request Guidelines

1. Run all tests
2. Pass linting checks
3. Update documentation
4. Follow existing code style

## Need Help?

- [Open an issue](https://github.com/yamadashy/repomix/issues)
- [Join Discord](https://discord.gg/wNYzTwZFku)
</file>

<file path="website/client/src/en/guide/development/setup.md">
# Development Setup

## Prerequisites

- Node.js ≥ 18.0.0
- Git
- npm

## Local Development

```bash
# Clone repository
git clone https://github.com/yamadashy/repomix.git
cd repomix

# Install dependencies
npm install

# Run CLI
npm run cli-run
```

## Docker Development

```bash
# Build image
docker build -t repomix .

# Run container
docker run -v ./:/app -it --rm repomix
```

## Project Structure

```
src/
├── cli/          # CLI implementation
├── config/       # Configuration handling
├── core/         # Core functionality
└── shared/       # Shared utilities
```

## Testing

```bash
# Run tests
npm run test

# Test coverage
npm run test-coverage

# Linting
npm run lint-biome
npm run lint-ts
npm run lint-secretlint
```

## Release Process

1. Update version
```bash
npm version patch  # or minor/major
```

2. Run tests and build
```bash
npm run test-coverage
npm run build
```

3. Publish
```bash
npm publish
```
</file>

<file path="website/client/src/en/guide/tips/best-practices.md">
# AI-Assisted Development Best Practices: From My Experience

While I haven't successfully completed a large-scale project using AI yet, I'd like to share what I've learned so far from my experience working with AI in development.

## Basic Development Approach

When working with AI, attempting to implement all features at once can lead to unexpected issues and project stagnation. That's why it's more effective to start with core functionality and build each feature one at a time, ensuring solid implementation before moving forward.

### The Power of Existing Code

This approach is effective because implementing core functionality allows you to materialize your ideal design and coding style through actual code. The most effective way to communicate your project vision is through code that reflects your standards and preferences.

By starting with core features and ensuring each component works properly before moving on, the entire project maintains consistency, making it easier for AI to generate more appropriate code.

## The Modular Approach

Breaking code into smaller modules is crucial. In my experience, keeping files around 250 lines of code makes it easier to give clear instructions to AI and makes the trial-and-error process more efficient. While token count would be a more accurate metric, line count is more practical for human developers to work with, so we use that as a guideline.

This modularization isn't just about separating frontend, backend, and database components - it's about breaking down functionality at a much finer level. For example, within a single feature, you might separate validation, error handling, and other specific functionalities into distinct modules. Of course, high-level separation is also important, and implementing this modular approach gradually helps maintain clear instructions and enables AI to generate more appropriate code. This approach is effective not just for AI but for human developers as well.

## Ensuring Quality Through Testing

I consider testing to be crucial in AI-assisted development. Tests serve not only as quality assurance measures but also as documentation that clearly demonstrates code intentions. When asking AI to implement new features, existing test code effectively acts as a specification document.

Tests are also an excellent tool for validating the correctness of AI-generated code. For instance, when having AI implement new functionality for a module, writing test cases beforehand allows you to objectively evaluate whether the generated code behaves as expected. This aligns well with Test-Driven Development (TDD) principles and is particularly effective when collaborating with AI.

## Balancing Planning and Implementation

Before implementing large-scale features, I recommend first discussing the plan with AI. Organizing requirements and considering architecture leads to smoother implementation. A good practice is to compile requirements first, then move to a separate chat session for implementation work.

It's essential to have human review of AI output and make adjustments as needed. While the quality of AI-generated code is generally moderate, it still accelerates development compared to writing everything from scratch.

## Conclusion

By following these practices, you can leverage AI's strengths while building a consistent, high-quality codebase. Even as your project grows in size, each component remains well-defined and manageable.
</file>

<file path="website/client/src/en/guide/command-line-options.md">
# Command Line Options

## Basic Options

```bash
repomix [directory]  # Process specific directory (default: ".")
```

## Output Options

| Option | Description | Default |
|--------|-------------|---------|
| `-o, --output <file>` | Output file name | `repomix-output.txt` |
| `--style <type>` | Output style (`plain`, `xml`, `markdown`) | `plain` |
| `--output-show-line-numbers` | Add line numbers | `false` |
| `--copy` | Copy to clipboard | `false` |
| `--no-file-summary` | Disable file summary | `true` |
| `--no-directory-structure` | Disable directory structure | `true` |
| `--remove-comments` | Remove comments | `false` |
| `--remove-empty-lines` | Remove empty lines | `false` |

## Filter Options

| Option | Description |
|--------|-------------|
| `--include <patterns>` | Include patterns (comma-separated) |
| `-i, --ignore <patterns>` | Ignore patterns (comma-separated) |

## Remote Repository

| Option | Description |
|--------|-------------|
| `--remote <url>` | Process remote repository |
| `--remote-branch <name>` | Specify branch/tag/commit |

## Configuration

| Option | Description |
|--------|-------------|
| `-c, --config <path>` | Custom config file path |
| `--init` | Create config file |
| `--global` | Use global config |

## Security

| Option | Description | Default |
|--------|-------------|---------|
| `--no-security-check` | Disable security check | `true` |

## Other Options

| Option | Description |
|--------|-------------|
| `-v, --version` | Show version |
| `--verbose` | Enable verbose logging |
| `--top-files-len <number>` | Number of top files to show | `5` |

## Examples

```bash
# Basic usage
repomix

# Custom output
repomix -o output.xml --style xml

# Process specific files
repomix --include "src/**/*.ts" --ignore "**/*.test.ts"

# Remote repository
repomix --remote user/repo --remote-branch main
```
</file>

<file path="website/client/src/en/guide/comment-removal.md">
# Comment Removal

Repomix can automatically remove comments from your codebase when generating the output file. This can help reduce noise and focus on the actual code.

## Usage

To enable comment removal, set the `removeComments` option to `true` in your `repomix.config.json`:

```json
{
  "output": {
    "removeComments": true
  }
}
```

## Supported Languages

Repomix supports comment removal for a wide range of programming languages, including:

- JavaScript/TypeScript (`//`, `/* */`)
- Python (`#`, `"""`, `'''`)
- Java (`//`, `/* */`)
- C/C++ (`//`, `/* */`)
- HTML (`<!-- -->`)
- CSS (`/* */`)
- And many more...

## Example

Given the following JavaScript code:

```javascript
// This is a single-line comment
function test() {
  /* This is a
     multi-line comment */
  return true;
}
```

With comment removal enabled, the output will be:

```javascript
function test() {
  return true;
}
```

## Notes

- Comment removal is performed before other processing steps, such as line number addition.
- Some comments, such as JSDoc comments, may be preserved depending on the language and context.
</file>

<file path="website/client/src/en/guide/configuration.md">
# Configuration

## Quick Start

Create configuration file:
```bash
repomix --init
```

## Configuration File

`repomix.config.json`:
```json
{
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "headerText": "Custom header text",
    "instructionFilePath": "repomix-instruction.md",
    "fileSummary": true,
    "directoryStructure": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "includeEmptyDirectories": false
  },
  "include": ["**/*"],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": ["tmp/", "*.log"]
  },
  "security": {
    "enableSecurityCheck": true
  }
}
```

## Global Configuration

Create global configuration:
```bash
repomix --init --global
```

Location:
- Windows: `%LOCALAPPDATA%\Repomix\repomix.config.json`
- macOS/Linux: `~/.config/repomix/repomix.config.json`

## Ignore Patterns

Priority order:
1. CLI options (`--ignore`)
2. .repomixignore
3. .gitignore
4. Default patterns

`.repomixignore` example:
```text
# Cache directories
.cache/
tmp/

# Build outputs
dist/
build/

# Logs
*.log
```

## Default Ignore Patterns

Common patterns included by default:
```text
node_modules/**
.git/**
coverage/**
dist/**
```

Full list: [defaultIgnore.ts](https://github.com/yamadashy/repomix/blob/main/src/config/defaultIgnore.ts)
</file>

<file path="website/client/src/en/guide/custom-instructions.md">
# Custom Instructions

Repomix allows you to provide custom instructions that will be included in the output file. This can be useful for adding context or specific guidelines for AI systems processing the repository.

## Usage

To include a custom instruction, create a markdown file (e.g., `repomix-instruction.md`) in the root of your repository. Then, specify the path to this file in your `repomix.config.json`:

```json
{
  "output": {
    "instructionFilePath": "repomix-instruction.md"
  }
}
```

The content of this file will be included in the output under the "Instruction" section.

## Example

```markdown
# Repository Instructions

This repository contains the source code for the Repomix tool. Please follow these guidelines when analyzing the code:

1. Focus on the core functionality in the `src/core` directory.
2. Pay special attention to the security checks in `src/core/security`.
3. Ignore any files in the `tests` directory.
```

This will result in the following section in the output:

```xml
<instruction>
# Repository Instructions

This repository contains the source code for the Repomix tool. Please follow these guidelines when analyzing the code:

1. Focus on the core functionality in the `src/core` directory.
2. Pay special attention to the security checks in `src/core/security`.
3. Ignore any files in the `tests` directory.
</instruction>
```
</file>

<file path="website/client/src/en/guide/index.md">
# Getting Started with Repomix

Repomix is a tool that packs your entire repository into a single, AI-friendly file. It's designed to help you feed your codebase to Large Language Models (LLMs) like Claude, ChatGPT, and Gemini.

## Quick Start

Run this command in your project directory:

```bash
npx repomix
```

That's it! You'll find a `repomix-output.txt` file containing your entire repository in an AI-friendly format.

You can then send this file to an AI assistant with a prompt like:

```
This file contains all the files in the repository combined into one.
I want to refactor the code, so please review it first.
```

The AI will analyze your entire codebase and provide comprehensive insights:

![Repomix File Usage 1](/images/docs/repomix-file-usage-1.png)

When discussing specific changes, the AI can help generate code. With features like Claude's Artifacts, you can even receive multiple interdependent files:

![Repomix File Usage 2](/images/docs/repomix-file-usage-2.png)

Happy coding! 🚀

## Core Features

- **AI-Optimized Output**: Formats your codebase for easy AI processing
- **Token Counting**: Tracks token usage for LLM context limits
- **Git-Aware**: Respects your .gitignore files
- **Security-Focused**: Detects sensitive information
- **Multiple Output Formats**: Choose between plain text, XML, or Markdown

## What's Next?

- [Installation Guide](installation.md): Different ways to install Repomix
- [Usage Guide](usage.md): Learn about basic and advanced features
- [Configuration](configuration.md): Customize Repomix for your needs
- [Security Features](security.md): Learn about security checks

## Community

Join our [Discord community](https://discord.gg/wNYzTwZFku) for:
- Getting help with Repomix
- Sharing your experiences
- Suggesting new features
- Connecting with other users

## Support

Found a bug or need help?
- [Open an issue on GitHub](https://github.com/yamadashy/repomix/issues)
- Join our Discord server
- Check the [documentation](https://repomix.com)
</file>

<file path="website/client/src/en/guide/installation.md">
# Installation

## Using npx (No Installation Required)

```bash
npx repomix
```

## Global Installation

### npm
```bash
npm install -g repomix
```

### Yarn
```bash
yarn global add repomix
```

### Homebrew (macOS/Linux)
```bash
brew install repomix
```

## Docker Installation

Pull and run the Docker image:

```bash
# Current directory
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix

# Specific directory
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory

# Remote repository
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote yamadashy/repomix
```

## System Requirements

- Node.js: ≥ 18.0.0
- Git: Required for remote repository processing

## Verification

After installation, verify that Repomix is working:

```bash
repomix --version
repomix --help
```
</file>

<file path="website/client/src/en/guide/output.md">
# Output Formats

Repomix supports three output formats:
- Plain Text (default)
- XML
- Markdown

## Plain Text Format

```bash
repomix --style plain
```

Output structure:
```text
This file is a merged representation of the entire codebase...

================
File Summary
================
(Metadata and AI instructions)

================
Directory Structure
================
src/
  index.ts
  utils/
    helper.ts

================
Files
================

================
File: src/index.ts
================
// File contents here
```

## XML Format

```bash
repomix --style xml
```

XML format is optimized for AI processing:

```xml
This file is a merged representation of the entire codebase...

<file_summary>
(Metadata and AI instructions)
</file_summary>

<directory_structure>
src/
  index.ts
  utils/
    helper.ts
</directory_structure>

<files>
<file path="src/index.ts">
// File contents here
</file>
</files>
```

::: tip Why XML?
XML tags help AI models like Claude parse content more accurately. [Claude Documentation](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/use-xml-tags) recommends using XML tags for structured prompts.
:::

## Markdown Format

```bash
repomix --style markdown
```

Markdown provides readable formatting:

```markdown
This file is a merged representation of the entire codebase...

# File Summary
(Metadata and AI instructions)

# Directory Structure
```
src/
index.ts
utils/
helper.ts
```

# Files

## File: src/index.ts
```typescript
// File contents here
```
```

## Usage with AI Models

Each format works well with AI models, but consider:
- Use XML for Claude (best parsing accuracy)
- Use Markdown for general readability
- Use Plain Text for simplicity and universal compatibility

## Customization

Set default format in `repomix.config.json`:
```json
{
  "output": {
    "style": "xml",
    "filePath": "output.xml"
  }
}
```
</file>

<file path="website/client/src/en/guide/prompt-examples.md">
# Prompt Examples

## Code Review

### Architecture Review
```
Analyze this codebase's architecture:
1. Evaluate the overall structure and patterns
2. Identify potential architectural issues
3. Suggest improvements for scalability
4. Note areas that follow best practices

Focus on maintainability and modularity.
```

### Security Review
```
Perform a security review of this codebase:
1. Identify potential security vulnerabilities
2. Check for common security anti-patterns
3. Review error handling and input validation
4. Assess dependency security

Provide specific examples and remediation steps.
```

### Performance Review
```
Review the codebase for performance:
1. Identify performance bottlenecks
2. Check resource utilization
3. Review algorithmic efficiency
4. Assess caching strategies

Include specific optimization recommendations.
```

## Documentation Generation

### API Documentation
```
Generate comprehensive API documentation:
1. List and describe all public endpoints
2. Document request/response formats
3. Include usage examples
4. Note any limitations or constraints
```

### Developer Guide
```
Create a developer guide covering:
1. Setup instructions
2. Project structure overview
3. Development workflow
4. Testing approach
5. Common troubleshooting steps
```

### Architecture Documentation
```
Document the system architecture:
1. High-level overview
2. Component interactions
3. Data flow diagrams
4. Design decisions and rationale
5. System constraints and limitations
```

## Analysis and Improvement

### Dependency Analysis
```
Analyze the project dependencies:
1. Identify outdated packages
2. Check for security vulnerabilities
3. Suggest alternative packages
4. Review dependency usage patterns

Include specific upgrade recommendations.
```

### Test Coverage
```
Review the test coverage:
1. Identify untested components
2. Suggest additional test cases
3. Review test quality
4. Recommend testing strategies
```

### Code Quality
```
Assess code quality and suggest improvements:
1. Review naming conventions
2. Check code organization
3. Evaluate error handling
4. Review commenting practices

Provide specific examples of good and problematic patterns.
```

## Tips for Better Results

1. **Be Specific**: Include clear objectives and evaluation criteria
2. **Set Context**: Specify your role and expertise level needed
3. **Request Format**: Define how you want the response structured
4. **Prioritize**: Indicate which aspects are most important

## Model-Specific Notes

### Claude
- Use XML output format
- Place important instructions at the end
- Specify response structure

### ChatGPT
- Use Markdown format
- Break large codebases into sections
- Include system role prompts

### Gemini
- Works with all formats
- Focus on specific areas per request
- Use step-by-step analysis
</file>

<file path="website/client/src/en/guide/remote-repository-processing.md">
# Remote Repository Processing

## Basic Usage

Process public repositories:
```bash
# Using full URL
repomix --remote https://github.com/user/repo

# Using GitHub shorthand
repomix --remote user/repo
```

## Branch and Commit Selection

```bash
# Specific branch
repomix --remote user/repo --remote-branch main

# Tag
repomix --remote user/repo --remote-branch v1.0.0

# Commit hash
repomix --remote user/repo --remote-branch 935b695
```

## Requirements

- Git must be installed
- Internet connection
- Read access to repository

## Output Control

```bash
# Custom output location
repomix --remote user/repo -o custom-output.xml

# With XML format
repomix --remote user/repo --style xml

# Remove comments
repomix --remote user/repo --remove-comments
```

## Docker Usage

```bash
# Process and output to current directory
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo

# Output to specific directory
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo
```

## Common Issues

### Access Issues
- Ensure repository is public
- Check Git installation
- Verify internet connection

### Large Repositories
- Use `--include` to select specific paths
- Enable `--remove-comments`
- Process branches separately
</file>

<file path="website/client/src/en/guide/security.md">
# Security

## Security Check Feature

Repomix uses [Secretlint](https://github.com/secretlint/secretlint) to detect sensitive information in your files:
- API keys
- Access tokens
- Credentials
- Private keys
- Environment variables

## Configuration

Security checks are enabled by default.

Disable via CLI:
```bash
repomix --no-security-check
```

Or in `repomix.config.json`:
```json
{
  "security": {
    "enableSecurityCheck": false
  }
}
```

## Security Measures

1. **Binary File Exclusion**: Binary files are not included in output
2. **Git-Aware**: Respects `.gitignore` patterns
3. **Automated Detection**: Scans for common security issues:
    - AWS credentials
    - Database connection strings
    - Authentication tokens
    - Private keys

## When Security Check Finds Issues

Example output:
```bash
🔍 Security Check:
──────────────────
2 suspicious file(s) detected and excluded:
1. config/credentials.json
   - Found AWS access key
2. .env.local
   - Found database password
```

## Best Practices

1. Always review output before sharing
2. Use `.repomixignore` for sensitive paths
3. Keep security checks enabled
4. Remove sensitive files from repository

## Reporting Security Issues

Found a security vulnerability? Please:
1. Do not open a public issue
2. Email: koukun0120@gmail.com
3. Or use [GitHub Security Advisories](https://github.com/yamadashy/repomix/security/advisories/new)
</file>

<file path="website/client/src/en/guide/usage.md">
# Basic Usage

## Quick Start

Pack your entire repository:
```bash
repomix
```

## Common Use Cases

### Pack Specific Directories
```bash
repomix path/to/directory
```

### Include Specific Files
Use [glob patterns](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax):
```bash
repomix --include "src/**/*.ts,**/*.md"
```

### Exclude Files
```bash
repomix --ignore "**/*.log,tmp/"
```

### Remote Repositories
```bash
# Using GitHub URL
repomix --remote https://github.com/user/repo

# Using shorthand
repomix --remote user/repo

# Specific branch/tag/commit
repomix --remote user/repo --remote-branch main
repomix --remote user/repo --remote-branch 935b695
```

## Output Formats

### Plain Text (Default)
```bash
repomix --style plain
```

### XML
```bash
repomix --style xml
```

### Markdown
```bash
repomix --style markdown
```

## Additional Options

### Remove Comments
```bash
repomix --remove-comments
```

### Show Line Numbers
```bash
repomix --output-show-line-numbers
```

### Copy to Clipboard
```bash
repomix --copy
```

### Disable Security Check
```bash
repomix --no-security-check
```

## Configuration

Initialize configuration file:
```bash
repomix --init
```

See [Configuration Guide](/guide/configuration) for detailed options.
</file>

<file path="website/client/src/en/index.md">
---
layout: home
title: Repomix
titleTemplate: Pack your codebase into AI-friendly formats
aside: false
editLink: false

features:
  - icon: 🤖
    title: AI-Optimized
    details: Formats your codebase in a way that's easy for AI to understand and process.

  - icon: ⚙️
    title: Git-Aware
    details: Automatically respects your .gitignore files.

  - icon: 🛡️
    title: Security-Focused
    details: Incorporates Secretlint for robust security checks to detect and prevent inclusion of sensitive information.

  - icon: 📊
    title: Token Counting
    details: Provides token counts for each file and the entire repository, useful for LLM context limits.

---

<div class="cli-section">


## Quick Start

Once you've generated a packed file (`repomix-output.txt`) using Repomix, you can send it to an AI assistant with a prompt like:

```
This file contains all the files in the repository combined into one.
I want to refactor the code, so please review it first.
```

The AI will analyze your entire codebase and provide comprehensive insights:

![Repomix File Usage 1](/images/docs/repomix-file-usage-1.png)

When discussing specific changes, the AI can help generate code. With features like Claude's Artifacts, you can even receive multiple interdependent files:

![Repomix File Usage 2](/images/docs/repomix-file-usage-2.png)

Happy coding! 🚀



## Power User Guide

For advanced users who need more control, Repomix offers extensive customization options through its CLI interface.

### Quick Start

You can try Repomix instantly in your project directory without installation:

```bash
npx repomix
```

Or install globally for repeated use:

```bash
# Install using npm
npm install -g repomix

# Alternatively using yarn
yarn global add repomix

# Alternatively using Homebrew (macOS/Linux)
brew install repomix

# Then run in any project directory
repomix
```

That's it! Repomix will generate a `repomix-output.txt` file in your current directory, containing your entire repository in an AI-friendly format.



### Usage

To pack your entire repository:

```bash
repomix
```

To pack a specific directory:

```bash
repomix path/to/directory
```

To pack specific files or directories using [glob patterns](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax):

```bash
repomix --include "src/**/*.ts,**/*.md"
```

To exclude specific files or directories:

```bash
repomix --ignore "**/*.log,tmp/"
```

To pack a remote repository:
```bash
repomix --remote https://github.com/yamadashy/repomix

# You can also use GitHub shorthand:
repomix --remote yamadashy/repomix

# You can specify the branch name, tag, or commit hash:
repomix --remote https://github.com/yamadashy/repomix --remote-branch main

# Or use a specific commit hash:
repomix --remote https://github.com/yamadashy/repomix --remote-branch 935b695
```

To initialize a new configuration file (`repomix.config.json`):

```bash
repomix --init
```

Once you have generated the packed file, you can use it with Generative AI tools like Claude, ChatGPT, and Gemini.

#### Docker Usage

You can also run Repomix using Docker 🐳  
This is useful if you want to run Repomix in an isolated environment or prefer using containers.

Basic usage (current directory):

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

To pack a specific directory:
```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory
```

Process a remote repository and output to a `output` directory:

```bash
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote https://github.com/yamadashy/repomix
```

### Output Formats

Choose your preferred output format:

```bash
# XML format (default)
repomix --style xml

# Markdown format
repomix --style markdown

# Plain text format
repomix --style plain
```

### Customization

Create a `repomix.config.json` for persistent settings:

```json
{
  "output": {
    "style": "markdown",
    "filePath": "custom-output.md",
    "removeComments": true,
    "showLineNumbers": true,
    "topFilesLength": 10
  },
  "ignore": {
    "customPatterns": ["*.test.ts", "docs/**"]
  }
}
```

### More Examples
::: tip
💡 Check out our [GitHub repository](https://github.com/yamadashy/repomix) for complete documentation and more examples!
:::

</div>
</file>

<file path="website/client/src/es/guide/development/index.md">
# Contribuir a Repomix

## Inicio rápido

```bash
git clone https://github.com/yamadashy/repomix.git
cd repomix
npm install
```

## Comandos de desarrollo

```bash
# Ejecutar CLI
npm run cli-run

# Ejecutar pruebas
npm run test
npm run test-coverage

# Linting de código
npm run lint
```

## Estilo de código

- Usa [Biome](https://biomejs.dev/) para linting y formateo
- Inyección de dependencias para la testabilidad
- Mantén los archivos por debajo de las 250 líneas
- Agrega pruebas para las nuevas funciones

## Pautas para Pull Requests

1. Ejecuta todas las pruebas
2. Pasa las comprobaciones de linting
3. Actualiza la documentación
4. Sigue el estilo de código existente

## ¿Necesitas ayuda?

- [Abre un issue](https://github.com/yamadashy/repomix/issues)
- [Únete a Discord](https://discord.gg/wNYzTwZFku)
</file>

<file path="website/client/src/es/guide/development/setup.md">
# Configuración del entorno de desarrollo

## Requisitos previos

- Node.js ≥ 18.0.0
- Git
- npm

## Desarrollo local

```bash
# Clonar el repositorio
git clone https://github.com/yamadashy/repomix.git
cd repomix

# Instalar dependencias
npm install

# Ejecutar CLI
npm run cli-run
```

## Desarrollo con Docker

```bash
# Construir la imagen
docker build -t repomix .

# Ejecutar el contenedor
docker run -v ./:/app -it --rm repomix
```

## Estructura del proyecto

```
src/
├── cli/          # Implementación de la CLI
├── config/       # Manejo de la configuración
├── core/         # Funcionalidad principal
└── shared/       # Utilidades compartidas
```

## Pruebas

```bash
# Ejecutar pruebas
npm run test

# Cobertura de pruebas
npm run test-coverage

# Linting
npm run lint-biome
npm run lint-ts
npm run lint-secretlint
```

## Proceso de lanzamiento

1. Actualizar la versión
```bash
npm version patch  # o minor/major
```

2. Ejecutar pruebas y construir
```bash
npm run test-coverage
npm run build
```

3. Publicar
```bash
npm publish
</file>

<file path="website/client/src/es/guide/tips/best-practices.md">
# Mejores prácticas para el desarrollo asistido por IA: Desde mi experiencia

Aunque todavía no he completado con éxito un proyecto a gran escala utilizando IA, me gustaría compartir lo que he aprendido hasta ahora de mi experiencia trabajando con IA en el desarrollo.

## Enfoque de desarrollo básico

Cuando se trabaja con IA, intentar implementar todas las funciones a la vez puede llevar a problemas inesperados y al estancamiento del proyecto. Por eso es más efectivo comenzar con la funcionalidad principal y construir cada función una por una, asegurando una implementación sólida antes de seguir adelante.

### El poder del código existente

Este enfoque es efectivo porque implementar la funcionalidad principal te permite materializar tu diseño ideal y estilo de codificación a través de código real. La forma más efectiva de comunicar la visión de tu proyecto es a través de código que refleje tus estándares y preferencias.

Al comenzar con las funciones principales y asegurar que cada componente funcione correctamente antes de continuar, todo el proyecto mantiene la consistencia, lo que facilita que la IA genere código más apropiado.

## El enfoque modular

Dividir el código en módulos más pequeños es crucial. En mi experiencia, mantener los archivos alrededor de 250 líneas de código facilita dar instrucciones claras a la IA y hace que el proceso de prueba y error sea más eficiente. Si bien el recuento de tokens sería una métrica más precisa, el recuento de líneas es más práctico para los desarrolladores humanos, por lo que lo usamos como una guía.

Esta modularización no se trata solo de separar los componentes de frontend, backend y base de datos, sino de desglosar la funcionalidad a un nivel mucho más fino. Por ejemplo, dentro de una sola función, podrías separar la validación, el manejo de errores y otras funcionalidades específicas en módulos distintos. Por supuesto, la separación de alto nivel también es importante, e implementar este enfoque modular gradualmente ayuda a mantener instrucciones claras y permite que la IA genere código más apropiado. Este enfoque es efectivo no solo para la IA sino también para los desarrolladores humanos.

## Asegurar la calidad a través de las pruebas

Considero que las pruebas son cruciales en el desarrollo asistido por IA. Las pruebas no solo sirven como medidas de garantía de calidad, sino también como documentación que demuestra claramente las intenciones del código. Al pedirle a la IA que implemente nuevas funciones, el código de prueba existente actúa efectivamente como un documento de especificación.

Las pruebas también son una excelente herramienta para validar la corrección del código generado por IA. Por ejemplo, al hacer que la IA implemente una nueva funcionalidad para un módulo, escribir casos de prueba de antemano te permite evaluar objetivamente si el código generado se comporta como se espera. Esto se alinea bien con los principios de desarrollo basado en pruebas (TDD) y es particularmente efectivo cuando se colabora con la IA.

## Equilibrar la planificación y la implementación

Antes de implementar funciones a gran escala, recomiendo discutir primero el plan con la IA. Organizar los requisitos y considerar la arquitectura conduce a una implementación más fluida. Una buena práctica es compilar primero los requisitos y luego pasar a una sesión de chat separada para el trabajo de implementación.

Es esencial que un humano revise el resultado de la IA y haga los ajustes necesarios. Si bien la calidad del código generado por IA es generalmente moderada, aún acelera el desarrollo en comparación con escribir todo desde cero.

## Conclusión

Siguiendo estas prácticas, puedes aprovechar las fortalezas de la IA mientras construyes una base de código consistente y de alta calidad. Incluso a medida que tu proyecto crece en tamaño, cada componente permanece bien definido y manejable.
</file>

<file path="website/client/src/es/guide/command-line-options.md">
# Opciones de línea de comandos

## Opciones básicas

```bash
repomix [directorio]  # Procesa un directorio específico (por defecto: ".")
```

## Opciones de salida

| Opción | Descripción | Predeterminado |
|--------|-------------|---------|
| `-o, --output <archivo>` | Nombre del archivo de salida | `repomix-output.txt` |
| `--style <tipo>` | Estilo de salida (`plain`, `xml`, `markdown`) | `plain` |
| `--output-show-line-numbers` | Añadir números de línea | `false` |
| `--copy` | Copiar al portapapeles | `false` |
| `--no-file-summary` | Desactivar el resumen de archivos | `true` |
| `--no-directory-structure` | Desactivar la estructura de directorios | `true` |
| `--remove-comments` | Eliminar comentarios | `false` |
| `--remove-empty-lines` | Eliminar líneas vacías | `false` |

## Opciones de filtrado

| Opción | Descripción |
|--------|-------------|
| `--include <patrones>` | Patrones a incluir (separados por comas) |
| `-i, --ignore <patrones>` | Patrones a ignorar (separados por comas) |

## Repositorio remoto

| Opción | Descripción |
|--------|-------------|
| `--remote <url>` | Procesar un repositorio remoto |
| `--remote-branch <nombre>` | Especificar rama/etiqueta/commit |

## Configuración

| Opción | Descripción |
|--------|-------------|
| `-c, --config <ruta>` | Ruta al archivo de configuración personalizado |
| `--init` | Crear archivo de configuración |
| `--global` | Usar configuración global |

## Seguridad

| Opción | Descripción | Predeterminado |
|--------|-------------|---------|
| `--no-security-check` | Desactivar la comprobación de seguridad | `true` |

## Otras opciones

| Opción | Descripción |
|--------|-------------|
| `-v, --version` | Mostrar versión |
| `--verbose` | Habilitar el registro detallado |
| `--top-files-len <número>` | Número de archivos principales a mostrar | `5` |

## Ejemplos

```bash
# Uso básico
repomix

# Salida personalizada
repomix -o salida.xml --style xml

# Procesar archivos específicos
repomix --include "src/**/*.ts" --ignore "**/*.test.ts"

# Repositorio remoto
repomix --remote usuario/repositorio --remote-branch main
</file>

<file path="website/client/src/es/guide/comment-removal.md">
# Eliminación de comentarios

Repomix puede eliminar automáticamente los comentarios de tu código al generar el archivo de salida. Esto puede ayudar a reducir el ruido y centrarse en el código real.

## Uso

Para habilitar la eliminación de comentarios, establece la opción `removeComments` a `true` en tu archivo `repomix.config.json`:

```json
{
  "output": {
    "removeComments": true
  }
}
```

## Lenguajes soportados

Repomix soporta la eliminación de comentarios para una amplia gama de lenguajes de programación, incluyendo:

- JavaScript/TypeScript (`//`, `/* */`)
- Python (`#`, `"""`, `'''`)
- Java (`//`, `/* */`)
- C/C++ (`//`, `/* */`)
- HTML (`<!-- -->`)
- CSS (`/* */`)
- Y muchos más...

## Ejemplo

Dado el siguiente código JavaScript:

```javascript
// Este es un comentario de una sola línea
function test() {
  /* Este es un
     comentario multilínea */
  return true;
}
```

Con la eliminación de comentarios habilitada, la salida será:

```javascript
function test() {
  return true;
}
```

## Notas

- La eliminación de comentarios se realiza antes que otros pasos de procesamiento, como la adición de números de línea.
- Algunos comentarios, como los comentarios JSDoc, pueden conservarse dependiendo del lenguaje y el contexto.
</file>

<file path="website/client/src/es/guide/configuration.md">
# Configuración

## Inicio rápido

Crear archivo de configuración:
```bash
repomix --init
```

## Archivo de configuración

`repomix.config.json`:
```json
{
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "headerText": "Texto de encabezado personalizado",
    "instructionFilePath": "repomix-instruction.md",
    "fileSummary": true,
    "directoryStructure": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "includeEmptyDirectories": false
  },
  "include": ["**/*"],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": ["tmp/", "*.log"]
  },
  "security": {
    "enableSecurityCheck": true
  }
}
```

## Configuración global

Crear configuración global:
```bash
repomix --init --global
```

Ubicación:
- Windows: `%LOCALAPPDATA%\Repomix\repomix.config.json`
- macOS/Linux: `~/.config/repomix/repomix.config.json`

## Patrones de ignorar

Orden de prioridad:
1. Opciones de CLI (`--ignore`)
2. .repomixignore
3. .gitignore
4. Patrones predeterminados

Ejemplo de `.repomixignore`:
```text
# Directorios de caché
.cache/
tmp/

# Salidas de compilación
dist/
build/

# Registros
*.log
```

## Patrones de ignorar predeterminados

Patrones comunes incluidos por defecto:
```text
node_modules/**
.git/**
coverage/**
dist/**
```

Lista completa: [defaultIgnore.ts](https://github.com/yamadashy/repomix/blob/main/src/config/defaultIgnore.ts)
</file>

<file path="website/client/src/es/guide/custom-instructions.md">
# Instrucciones personalizadas

Repomix te permite proporcionar instrucciones personalizadas que se incluirán en el archivo de salida. Esto puede ser útil para agregar contexto o pautas específicas para los sistemas de IA que procesan el repositorio.

## Uso

Para incluir una instrucción personalizada, crea un archivo markdown (por ejemplo, `repomix-instruction.md`) en la raíz de tu repositorio. Luego, especifica la ruta a este archivo en tu `repomix.config.json`:

```json
{
  "output": {
    "instructionFilePath": "repomix-instruction.md"
  }
}
```

El contenido de este archivo se incluirá en la salida bajo la sección "Instruction".

## Ejemplo

```markdown
# Instrucciones del repositorio

Este repositorio contiene el código fuente de la herramienta Repomix. Por favor, sigue estas pautas al analizar el código:

1. Concéntrate en la funcionalidad principal en el directorio `src/core`.
2. Presta especial atención a las comprobaciones de seguridad en `src/core/security`.
3. Ignora cualquier archivo en el directorio `tests`.
```

Esto resultará en la siguiente sección en la salida:

```xml
<instruction>
# Instrucciones del repositorio

Este repositorio contiene el código fuente de la herramienta Repomix. Por favor, sigue estas pautas al analizar el código:

1. Concéntrate en la funcionalidad principal en el directorio `src/core`.
2. Presta especial atención a las comprobaciones de seguridad en `src/core/security`.
3. Ignora cualquier archivo en el directorio `tests`.
</instruction>
</file>

<file path="website/client/src/es/guide/index.md">
# Primeros pasos con Repomix

Repomix es una herramienta que empaqueta todo tu repositorio en un solo archivo amigable para la IA. Está diseñado para ayudarte a alimentar tu código a modelos de lenguaje grandes (LLMs) como Claude, ChatGPT y Gemini.

## Inicio rápido

Ejecuta este comando en el directorio de tu proyecto:

```bash
npx repomix
```

¡Eso es todo! Encontrarás un archivo `repomix-output.txt` que contiene todo tu repositorio en un formato amigable para la IA.

Luego puedes enviar este archivo a un asistente de IA con un prompt como:

```
Este archivo contiene todos los archivos del repositorio combinados en uno.
Quiero refactorizar el código, así que por favor revísalo primero.
```

La IA analizará todo tu código y proporcionará información completa:

![Repomix File Usage 1](/images/docs/repomix-file-usage-1.png)

Al discutir cambios específicos, la IA puede ayudar a generar código. Con funciones como los Artefactos de Claude, incluso puedes recibir múltiples archivos interdependientes:

![Repomix File Usage 2](/images/docs/repomix-file-usage-2.png)

¡Feliz programación! 🚀

## Características principales

- **Salida optimizada para IA**: Formatea tu código para un fácil procesamiento por parte de la IA
- **Conteo de tokens**: Realiza un seguimiento del uso de tokens para los límites de contexto de los LLM
- **Compatible con Git**: Respeta tus archivos .gitignore
- **Enfocado en la seguridad**: Detecta información sensible
- **Múltiples formatos de salida**: Elige entre texto plano, XML o Markdown

## ¿Qué sigue?

- [Guía de instalación](installation.md): Diferentes formas de instalar Repomix
- [Guía de uso](usage.md): Aprende sobre las funciones básicas y avanzadas
- [Configuración](configuration.md): Personaliza Repomix para tus necesidades
- [Funciones de seguridad](security.md): Aprende sobre las comprobaciones de seguridad

## Comunidad

Únete a nuestra [comunidad de Discord](https://discord.gg/wNYzTwZFku) para:
- Obtener ayuda con Repomix
- Compartir tus experiencias
- Sugerir nuevas funciones
- Conectarte con otros usuarios

## Soporte

¿Encontraste un error o necesitas ayuda?
- [Abre un issue en GitHub](https://github.com/yamadashy/repomix/issues)
- Únete a nuestro servidor de Discord
- Consulta la [documentación](https://repomix.com)
</file>

<file path="website/client/src/es/guide/installation.md">
# Instalación

## Usando npx (no requiere instalación)

```bash
npx repomix
```

## Instalación global

### npm
```bash
npm install -g repomix
```

### Yarn
```bash
yarn global add repomix
```

### Homebrew (macOS/Linux)
```bash
brew install repomix
```

## Instalación con Docker

Extrae y ejecuta la imagen de Docker:

```bash
# Directorio actual
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix

# Directorio específico
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix ruta/al/directorio

# Repositorio remoto
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote yamadashy/repomix
```

## Requisitos del sistema

- Node.js: ≥ 18.0.0
- Git: Requerido para el procesamiento de repositorios remotos

## Verificación

Después de la instalación, verifica que Repomix esté funcionando:

```bash
repomix --version
repomix --help
</file>

<file path="website/client/src/es/guide/output.md">
# Formatos de salida

Repomix admite tres formatos de salida:
- Texto sin formato (predeterminado)
- XML
- Markdown

## Formato de texto sin formato

```bash
repomix --style plain
```

Estructura de salida:
```text
Este archivo es una representación fusionada de toda la base de código...

================
Resumen de archivos
================
(Metadatos e instrucciones de IA)

================
Estructura de directorios
================
src/
  index.ts
  utils/
    helper.ts

================
Archivos
================

================
Archivo: src/index.ts
================
// Contenido del archivo aquí
```

## Formato XML

```bash
repomix --style xml
```

El formato XML está optimizado para el procesamiento de IA:

```xml
Este archivo es una representación fusionada de toda la base de código...

<file_summary>
(Metadatos e instrucciones de IA)
</file_summary>

<directory_structure>
src/
  index.ts
  utils/
    helper.ts
</directory_structure>

<files>
<file path="src/index.ts">
// Contenido del archivo aquí
</file>
</files>
```

::: tip ¿Por qué XML?
Las etiquetas XML ayudan a los modelos de IA como Claude a analizar el contenido con mayor precisión. La [documentación de Claude](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/use-xml-tags) recomienda usar etiquetas XML para prompts estructurados.
:::

## Formato Markdown

```bash
repomix --style markdown
```

Markdown proporciona un formato legible:

```markdown
Este archivo es una representación fusionada de toda la base de código...

# Resumen de archivos
(Metadatos e instrucciones de IA)

# Estructura de directorios
```
src/
index.ts
utils/
helper.ts
```

# Archivos

## Archivo: src/index.ts
```typescript
// Contenido del archivo aquí
```
```

## Uso con modelos de IA

Cada formato funciona bien con modelos de IA, pero considera:
- Usar XML para Claude (mejor precisión de análisis)
- Usar Markdown para legibilidad general
- Usar texto sin formato para simplicidad y compatibilidad universal

## Personalización

Establece el formato predeterminado en `repomix.config.json`:
```json
{
  "output": {
    "style": "xml",
    "filePath": "output.xml"
  }
}
</file>

<file path="website/client/src/es/guide/prompt-examples.md">
# Ejemplos de prompts

## Revisión de código

### Revisión de arquitectura
```
Analiza la arquitectura de esta base de código:
1. Evalúa la estructura general y los patrones
2. Identifica posibles problemas de arquitectura
3. Sugiere mejoras para la escalabilidad
4. Señala las áreas que siguen las mejores prácticas

Concéntrate en la mantenibilidad y la modularidad.
```

### Revisión de seguridad
```
Realiza una revisión de seguridad de esta base de código:
1. Identifica posibles vulnerabilidades de seguridad
2. Busca antipatrones de seguridad comunes
3. Revisa el manejo de errores y la validación de entradas
4. Evalúa la seguridad de las dependencias

Proporciona ejemplos específicos y pasos de remediación.
```

### Revisión de rendimiento
```
Revisa el rendimiento de la base de código:
1. Identifica cuellos de botella de rendimiento
2. Comprueba la utilización de recursos
3. Revisa la eficiencia algorítmica
4. Evalúa las estrategias de almacenamiento en caché

Incluye recomendaciones de optimización específicas.
```

## Generación de documentación

### Documentación de API
```
Genera documentación de API completa:
1. Enumera y describe todos los endpoints públicos
2. Documenta los formatos de solicitud/respuesta
3. Incluye ejemplos de uso
4. Señala cualquier limitación o restricción
```

### Guía para desarrolladores
```
Crea una guía para desarrolladores que cubra:
1. Instrucciones de configuración
2. Descripción general de la estructura del proyecto
3. Flujo de trabajo de desarrollo
4. Enfoque de pruebas
5. Pasos comunes para la solución de problemas
```

### Documentación de arquitectura
```
Documenta la arquitectura del sistema:
1. Descripción general de alto nivel
2. Interacciones entre componentes
3. Diagramas de flujo de datos
4. Decisiones de diseño y justificación
5. Restricciones y limitaciones del sistema
```

## Análisis y mejora

### Análisis de dependencias
```
Analiza las dependencias del proyecto:
1. Identifica paquetes obsoletos
2. Busca vulnerabilidades de seguridad
3. Sugiere paquetes alternativos
4. Revisa los patrones de uso de dependencias

Incluye recomendaciones de actualización específicas.
```

### Cobertura de pruebas
```
Revisa la cobertura de pruebas:
1. Identifica componentes no probados
2. Sugiere casos de prueba adicionales
3. Revisa la calidad de las pruebas
4. Recomienda estrategias de prueba
```

### Calidad del código
```
Evalúa la calidad del código y sugiere mejoras:
1. Revisa las convenciones de nomenclatura
2. Comprueba la organización del código
3. Evalúa el manejo de errores
4. Revisa las prácticas de comentarios

Proporciona ejemplos específicos de patrones buenos y problemáticos.
```

## Consejos para obtener mejores resultados

1. **Sé específico**: Incluye objetivos claros y criterios de evaluación
2. **Establece el contexto**: Especifica tu rol y el nivel de experiencia necesario
3. **Solicita un formato**: Define cómo quieres que se estructure la respuesta
4. **Prioriza**: Indica qué aspectos son más importantes

## Notas específicas del modelo

### Claude
- Usa el formato de salida XML
- Coloca las instrucciones importantes al final
- Especifica la estructura de la respuesta

### ChatGPT
- Usa el formato Markdown
- Divide las bases de código grandes en secciones
- Incluye prompts de rol del sistema

### Gemini
- Funciona con todos los formatos
- Concéntrate en áreas específicas por solicitud
- Usa un análisis paso a paso
</file>

<file path="website/client/src/es/guide/remote-repository-processing.md">
# Procesamiento de repositorios remotos

## Uso básico

Procesar repositorios públicos:
```bash
# Usando URL completo
repomix --remote https://github.com/usuario/repositorio

# Usando la abreviatura de GitHub
repomix --remote usuario/repositorio
```

## Selección de rama y commit

```bash
# Rama específica
repomix --remote usuario/repositorio --remote-branch main

# Etiqueta
repomix --remote usuario/repositorio --remote-branch v1.0.0

# Hash de commit
repomix --remote usuario/repositorio --remote-branch 935b695
```

## Requisitos

- Git debe estar instalado
- Conexión a Internet
- Acceso de lectura al repositorio

## Control de salida

```bash
# Ubicación de salida personalizada
repomix --remote usuario/repositorio -o salida-personalizada.xml

# Con formato XML
repomix --remote usuario/repositorio --style xml

# Eliminar comentarios
repomix --remote usuario/repositorio --remove-comments
```

## Uso de Docker

```bash
# Procesar y generar la salida en el directorio actual
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote usuario/repositorio

# Generar la salida en un directorio específico
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote usuario/repositorio
```

## Problemas comunes

### Problemas de acceso
- Asegúrate de que el repositorio sea público
- Comprueba la instalación de Git
- Verifica la conexión a Internet

### Repositorios grandes
- Usa `--include` para seleccionar rutas específicas
- Habilita `--remove-comments`
- Procesa las ramas por separado
</file>

<file path="website/client/src/es/guide/security.md">
# Seguridad

## Función de verificación de seguridad

Repomix utiliza [Secretlint](https://github.com/secretlint/secretlint) para detectar información sensible en tus archivos:
- Claves de API
- Tokens de acceso
- Credenciales
- Claves privadas
- Variables de entorno

## Configuración

Las verificaciones de seguridad están habilitadas de forma predeterminada.

Deshabilitar a través de CLI:
```bash
repomix --no-security-check
```

O en `repomix.config.json`:
```json
{
  "security": {
    "enableSecurityCheck": false
  }
}
```

## Medidas de seguridad

1. **Exclusión de archivos binarios**: Los archivos binarios no se incluyen en la salida
2. **Compatible con Git**: Respeta los patrones de `.gitignore`
3. **Detección automatizada**: Busca problemas de seguridad comunes:
    - Credenciales de AWS
    - Cadenas de conexión de bases de datos
    - Tokens de autenticación
    - Claves privadas

## Cuando la verificación de seguridad encuentra problemas

Ejemplo de salida:
```bash
🔍 Verificación de seguridad:
──────────────────
2 archivo(s) sospechoso(s) detectado(s) y excluido(s):
1. config/credentials.json
   - Se encontró la clave de acceso de AWS
2. .env.local
   - Se encontró la contraseña de la base de datos
```

## Mejores prácticas

1. Siempre revisa la salida antes de compartirla
2. Usa `.repomixignore` para rutas sensibles
3. Mantén las verificaciones de seguridad habilitadas
4. Elimina los archivos sensibles del repositorio

## Reportar problemas de seguridad

¿Encontraste una vulnerabilidad de seguridad? Por favor:
1. No abras un issue público
2. Envía un correo electrónico a: koukun0120@gmail.com
3. O usa [GitHub Security Advisories](https://github.com/yamadashy/repomix/security/advisories/new)
</file>

<file path="website/client/src/es/guide/usage.md">
# Uso básico

## Inicio rápido

Empaqueta todo tu repositorio:
```bash
repomix
```

## Casos de uso comunes

### Empaquetar directorios específicos
```bash
repomix ruta/al/directorio
```

### Incluir archivos específicos
Usa [patrones glob](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax):
```bash
repomix --include "src/**/*.ts,**/*.md"
```

### Excluir archivos
```bash
repomix --ignore "**/*.log,tmp/"
```

### Repositorios remotos
```bash
# Usando la URL de GitHub
repomix --remote https://github.com/usuario/repositorio

# Usando la abreviatura
repomix --remote usuario/repositorio

# Rama/etiqueta/commit específico
repomix --remote usuario/repositorio --remote-branch main
repomix --remote usuario/repositorio --remote-branch 935b695
```

## Formatos de salida

### Texto sin formato (predeterminado)
```bash
repomix --style plain
```

### XML
```bash
repomix --style xml
```

### Markdown
```bash
repomix --style markdown
```

## Opciones adicionales

### Eliminar comentarios
```bash
repomix --remove-comments
```

### Mostrar números de línea
```bash
repomix --output-show-line-numbers
```

### Copiar al portapapeles
```bash
repomix --copy
```

### Deshabilitar la verificación de seguridad
```bash
repomix --no-security-check
```

## Configuración

Inicializar el archivo de configuración:
```bash
repomix --init
```

Consulta la [Guía de configuración](/guide/configuration) para obtener opciones detalladas.
</file>

<file path="website/client/src/es/index.md">
---
layout: home
title: Repomix
titleTemplate: Empaqueta tu código en formatos amigables para la IA
aside: false
editLink: false

features:
  - icon: 🤖
    title: Optimizado para IA
    details: Formatea tu código de una manera que sea fácil de entender y procesar para la IA.

  - icon: ⚙️
    title: Compatible con Git
    details: Respeta automáticamente tus archivos .gitignore.

  - icon: 🛡️
    title: Enfocado en la seguridad
    details: Incorpora Secretlint para realizar robustas comprobaciones de seguridad que detectan y previenen la inclusión de información sensible.

  - icon: 📊
    title: Conteo de tokens
    details: Proporciona recuentos de tokens para cada archivo y para todo el repositorio, útil para los límites de contexto de los LLM.

---

<div class="cli-section">

## Inicio rápido

Una vez que hayas generado un archivo empaquetado (`repomix-output.txt`) usando Repomix, puedes enviarlo a un asistente de IA con un prompt como:

```
Este archivo contiene todos los archivos del repositorio combinados en uno.
Quiero refactorizar el código, así que por favor revísalo primero.
```

La IA analizará todo tu código y proporcionará información completa:

![Repomix File Usage 1](/images/docs/repomix-file-usage-1.png)

Al discutir cambios específicos, la IA puede ayudar a generar código. Con funciones como los Artefactos de Claude, incluso puedes recibir múltiples archivos interdependientes:

![Repomix File Usage 2](/images/docs/repomix-file-usage-2.png)

¡Feliz programación! 🚀



## Guía para usuarios avanzados

Para los usuarios avanzados que necesitan más control, Repomix ofrece amplias opciones de personalización a través de su interfaz de línea de comandos.

### Inicio rápido

Puedes probar Repomix instantáneamente en el directorio de tu proyecto sin necesidad de instalación:

```bash
npx repomix
```

O instalarlo globalmente para uso repetido:

```bash
# Instalar usando npm
npm install -g repomix

# Alternativamente usando yarn
yarn global add repomix

# Alternativamente usando Homebrew (macOS/Linux)
brew install repomix

# Luego ejecutar en cualquier directorio de proyecto
repomix
```

¡Eso es todo! Repomix generará un archivo `repomix-output.txt` en tu directorio actual, que contendrá todo tu repositorio en un formato amigable para la IA.



### Uso

Para empaquetar todo tu repositorio:

```bash
repomix
```

Para empaquetar un directorio específico:

```bash
repomix ruta/al/directorio
```

Para empaquetar archivos o directorios específicos usando [patrones glob](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax):

```bash
repomix --include "src/**/*.ts,**/*.md"
```

Para excluir archivos o directorios específicos:

```bash
repomix --ignore "**/*.log,tmp/"
```

Para empaquetar un repositorio remoto:
```bash
repomix --remote https://github.com/yamadashy/repomix

# También puedes usar la abreviatura de GitHub:
repomix --remote yamadashy/repomix

# Puedes especificar el nombre de la rama, la etiqueta o el hash de confirmación:
repomix --remote https://github.com/yamadashy/repomix --remote-branch main

# O usar un hash de confirmación específico:
repomix --remote https://github.com/yamadashy/repomix --remote-branch 935b695
```

Para inicializar un nuevo archivo de configuración (`repomix.config.json`):

```bash
repomix --init
```

Una vez que hayas generado el archivo empaquetado, puedes usarlo con herramientas de IA generativa como Claude, ChatGPT y Gemini.

#### Uso de Docker

También puedes ejecutar Repomix usando Docker 🐳  
Esto es útil si deseas ejecutar Repomix en un entorno aislado o prefieres usar contenedores.

Uso básico (directorio actual):

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

Para empaquetar un directorio específico:
```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix ruta/al/directorio
```

Procesar un repositorio remoto y generar la salida en un directorio `output`:

```bash
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote https://github.com/yamadashy/repomix
```

### Formatos de salida

Elige tu formato de salida preferido:

```bash
# Formato XML (predeterminado)
repomix --style xml

# Formato Markdown
repomix --style markdown

# Formato de texto plano
repomix --style plain
```

### Personalización

Crea un archivo `repomix.config.json` para configuraciones persistentes:

```json
{
  "output": {
    "style": "markdown",
    "filePath": "custom-output.md",
    "removeComments": true,
    "showLineNumbers": true,
    "topFilesLength": 10
  },
  "ignore": {
    "customPatterns": ["*.test.ts", "docs/**"]
  }
}
```

### Más ejemplos
::: tip
💡 ¡Consulta nuestro [repositorio de GitHub](https://github.com/yamadashy/repomix) para obtener la documentación completa y más ejemplos!
:::

</div>
</file>

<file path="website/client/src/ja/guide/development/index.md">
# Repomixへの貢献

## クイックスタート

```bash
git clone https://github.com/yamadashy/repomix.git
cd repomix
npm install
```

## 開発コマンド

```bash
# CLIを実行
npm run cli-run

# テストを実行
npm run test
npm run test-coverage

# コードのリント
npm run lint
```

## コーディングスタイル

- [Biome](https://biomejs.dev/)を使用してリントとフォーマットを行う
- テスト可能性のために依存性注入を使用
- ファイルは250行以下に保つ
- 新機能には必ずテストを追加

## プルリクエストのガイドライン

1. 全てのテストを実行
2. リントチェックをパス
3. ドキュメントを更新
4. 既存のコードスタイルに従う

## サポートが必要な場合

- [イシューを作成](https://github.com/yamadashy/repomix/issues)
- [Discordに参加](https://discord.gg/wNYzTwZFku)
</file>

<file path="website/client/src/ja/guide/development/setup.md">
# 開発環境のセットアップ

## 前提条件

- Node.js ≥ 18.0.0
- Git
- npm

## ローカル開発

```bash
# リポジトリのクローン
git clone https://github.com/yamadashy/repomix.git
cd repomix

# 依存関係のインストール
npm install

# CLIの実行
npm run cli-run
```

## Docker開発

```bash
# イメージのビルド
docker build -t repomix .

# コンテナの実行
docker run -v ./:/app -it --rm repomix
```

## プロジェクト構造

```
src/
├── cli/          # CLI実装
├── config/       # 設定の処理
├── core/         # コア機能
└── shared/       # 共有ユーティリティ
```

## テスト

```bash
# テストの実行
npm run test

# テストカバレッジ
npm run test-coverage

# リント
npm run lint-biome
npm run lint-ts
npm run lint-secretlint
```

## リリースプロセス

1. バージョンの更新
```bash
npm version patch  # または minor/major
```

2. テストとビルドの実行
```bash
npm run test-coverage
npm run build
```

3. 公開
```bash
npm publish
```
</file>

<file path="website/client/src/ja/guide/tips/best-practices.md">
# AI支援開発のベストプラクティス：私の経験から

私はまだAIを使用した大規模な開発を経験したわけではありませんが、これまでの経験から学んだことを共有したいと思います。

## 開発の基本アプローチ

AIと共に開発を進める際、一度にすべての機能を実装しようとすると、予期せぬ問題が発生し、プロジェクト全体が行き詰まってしまうことがあります。そのため、コア機能から始めて一つ一つの機能を確実に作り上げていく方法が効果的です。

### 既存コードの重要性

この方法が効果的な理由は、コア機能の実装を通じて、あなたの理想とする設計やコーディングスタイルをコードとして具体化できる点にあります。
プロジェクトのビジョンを最も効果的に伝えるのは、あなたの基準や好みを反映したコードそのものなのです。

コア機能から始めつつ、一つ一つの機能を確実に動く状態にしてから次の機能に進むことで、プロジェクト全体が一貫性を持ち、AIがより適切なコードを生成しやすくなります。

## モジュール分割のアプローチ

また、コードは小さなモジュールに分割することが重要です。私の経験では、行数を250行程度に抑えることで結果的にAIに明確な指示を与えやすくなり、試行錯誤のプロセスも効率的になります。実際にはトークン数のほうが指標として正しいのですが、人間に判断しやすいのは行数なので、ここでは行数としています。

これはフロントエンド、バックエンド、データベースなどの大きな単位の話ではなく、もっと小さな単位、例えば一つの機能の中でもバリデーションやエラーハンドリングなど、個別の機能をモジュールとして分割することが重要です。

もちろん大きな単位で分けるのも重要で、段階的にモジュールを分割しておくことで、指示も明確になり、AIがより適切なコードを生成しやすくなります。AIに限らず人間にも効果的なアプローチですね。


## テストを通じた品質の確保
私はテストも重要だと考えています。
テストは単なる品質保証の手段としてだけでなく、コードの意図を明確に示すドキュメントとしても機能します。AIに新しい機能の実装を依頼する際、既存のテストコードは実装すべき機能の仕様書として働きます。

また、AIが生成したコードの正しさを判断する際、テストは非常に効果的なツールとなります。例えば、あるモジュールの新しい機能をAIに実装してもらう場合、テストケースを先に書いておくことで、生成されたコードが期待通りの動作をするかを客観的に評価できます。これはテスト駆動開発（TDD）の考え方とも親和性が高く、AIとの協業において特に有効です。


## 計画と実装のバランス

大規模な機能を実装する前には、まずAIと計画について話し合うことをお勧めします。要件を整理し、アーキテクチャを検討することで、後の実装がスムーズになります。要件をまずまとめて、別のチャットに移動して実装を進めるのも良いでしょう。
また、AIの出力は必ず人間がレビューし、必要に応じて調整を加えることが重要です。AIの出力の品質は一般的に中程度ですが、それでも一からコードを書くよりも開発速度は向上します。



## まとめ

この方法を実践することで、AIの強みを活かしながら、一貫性のある高品質なコードベースを構築できます。プロジェクトの規模が大きくなっても、各部分が明確に定義され、管理しやすい状態を維持できるでしょう。
</file>

<file path="website/client/src/ja/guide/command-line-options.md">
# コマンドラインオプション

## 基本オプション

```bash
repomix [directory]  # 特定のディレクトリを処理（指定しない場合はカレントディレクトリ）
```

## 出力オプション

| オプション | 説明 | デフォルト |
|--------|-------------|---------|
| `-o, --output <file>` | 出力ファイル名 | `repomix-output.txt` |
| `--style <type>` | 出力形式（`plain`, `xml`, `markdown`） | `plain` |
| `--output-show-line-numbers` | 行番号を追加 | `false` |
| `--copy` | クリップボードにコピー | `false` |
| `--no-file-summary` | ファイルサマリーを無効化 | `true` |
| `--no-directory-structure` | ディレクトリ構造を無効化 | `true` |
| `--remove-comments` | コメントを削除 | `false` |
| `--remove-empty-lines` | 空行を削除 | `false` |

## フィルターオプション

| オプション | 説明 |
|--------|-------------|
| `--include <patterns>` | 指定したファイルまたはディレクトリをパッケージング対象に含める |
| `-i, --ignore <patterns>` | 指定したファイルまたはディレクトリをパッケージング対象から除外する |

## リモートリポジトリ

| オプション | 説明 |
|--------|-------------|
| `--remote <url>` | 指定したリモートリポジトリをパッケージングする |
| `--remote-branch <name>` | リモートリポジトリの特定のブランチ、タグ、またはコミットハッシュを指定する |

## 設定

| オプション | 説明 |
|--------|-------------|
| `-c, --config <path>` | カスタム設定ファイルのパス |
| `--init` | 設定ファイルを作成 |
| `--global` | グローバル設定を使用 |

## セキュリティ

| オプション | 説明 | デフォルト |
|--------|-------------|---------|
| `--no-security-check` | セキュリティチェックを無効化 | `true` |

## その他のオプション

| オプション | 説明 |
|--------|-------------|
| `-v, --version` | バージョンを表示 |
| `--verbose` | 詳細なログ出力を有効化 |
| `--top-files-len <number>` | 上位何件のファイルを詳細出力するかを指定する | `5` |

## 使用例

```bash
# 基本的な使用方法
repomix

# 出力ファイル名とフォーマットを指定
repomix -o output.xml --style xml

# 特定のファイルを含める、または除外する
repomix --include "src/**/*.ts" --ignore "**/*.test.ts"

# リモートリポジトリをパッケージングする
repomix --remote user/repo --remote-branch main
```
</file>

<file path="website/client/src/ja/guide/comment-removal.md">
# ソースコード中のコメント削除

Repomixは、パッケージング時に、ソースコード中のコメントを自動的に削除する機能を提供します。これにより、出力ファイルからノイズを減らし、実際のコードに焦点を当てることができます。

## 使用方法

コメントの削除を有効にするには、`repomix.config.json`で`removeComments`オプションを`true`に設定します。

```json
{
  "output": {
    "removeComments": true
  }
}
```

## サポートされている言語

Repomixは以下を含む多くのプログラミング言語のコメント削除をサポートしています。

- JavaScript/TypeScript (`//`, `/* */`)
- Python (`#`, `"""`, `'''`)
- Java (`//`, `/* */`)
- C/C++ (`//`, `/* */`)
- HTML (`<!-- -->`)
- CSS (`/* */`)
- その他多数の言語

## 使用例と出力例

以下のようなJavaScriptコードがある場合

```javascript
// これは単一行コメントです
function test() {
  /* これは
     複数行コメントです */
  return true;
}
```

コメント削除を有効にすると、出力は以下のようになります。

```javascript
function test() {
  return true;
}
```

## 制限事項

- コメントの削除は、行番号の追加など、他の処理よりも先に行われます。
- JSDocコメントなど、一部のコメントは削除されない場合があります。
</file>

<file path="website/client/src/ja/guide/configuration.md">
# 設定

## クイックスタート

設定ファイルの作成。

```bash
repomix --init
```

## 設定ファイル (`repomix.config.json`)

```json
{
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "headerText": "カスタムヘッダーテキスト",
    "instructionFilePath": "repomix-instruction.md",
    "fileSummary": true,
    "directoryStructure": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "includeEmptyDirectories": false
  },
  "include": ["**/*"],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": ["tmp/", "*.log"]
  },
  "security": {
    "enableSecurityCheck": true
  }
}
```

## グローバル設定ファイル

グローバル設定ファイルの作成。

```bash
repomix --init --global
```

設定ファイルの場所。

- Windows: `%LOCALAPPDATA%\\Repomix\\repomix.config.json`
- macOS/Linux: `~/.config/repomix/repomix.config.json`

## 除外パターン (`.repomixignore`)

優先順位

1. CLIオプション（`--ignore`）
2. .repomixignore
3. .gitignore
4. デフォルトパターン

`.repomixignore`の例

```text
# キャッシュディレクトリ
.cache/
tmp/

# ビルド出力
dist/
build/

# ログ
*.log
```

## デフォルトの除外パターン

デフォルトで含まれる一般的なパターン

```text
node_modules/**
.git/**
coverage/**
dist/**
```

完全なリスト：[defaultIgnore.ts](https://github.com/yamadashy/repomix/blob/main/src/config/defaultIgnore.ts)
</file>

<file path="website/client/src/ja/guide/custom-instructions.md">
# カスタム指示

Repomixでは、出力ファイルに含めるカスタム指示（独自の指示）を提供することができます。これは、AIシステムにプロジェクトの特定のコンテキストや要件を理解させるのに役立ちます。

## 使用方法

カスタム指示を含めるには、リポジトリのルートにマークダウンファイル（例：`repomix-instruction.md`）を作成し、`repomix.config.json`でそのパスを指定します。

```json
{
  "output": {
    "instructionFilePath": "repomix-instruction.md"
  }
}
```

このファイルの内容は出力の「Instruction」セクションに含まれます。

## 使用例

```markdown
# コーディングガイドライン

- Airbnb JavaScript スタイルガイドに従う
- 適切な場合は、ファイルを小さな単位に分割する
- 自明でないロジックにはコメントを追加。すべてのテキストは英語で記述
- すべての新機能には対応するユニットテストを作成する

# 生成内容について

- 特に指定がない限り、すべての内容を省略せずに含める
- 大規模なコードベースを処理しながら、出力の品質を維持する
```

これは出力ファイルで以下のように表示されます。

```xml
<instruction>
# コーディングガイドライン

- Airbnb JavaScript スタイルガイドに従う
- 適切な場合は、ファイルを小さな単位に分割する
- 自明でないロジックにはコメントを追加。すべてのテキストは英語で記述
- すべての新機能には対応するユニットテストを作成する

# 生成内容について

- 特に指定がない限り、すべての内容を省略せずに含める
- 大規模なコードベースを処理しながら、出力の品質を維持する
</instruction>
```

## 注意点

- カスタム指示は出力ファイルの`Instruction`セクションに含まれます。
- カスタム指示は適切な長さに保つことを推奨します。過度に長い指示は逆効果になる場合があります。
- プロジェクト固有のガイドラインや要件に焦点を当てることで、AIがプロジェクトのコンテキストを理解しやすくなり、より効果的な結果が得られます。
</file>

<file path="website/client/src/ja/guide/index.md">
# Repomixとは

Repomixは、リポジトリ全体をAIフレンドリーな単一ファイルにパッケージングするツールです。Claude、ChatGPT、Geminiなどの大規模言語モデル（LLM）にコードベースを提供するために設計されています。

## クイックスタート

プロジェクトディレクトリで以下のコマンドを実行するだけです。

```bash
npx repomix
```

これだけで、`repomix-output.txt`ファイルにAIが理解しやすい形式でリポジトリ全体がまとめられます。

このファイルを以下のようなプロンプトとともにAIアシスタントに送信できます。

```
このファイルはリポジトリ内のすべてのファイルを1つにまとめたものです。
コードのリファクタリングを行いたいので、まずはコードレビューをお願いします。
```

すると、AIはコードベース全体を分析し、包括的な洞察を提供してくれます。

![Repomixの使用例1](/images/docs/repomix-file-usage-1.png)

具体的な変更点を議論する際には、AIはコードの生成をサポートしてくれます。例えば、Claudeのアーティファクト機能などを使用すると、相互に依存する複数のファイルを一度に生成することも可能です。

![Repomixの使用例2](/images/docs/repomix-file-usage-2.png)

良いコーディング体験を！🚀

## 主な機能

- **AI最適化**: コードベースをAIが理解しやすい形式にフォーマット化
- **トークンカウント**: LLMのコンテキスト制限に対応するためのトークン数を計測
- **Git対応**: .gitignoreファイルを自動的に認識してパッケージング対象から除外
- **セキュリティ重視**: [Secretlint](https://github.com/secretlint/secretlint)を使用した機密情報の検出と保護
- **複数の出力形式**: プレーンテキスト、XML、Markdownの出力形式を選択可能

## 次のステップ

- [インストールガイド](installation.md): Repomixをインストールするにはこちら
- [使用方法](usage.md): 基本的な使い方から高度な使い方まで
- [設定](configuration.md): Repomixをカスタマイズするにはこちら
- [セキュリティ機能](security.md): セキュリティチェックの詳細はこちら

## コミュニティ

[Discordコミュニティ](https://discord.gg/wNYzTwZFku)に参加して、Repomixの使い方について質問したり、経験やノウハウを共有したり、新機能を提案したり、他のユーザーと交流しましょう。

## サポート

バグを見つけた場合や支援が必要な場合は、[GitHubでイシューを作成](https://github.com/yamadashy/repomix/issues)するか、Discordサーバーに参加してください。
</file>

<file path="website/client/src/ja/guide/installation.md">
# インストール

## npx を使用する方法 (インストール不要)

```bash
npx repomix
```

## グローバルインストール

### npm
```bash
npm install -g repomix
```

### Yarn
```bash
yarn global add repomix
```

### Homebrew（macOS/Linux）
```bash
brew install repomix
```

## Dockerを使用する方法

以下のコマンドで Docker イメージをプルして実行できます。

```bash
# カレントディレクトリを処理
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix

# 特定のディレクトリを処理
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory

# リモートリポジトリを処理
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote yamadashy/repomix
```

## システム要件

- Node.js: 18.0.0 以上
- Git: リモートリポジトリを処理する場合はインストールしてください

## インストールの確認

インストール後、以下のコマンドで Repomix が正常に動作することを確認できます。

```bash
repomix --version
repomix --help
```
</file>

<file path="website/client/src/ja/guide/output.md">
# 出力フォーマット

Repomixは3つの出力フォーマットをサポートしています。
- プレーンテキスト（デフォルト）
- XML
- Markdown

## プレーンテキストフォーマット

```bash
repomix --style plain
```

出力の構造
```text
このファイルは、コードベース全体を1つのドキュメントにまとめた表現です...

================
ファイルサマリー
================
（メタデータとAI向けの使用説明）

================
ディレクトリ構造
================
src/
  index.ts
  utils/
    helper.ts

================
ファイル
================

================
File: src/index.js
================
// ファイルの内容がここに表示されます

================
File: src/utils.js
================
// ファイルの内容がここに表示されます
```

## XMLフォーマット

```bash
repomix --style xml
```

XMLフォーマットはAI処理に最適化されています。

```xml
このファイルは、コードベース全体を1つのドキュメントにまとめた表現です...

<file_summary>
（メタデータとAI向けの使用説明）
</file_summary>

<directory_structure>
src/
  index.ts
  utils/
    helper.ts
</directory_structure>

<files>
<file path="src/index.js">
// ファイルの内容がここに表示されます
</file>
</files>

<instruction>
（output.instructionFilePathで指定されたカスタム指示）
</instruction>
```

::: tip なぜXML？
XMLタグはClaudeなどのAIモデルがコンテンツをより正確に解析するのに役立ちます。[Claude公式ドキュメント](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/use-xml-tags)では、構造化されたプロンプトにXMLタグを使用することを推奨しています。
:::

## Markdownフォーマット

```bash
repomix --style markdown
```

Markdownは読みやすいフォーマットを提供します。

```markdown
このファイルは、コードベース全体を1つのドキュメントにまとめた表現です...

# ファイルサマリー
（メタデータとAI向けの使用説明）

# ディレクトリ構造
```
src/
index.ts
utils/
helper.ts
```

# ファイル

## File: src/index.ts
```typescript
// ファイルの内容がここに表示されます
```
```

## AIモデルとの使用

各フォーマットはAIモデルで問題なく動作しますが、以下の点を考慮してください。
- XMLはClaude用に最適化（最も正確な解析）
- Markdownは一般的な読みやすさを重視
- プレーンテキストはシンプルさと互換性を重視

## カスタマイズ

`repomix.config.json`でデフォルトのフォーマットを設定
```json
{
  "output": {
    "style": "xml",
    "filePath": "output.xml"
  }
}
```
</file>

<file path="website/client/src/ja/guide/prompt-examples.md">
# プロンプト例

## コードレビュー

### アーキテクチャレビュー
```
このコードベースのアーキテクチャを分析してください。
1. 全体的な構造とパターンを評価
2. アーキテクチャ上の潜在的な問題点を特定
3. スケーラビリティ向上のための改善案を提案
4. ベストプラクティスに従っている部分を指摘

保守性とモジュール性に特に注目してください。
```

### セキュリティレビュー
```
このコードベースのセキュリティレビューを実施してください。
1. 潜在的なセキュリティ脆弱性の特定
2. 一般的なセキュリティアンチパターンのチェック
3. エラー処理と入力バリデーションの確認
4. 依存関係のセキュリティ評価

具体的な例と対策手順を含めてください。
```

### パフォーマンスレビュー
```
パフォーマンスの観点からコードベースをレビューしてください。
1. パフォーマンスのボトルネックを特定
2. リソース使用状況の確認
3. アルゴリズムの効率性の評価
4. キャッシュ戦略の評価

具体的な最適化の推奨事項を含めてください。
```

## ドキュメント生成

### API ドキュメント
```
包括的なAPIドキュメントを生成してください。
1. すべてのパブリックエンドポイントをリストアップし説明
2. リクエスト/レスポンスのフォーマットを文書化
3. 使用例を含める
4. 制限事項や制約を記載
```

### 開発者ガイド
```
以下の内容を含む開発者ガイドを作成してください。
1. セットアップ手順
2. プロジェクト構造の概要
3. 開発ワークフロー
4. テストアプローチ
5. 一般的なトラブルシューティング手順
```

### アーキテクチャドキュメント
```
システムアーキテクチャを文書化してください。
1. 高レベルの概要
2. コンポーネント間の相互作用
3. データフロー図
4. 設計上の決定と根拠
5. システムの制約と制限事項
```

## 分析と改善

### 依存関係の分析
```
プロジェクトの依存関係を分析してください。
1. 古くなったパッケージの特定
2. セキュリティ脆弱性のチェック
3. 代替パッケージの提案
4. 依存関係の使用パターンの確認

具体的なアップグレード推奨事項を含めてください。
```

### テストカバレッジ
```
テストカバレッジを確認してください。
1. テストされていないコンポーネントの特定
2. 追加のテストケースの提案
3. テストの品質の確認
4. テスト戦略の推奨

具体的な改善案を提供してください。
```

### コード品質
```
コード品質を評価し、改善点を提案してください。
1. 命名規則の確認
2. コード構成の確認
3. エラー処理の評価
4. コメントの実践の確認

良いパターンと問題のあるパターンの具体例を提供してください。
```

## より良い結果を得るためのヒント

1. **具体的に**: 明確な目標と評価基準を含める
2. **コンテキストを設定**: あなたの役割と必要な専門知識レベルを指定
3. **レスポンス形式**: 希望する回答の構造を指定
4. **優先順位**: どの側面が最も重要かを示す

## モデル別の注意点

### Claude
- XML出力形式を使用
- 重要な指示を最後に配置
- レスポンス構造を指定

### ChatGPT
- Markdown形式を使用
- 大規模なコードベースはセクションに分割
- システムロールプロンプトを含める

### Gemini
- すべての形式で動作
- 特定の領域に焦点を絞る
- ステップバイステップの分析を使用
</file>

<file path="website/client/src/ja/guide/remote-repository-processing.md">
# リモートリポジトリの処理

## 基本的な使用方法

パブリックリポジトリを処理
```bash
# 完全なURLを使用
repomix --remote https://github.com/user/repo

# GitHubのショートハンド形式を使用
repomix --remote user/repo
```

## ブランチとコミットの選択

```bash
# 特定のブランチ
repomix --remote user/repo --remote-branch main

# タグ
repomix --remote user/repo --remote-branch v1.0.0

# コミットハッシュ
repomix --remote user/repo --remote-branch 935b695
```

## 必要条件

- Gitがインストールされていること
- インターネット接続があること
- リポジトリへの読み取りアクセス権があること

## 出力の制御

```bash
# 出力先のカスタマイズ
repomix --remote user/repo -o custom-output.xml

# XML形式で出力
repomix --remote user/repo --style xml

# コメントを削除
repomix --remote user/repo --remove-comments
```

## Docker使用時

```bash
# カレントディレクトリに出力
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo

# 特定のディレクトリに出力
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo
```

## 一般的な問題

### アクセスの問題
- リポジトリがパブリックであることを確認
- Gitのインストールを確認
- インターネット接続を確認

### 大規模リポジトリの処理
- `--include`で特定のパスを選択
- `--remove-comments`を有効化
- ブランチごとに個別に処理
</file>

<file path="website/client/src/ja/guide/security.md">
# セキュリティ

## セキュリティチェック機能

Repomixは[Secretlint](https://github.com/secretlint/secretlint)を使用して、ファイル内の機密情報を検出します：
- APIキー
- アクセストークン
- 認証情報
- 秘密鍵
- 環境変数

## 設定

セキュリティチェックはデフォルトで有効になっています。

CLIで無効化する場合
```bash
repomix --no-security-check
```

または`repomix.config.json`で
```json
{
  "security": {
    "enableSecurityCheck": false
  }
}
```

## セキュリティ対策

1. **バイナリファイルの除外**: バイナリファイルは出力に含まれません
2. **Git対応**: `.gitignore`パターンを尊重します
3. **自動検出**: 以下を含む一般的なセキュリティ問題を検出
    - AWSの認証情報
    - データベース接続文字列
    - 認証トークン
    - 秘密鍵

## セキュリティチェックで問題が見つかった場合

出力例
```bash
🔍 Security Check:
──────────────────
2 suspicious file(s) detected and excluded:
1. config/credentials.json
   - Found AWS access key
2. .env.local
   - Found database password
```

## ベストプラクティス

1. 共有する前に必ず出力を確認
2. `.repomixignore`を使用して機密性のあるパスを除外
3. セキュリティチェックを有効に保つ
4. 機密ファイルをリポジトリから削除

## セキュリティ問題の報告

セキュリティ脆弱性を発見した場合は
1. パブリックなイシューは作成しないでください
2. メール: koukun0120@gmail.com
3. または[GitHub Security Advisories](https://github.com/yamadashy/repomix/security/advisories/new)を使用
</file>

<file path="website/client/src/ja/guide/usage.md">
# 基本的な使い方

## クイックスタート

リポジトリ全体をパッケージング
```bash
repomix
```

## 一般的な使用例

### 特定のディレクトリをパッケージング
```bash
repomix path/to/directory
```

### 特定のファイルを含める
[globパターン](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)を使用
```bash
repomix --include "src/**/*.ts,**/*.md"
```

### ファイルを除外
```bash
repomix --ignore "**/*.log,tmp/"
```

### リモートリポジトリを処理
```bash
# GitHubのURLを使用
repomix --remote https://github.com/user/repo

# 省略形を使用
repomix --remote user/repo

# 特定のブランチ/タグ/コミット
repomix --remote user/repo --remote-branch main
repomix --remote user/repo --remote-branch 935b695
```

## 出力フォーマット

### プレーンテキスト（デフォルト）
```bash
repomix --style plain
```

### XML
```bash
repomix --style xml
```

### Markdown
```bash
repomix --style markdown
```

## その他のオプション

### コメントを削除
```bash
repomix --remove-comments
```

### 行番号を表示
```bash
repomix --output-show-line-numbers
```

### クリップボードにコピー
```bash
repomix --copy
```

### セキュリティチェックを無効化
```bash
repomix --no-security-check
```

## 設定

設定ファイルを初期化
```bash
repomix --init
```

詳細な設定オプションについては[設定ガイド](/ja/guide/configuration)をご覧ください。
</file>

<file path="website/client/src/ja/index.md">
---
layout: home
title: Repomix
titleTemplate: コードベースをAIフレンドリーな形式にパッケージング
aside: false
editLink: false

features:
  - icon: 🤖
    title: AI最適化
    details: コードベースをAIが理解・処理しやすい形式にフォーマット

  - icon: ⚙️
    title: Git対応
    details: .gitignoreファイルを自動的に認識し、適切なファイル除外

  - icon: 🛡️
    title: セキュリティ重視
    details: Secretlintを組み込み、機密情報の検出と除外

  - icon: 📊
    title: トークンカウント
    details: ファイルごとおよびコードベース全体のトークン数を計測し、LLMのコンテキスト制限に対応

---

<div class="cli-section">

## クイックスタート

Repomixを使用すると、コードベース全体を1ファイル（`repomix-output.txt`）にできます。

そのまま Claude に次のようなプロンプトと一緒に送ると、

```
このファイルはコードベース内のファイルを1つにまとめたものです。
コードのリファクタリングを行いたいので、まずはコードレビューをお願いします。
```

全体の内容を理解した上で、リファクタリングなどを進めることができます。

![Repomixの使用例1](/images/docs/repomix-file-usage-1.png)

具体的な内容を提案すると、それに従って良い感じのコードを生成してくれます。Claude だと Artifacts 機能で複数のファイルが出力できるため、依存関係にある複数のコードも一緒に生成できます。

![Repomixの使用例2](/images/docs/repomix-file-usage-2.png)

良いコーディング体験を！🚀

## より凝った使い方をしたい方へ

Repomix はCLIでも使えます。

ウェブ上では簡単な設定しかできませんが、より詳細な設定で実行したい場合はCLIを使うことをお勧めします。

### クイックスタート

任意のディレクトリで以下のコマンドを実行すると、 `repomix-output.txt` が生成され、それ以降の使い方は同様です。

```bash
npx repomix
```

または、グローバルにインストールして繰り返し使用することもできます。

```bash
# npmを使用してインストール
npm install -g repomix

# または、yarnを使用
yarn global add repomix

# または、Homebrewを使用（macOS/Linux）
brew install repomix

# その後、任意のプロジェクトディレクトリで実行
repomix
```


### CLIの使用方法

カレントディレクトリ全体をまとめる。

```bash
repomix
```

特定のディレクトリをまとめる。

```bash
repomix path/to/directory
```

[glob パターン](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)を使用して特定のファイルやディレクトリを指定。

```bash
repomix --include "src/**/*.ts,**/*.md"
```

特定のファイルやディレクトリを除外。

```bash
repomix --ignore "**/*.log,tmp/"
```

リモートリポジトリをまとめる。

```bash
repomix --remote https://github.com/yamadashy/repomix

# GitHubショートハンド形式も使用可能
repomix --remote yamadashy/repomix

# ブランチ名、タグ、コミットハッシュを指定可能
repomix --remote https://github.com/yamadashy/repomix --remote-branch main

# または特定のコミットハッシュを使用
repomix --remote https://github.com/yamadashy/repomix --remote-branch 935b695
```

設定ファイル（`repomix.config.json`）の初期化

```bash
repomix --init
```

生成されたファイルは、Claude、ChatGPT、Geminiなどの生成AIツールで使用できます。

### Docker使用方法 🐳

Dockerを使用してRepomixを実行することも可能で、分離された環境でRepomixを実行したい場合に便利です。

基本的な使用方法

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

特定のディレクトリをまとめる
```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory
```

リモートリポジトリを処理し、`output`ディレクトリに出力

```bash
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote https://github.com/yamadashy/repomix
```

### 出力フォーマット

出力フォーマットは3種類あり、`xml`, `markdown`, `plain` を選択できます。
LLMによっては得意・不得意があるので、適切なフォーマットを選択してください。

```bash
# プレーンテキストフォーマット（デフォルト）
repomix --style plain

# XMLフォーマット
repomix --style xml

# Markdownフォーマット
repomix --style markdown
```

### カスタマイズ

フォルダごとの永続的な設定のために`repomix --init`で`repomix.config.json`を作成できます。

```json
{
  "output": {
    "style": "markdown",
    "filePath": "custom-output.md",
    "removeComments": true,
    "showLineNumbers": true,
    "topFilesLength": 10
  },
  "ignore": {
    "customPatterns": ["*.test.ts", "docs/**"]
  }
}
```

### その他の例
::: tip
💡 詳細なドキュメントと更なる例については、[GitHubリポジトリ](https://github.com/yamadashy/repomix)をご覧ください！
:::

</div>
</file>

<file path="website/client/src/ko/guide/development/index.md">
# Repomix에 기여하기

## 빠른 시작

```bash
git clone https://github.com/yamadashy/repomix.git
cd repomix
npm install
```

## 개발 명령어

```bash
# CLI 실행
npm run cli-run

# 테스트 실행
npm run test
npm run test-coverage

# 코드 린트
npm run lint
```

## 코드 스타일

- 린트 및 포맷팅에 [Biome](https://biomejs.dev/)을 사용합니다.
- 테스트 용이성을 위해 의존성 주입을 사용합니다.
- 파일 길이를 250줄 미만으로 유지합니다.
- 새로운 기능에 대한 테스트를 추가합니다.

## Pull Request 가이드라인

1. 모든 테스트를 실행합니다.
2. 린트 검사를 통과합니다.
3. 문서를 업데이트합니다.
4. 기존 코드 스타일을 따릅니다.

## 도움이 필요하신가요?

- [이슈 열기](https://github.com/yamadashy/repomix/issues)
- [Discord 참여](https://discord.gg/wNYzTwZFku)
</file>

<file path="website/client/src/ko/guide/development/setup.md">
# 개발 환경 설정

## 필수 구성 요소

- Node.js ≥ 18.0.0
- Git
- npm

## 로컬 개발

```bash
# 저장소 복제
git clone https://github.com/yamadashy/repomix.git
cd repomix

# 의존성 설치
npm install

# CLI 실행
npm run cli-run
```

## Docker 개발

```bash
# 이미지 빌드
docker build -t repomix .

# 컨테이너 실행
docker run -v ./:/app -it --rm repomix
```

## 프로젝트 구조

```
src/
├── cli/          # CLI 구현
├── config/       # 구성 처리
├── core/         # 핵심 기능
└── shared/       # 공유 유틸리티
```

## 테스트

```bash
# 테스트 실행
npm run test

# 테스트 커버리지
npm run test-coverage

# 린트
npm run lint-biome
npm run lint-ts
npm run lint-secretlint
```

## 릴리스 프로세스

1. 버전 업데이트
```bash
npm version patch  # 또는 minor/major
```

2. 테스트 및 빌드 실행
```bash
npm run test-coverage
npm run build
```

3. 게시
```bash
npm publish
</file>

<file path="website/client/src/ko/guide/tips/best-practices.md">
# AI 지원 개발 모범 사례: 나의 경험으로부터

저는 아직 AI를 사용하여 대규모 프로젝트를 성공적으로 완료하지는 못했지만, 지금까지 개발 과정에서 AI와 함께 작업하면서 배운 점을 공유하고자 합니다.

## 기본 개발 접근 방식

AI와 함께 작업할 때, 모든 기능을 한 번에 구현하려고 하면 예상치 못한 문제와 프로젝트 정체로 이어질 수 있습니다. 그렇기 때문에 핵심 기능부터 시작하여 각 기능을 하나씩 구축하고, 다음 단계로 넘어가기 전에 견고한 구현을 보장하는 것이 더 효과적입니다.

### 기존 코드의 힘

이 접근 방식이 효과적인 이유는 핵심 기능을 구현하면 실제 코드를 통해 이상적인 설계와 코딩 스타일을 구체화할 수 있기 때문입니다. 프로젝트 비전을 전달하는 가장 효과적인 방법은 표준과 선호도를 반영하는 코드를 작성하는 것입니다.

핵심 기능부터 시작하여 각 구성 요소가 제대로 작동하는지 확인한 후 다음 단계로 진행하면 전체 프로젝트의 일관성이 유지되므로 AI가 더 적절한 코드를 생성하기 쉬워집니다.

## 모듈식 접근 방식

코드를 더 작은 모듈로 나누는 것이 중요합니다. 제 경험상, 파일을 약 250줄 정도로 유지하면 AI에게 명확한 지침을 제공하기 쉽고 시행착오 프로세스가 더 효율적입니다. 토큰 수가 더 정확한 지표가 될 수 있지만, 줄 수는 개발자가 작업하기에 더 실용적이므로 이를 지침으로 사용합니다.

이러한 모듈화는 단순히 프런트엔드, 백엔드, 데이터베이스 구성 요소를 분리하는 것뿐만 아니라 훨씬 더 세분화된 수준에서 기능을 분리하는 것입니다. 예를 들어, 단일 기능 내에서 유효성 검사, 오류 처리 및 기타 특정 기능을 별개의 모듈로 분리할 수 있습니다. 물론, 높은 수준의 분리도 중요하며, 이러한 모듈식 접근 방식을 점진적으로 구현하면 명확한 지침을 유지하고 AI가 더 적절한 코드를 생성할 수 있습니다. 이 접근 방식은 AI뿐만 아니라 사람 개발자에게도 효과적입니다.

## 테스트를 통한 품질 보장

저는 AI 지원 개발에서 테스트가 매우 중요하다고 생각합니다. 테스트는 품질 보장 수단일 뿐만 아니라 코드 의도를 명확하게 보여주는 문서 역할도 합니다. AI에게 새로운 기능 구현을 요청할 때, 기존 테스트 코드는 사실상 사양 문서 역할을 합니다.

테스트는 또한 AI가 생성한 코드의 정확성을 검증하는 훌륭한 도구입니다. 예를 들어, AI에게 모듈에 대한 새로운 기능 구현을 요청할 때, 테스트 케이스를 미리 작성하면 생성된 코드가 예상대로 작동하는지 객관적으로 평가할 수 있습니다. 이는 테스트 주도 개발(TDD) 원칙과 잘 부합하며 AI와 협업할 때 특히 효과적입니다.

## 계획과 구현의 균형

대규모 기능을 구현하기 전에 먼저 AI와 계획에 대해 논의하는 것이 좋습니다. 요구 사항을 정리하고 아키텍처를 고려하면 구현이 더 원활해집니다. 좋은 방법은 먼저 요구 사항을 정리한 다음 별도의 대화 세션으로 이동하여 구현 작업을 수행하는 것입니다.

AI의 출력을 사람이 검토하고 필요에 따라 조정하는 것이 중요합니다. AI가 생성한 코드의 품질은 일반적으로 보통 수준이지만, 모든 것을 처음부터 작성하는 것보다 개발 속도를 높여줍니다.

## 결론

이러한 관행을 따르면 AI의 강점을 활용하면서 일관성 있고 고품질의 코드베이스를 구축할 수 있습니다. 프로젝트 규모가 커지더라도 각 구성 요소는 잘 정의되고 관리하기 쉬운 상태로 유지됩니다.
</file>

<file path="website/client/src/ko/guide/command-line-options.md">
# 명령행 옵션

## 기본 옵션

```bash
repomix [directory]  # 특정 디렉토리 처리 (기본값: ".")
```

## 출력 옵션

| 옵션 | 설명 | 기본값 |
|--------|-------------|---------|
| `-o, --output <file>` | 출력 파일 이름 | `repomix-output.txt` |
| `--style <type>` | 출력 형식 (`plain`, `xml`, `markdown`) | `plain` |
| `--output-show-line-numbers` | 행 번호 추가 | `false` |
| `--copy` | 클립보드에 복사 | `false` |
| `--no-file-summary` | 파일 요약 비활성화 | `true` |
| `--no-directory-structure` | 디렉토리 구조 비활성화 | `true` |
| `--remove-comments` | 주석 제거 | `false` |
| `--remove-empty-lines` | 빈 줄 제거 | `false` |

## 필터 옵션

| 옵션 | 설명 |
|--------|-------------|
| `--include <patterns>` | 포함할 패턴 (쉼표로 구분) |
| `-i, --ignore <patterns>` | 제외할 패턴 (쉼표로 구분) |

## 원격 저장소

| 옵션 | 설명 |
|--------|-------------|
| `--remote <url>` | 원격 저장소 처리 |
| `--remote-branch <name>` | 브랜치/태그/커밋 지정 |

## 설정

| 옵션 | 설명 |
|--------|-------------|
| `-c, --config <path>` | 사용자 정의 설정 파일 경로 |
| `--init` | 설정 파일 생성 |
| `--global` | 전역 설정 사용 |

## 보안

| 옵션 | 설명 | 기본값 |
|--------|-------------|---------|
| `--no-security-check` | 보안 검사 비활성화 | `true` |

## 기타 옵션

| 옵션 | 설명 |
|--------|-------------|
| `-v, --version` | 버전 표시 |
| `--verbose` | 상세 로그 활성화 |
| `--top-files-len <number>` | 표시할 상위 파일 수 | `5` |

## 사용 예시

```bash
# 기본 사용법
repomix

# 사용자 정의 출력
repomix -o output.xml --style xml

# 특정 파일 처리
repomix --include "src/**/*.ts" --ignore "**/*.test.ts"

# 원격 저장소 처리
repomix --remote user/repo --remote-branch main
```
</file>

<file path="website/client/src/ko/guide/comment-removal.md">
# 주석 제거

Repomix는 출력 파일을 생성할 때 코드베이스에서 주석을 자동으로 제거할 수 있습니다. 이를 통해 노이즈를 줄이고 실제 코드에 집중할 수 있습니다.

## 사용법

주석 제거를 활성화하려면 `repomix.config.json`에서 `removeComments` 옵션을 `true`로 설정합니다.

```json
{
  "output": {
    "removeComments": true
  }
}
```

## 지원되는 언어

Repomix는 다음을 포함한 광범위한 프로그래밍 언어에 대한 주석 제거를 지원합니다.

- JavaScript/TypeScript (`//`, `/* */`)
- Python (`#`, `"""`, `'''`)
- Java (`//`, `/* */`)
- C/C++ (`//`, `/* */`)
- HTML (`<!-- -->`)
- CSS (`/* */`)
- 그리고 더 많은 언어들...

## 예시

다음 JavaScript 코드가 주어졌을 때:

```javascript
// 이것은 한 줄 주석입니다
function test() {
  /* 이것은
     여러 줄 주석입니다 */
  return true;
}
```

주석 제거를 활성화하면 출력은 다음과 같습니다.

```javascript
function test() {
  return true;
}
```

## 참고

- 주석 제거는 행 번호 추가와 같은 다른 처리 단계 전에 수행됩니다.
- JSDoc 주석과 같은 일부 주석은 언어 및 컨텍스트에 따라 보존될 수 있습니다.
</file>

<file path="website/client/src/ko/guide/configuration.md">
# 설정

## 빠른 시작

설정 파일 생성:
```bash
repomix --init
```

## 설정 파일

`repomix.config.json`:
```json
{
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "headerText": "사용자 정의 헤더 텍스트",
    "instructionFilePath": "repomix-instruction.md",
    "fileSummary": true,
    "directoryStructure": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "includeEmptyDirectories": false
  },
  "include": ["**/*"],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": ["tmp/", "*.log"]
  },
  "security": {
    "enableSecurityCheck": true
  }
}
```

## 전역 설정

전역 설정 생성:
```bash
repomix --init --global
```

설정 파일 위치:
- Windows: `%LOCALAPPDATA%\\Repomix\\repomix.config.json`
- macOS/Linux: `~/.config/repomix/repomix.config.json`

## 제외 패턴

우선순위 순서:
1. 명령행 옵션 (`--ignore`)
2. .repomixignore
3. .gitignore
4. 기본 패턴

`.repomixignore` 예시:
```text
# 캐시 디렉토리
.cache/
tmp/

# 빌드 출력
dist/
build/

# 로그
*.log
```

## 기본 제외 패턴

기본적으로 포함되는 일반적인 패턴:
```text
node_modules/**
.git/**
coverage/**
dist/**
```

전체 목록: [defaultIgnore.ts](https://github.com/yamadashy/repomix/blob/main/src/config/defaultIgnore.ts)
</file>

<file path="website/client/src/ko/guide/custom-instructions.md">
# 사용자 정의 지시사항

Repomix는 출력 파일에 포함될 사용자 정의 지시사항을 제공할 수 있게 해줍니다. 이는 AI 시스템이 프로젝트의 특정 맥락이나 요구 사항을 이해하는 데 도움이 됩니다.

## 사용법

사용자 정의 지시사항을 포함하려면 저장소의 루트에 마크다운 파일(예: `repomix-instruction.md`)을 생성하고, `repomix.config.json`에서 해당 파일의 경로를 지정하세요:

```json
{
  "output": {
    "instructionFilePath": "repomix-instruction.md"
  }
}
```

이 파일의 내용은 출력의 "Instruction" 섹션에 포함됩니다.

## 사용 예시

```markdown
# 코딩 지침

- Airbnb JavaScript 스타일 가이드를 따르세요.
- 필요한 경우 파일을 더 작은 단위로 분할하세요.
- 불분명한 로직에는 주석을 추가하세요. 모든 텍스트는 영어로 작성하세요.
- 모든 새로운 기능에 대해 해당 단위 테스트를 작성하세요.

## 생성된 콘텐츠에 대하여

- 특별한 지정이 없는 한, 모든 콘텐츠를 생략 없이 포함하세요.
- 대규모 코드베이스를 처리할 때도 출력 품질을 유지하세요.
```

이는 출력 파일에서 다음과 같이 표시됩니다:

```xml
<instruction>
# 코딩 가이드라인

- Airbnb JavaScript 스타일 가이드를 따릅니다
- 필요한 경우 파일을 작은 단위로 분할합니다
- 명확하지 않은 로직에는 주석을 추가합니다. 모든 텍스트는 영어로 작성합니다
- 모든 새로운 기능에는 해당하는 단위 테스트를 작성합니다

## 생성 내용에 대해

- 특별한 지정이 없는 한, 모든 내용은 축약하지 않고 포함합니다
- 대규모 코드베이스를 처리하면서도 출력의 품질을 유지합니다
</instruction>
```

## 모범 사례

1. **간결하고 명확하게**: 지시사항은 간결하되, 필요한 세부 사항은 모두 포함해야 합니다.
2. **구체적인 예시 제공**: 적절한 경우 코드 예시를 사용하여 설명을 보완합니다.
3. **우선순위 설정**: 가장 중요한 지시사항을 문서 앞부분에 배치하여 강조합니다.
4. **맥락 포함**: 프로젝트의 배경과 중요한 고려사항을 제공하여 AI가 작업을 더 잘 이해하도록 돕습니다.
5. **구조화된 콘텐츠**: 제목과 목록을 사용하여 지시사항을 체계적으로 구성하고 가독성을 높입니다.

## 주의 사항

- 지시사항에 민감한 정보를 포함하지 마세요
- 프로젝트의 변화를 반영하여 정기적으로 지시사항을 업데이트하세요
- 지시사항이 프로젝트의 다른 문서와 일관성을 유지하도록 하세요
- 명확한 계층 구조를 사용하여 콘텐츠를 구성하세요
</file>

<file path="website/client/src/ko/guide/index.md">
# Repomix 시작하기

Repomix는 전체 저장소를 AI 친화적인 단일 파일로 패키징하는 도구입니다. Claude, ChatGPT, Gemini와 같은 대규모 언어 모델(LLM)에 코드베이스를 제공하는 데 도움이 되도록 설계되었습니다.

## 빠른 시작

프로젝트 디렉토리에서 다음 명령을 실행하세요.

```bash
npx repomix
```

이게 전부입니다! AI 친화적인 형식으로 전체 저장소를 포함하는 `repomix-output.txt` 파일이 생성됩니다.

그런 다음 이 파일을 다음과 같은 프롬프트와 함께 AI 어시스턴트에 보낼 수 있습니다.

```
이 파일에는 저장소의 모든 파일이 하나로 결합되어 있습니다.
코드를 리팩터링하고 싶으니 먼저 검토해 주세요.
```

AI는 전체 코드베이스를 분석하고 포괄적인 인사이트를 제공합니다.

![Repomix 파일 사용 예시 1](/images/docs/repomix-file-usage-1.png)

특정 변경 사항을 논의할 때 AI가 코드 생성을 도울 수 있습니다. Claude의 Artifacts와 같은 기능을 사용하면 상호 의존적인 여러 파일을 받을 수도 있습니다.

![Repomix 파일 사용 예시 2](/images/docs/repomix-file-usage-2.png)

즐거운 코딩 되세요! 🚀

## 핵심 기능

- **AI 최적화 출력**: AI 처리에 용이한 형식으로 코드베이스를 구성합니다.
- **토큰 계산**: LLM 컨텍스트 제한을 위한 토큰 사용량을 추적합니다.
- **Git 인식**: .gitignore 파일을 존중합니다.
- **보안 중심**: 민감한 정보를 탐지합니다.
- **다양한 출력 형식**: 일반 텍스트, XML, Markdown 중에서 선택할 수 있습니다.

## 다음 단계

- [설치 가이드](installation.md): Repomix를 설치하는 다양한 방법
- [사용 가이드](usage.md): 기본 및 고급 기능에 대해 알아보기
- [구성](configuration.md): 필요에 맞게 Repomix를 사용자 정의하기
- [보안 기능](security.md): 보안 검사에 대해 알아보기

## 커뮤니티

[Discord 커뮤니티](https://discord.gg/wNYzTwZFku)에 참여하세요:
- Repomix에 대한 도움 받기
- 경험 공유
- 새로운 기능 제안
- 다른 사용자와 소통

## 지원

버그를 발견했거나 도움이 필요하신가요?
- [GitHub에 이슈 열기](https://github.com/yamadashy/repomix/issues)
- Discord 서버에 참여하기
- [문서 확인하기](https://repomix.com)
</file>

<file path="website/client/src/ko/guide/installation.md">
# 설치

## npx 사용 (설치 불필요)

```bash
npx repomix
```

## 전역 설치

### npm
```bash
npm install -g repomix
```

### Yarn
```bash
yarn global add repomix
```

### Homebrew (macOS/Linux)
```bash
brew install repomix
```

## Docker 설치

Docker를 사용하면 환경 설정 문제를 피할 수 있어 가장 편리한 방법 중 하나입니다. 아래와 같이 실행하세요:

```bash
# 현재 디렉토리 처리
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix

# 특정 디렉토리 처리
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory

# 원격 저장소 처리
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote yamadashy/repomix
```

## 시스템 요구 사항

- Node.js: 18.0.0 이상
- Git: 원격 저장소 처리 시 필요

## 설치 확인

설치가 완료된 후, 다음 명령어로 Repomix가 정상적으로 작동하는지 확인하세요:

```bash
repomix --version
repomix --help
```
</file>

<file path="website/client/src/ko/guide/output.md">
# 출력 형식

Repomix는 세 가지 출력 형식을 지원합니다:
- 일반 텍스트 (기본값)
- XML
- Markdown

## 일반 텍스트 형식

```bash
repomix --style plain
```

출력 구조:
```text
이 파일은 전체 코드베이스를 하나의 문서로 통합한 것입니다...

================
파일 요약
================
(메타데이터 및 AI 지시사항)

================
디렉토리 구조
================
src/
  index.ts
  utils/
    helper.ts

================
파일
================

================
File: src/index.ts
================
// 파일 내용
```

## XML 형식

```bash
repomix --style xml
```

XML 형식은 AI 처리에 최적화되어 있습니다:

```xml
이 파일은 전체 코드베이스를 하나의 문서로 통합한 것입니다...

<file_summary>
(메타데이터 및 AI 지시사항)
</file_summary>

<directory_structure>
src/
  index.ts
  utils/
    helper.ts
</directory_structure>

<files>
<file path="src/index.ts">
// 파일 내용
</file>
</files>
```

::: tip XML을 사용하는 이유
XML 태그는 Claude와 같은 AI 모델이 내용을 더 정확하게 파싱하는 데 도움이 됩니다. [Claude 공식 문서](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/use-xml-tags)에서는 구조화된 프롬프트에 XML 태그 사용을 권장하고 있습니다.
:::

## Markdown 형식

```bash
repomix --style markdown
```

Markdown은 읽기 쉬운 형식을 제공합니다:

```markdown
이 파일은 전체 코드베이스를 하나의 문서로 통합한 것입니다...

# 파일 요약
(메타데이터 및 AI 지시사항)

# 디렉토리 구조
```
src/
index.ts
utils/
helper.ts
```

# 파일

## File: src/index.ts
```typescript
// 파일 내용
```
```

## AI 모델과의 사용

각 형식은 AI 모델에서 잘 작동하지만, 다음 사항을 고려하세요:
- Claude에는 XML 사용 (가장 정확한 파싱)
- 일반적인 가독성을 위해서는 Markdown
- 단순성과 호환성을 위해서는 일반 텍스트

## 사용자 정의

`repomix.config.json`에서 기본 형식 설정:
```json
{
  "output": {
    "style": "xml",
    "filePath": "output.xml"
  }
}
```
</file>

<file path="website/client/src/ko/guide/prompt-examples.md">
# Prompt Examples

## Code Review

### Architecture Review
```
Analyze this codebase's architecture:
1. Evaluate the overall structure and patterns
2. Identify potential architectural issues
3. Suggest improvements for scalability
4. Note areas that follow best practices

Focus on maintainability and modularity.
```

### Security Review
```
Perform a security review of this codebase:
1. Identify potential security vulnerabilities
2. Check for common security anti-patterns
3. Review error handling and input validation
4. Assess dependency security

Provide specific examples and remediation steps.
```

### Performance Review
```
Review the codebase for performance:
1. Identify performance bottlenecks
2. Check resource utilization
3. Review algorithmic efficiency
4. Assess caching strategies

Include specific optimization recommendations.
```

## Documentation Generation

### API Documentation
```
Generate comprehensive API documentation:
1. List and describe all public endpoints
2. Document request/response formats
3. Include usage examples
4. Note any limitations or constraints
```

### Developer Guide
```
Create a developer guide covering:
1. Setup instructions
2. Project structure overview
3. Development workflow
4. Testing approach
5. Common troubleshooting steps
```

### Architecture Documentation
```
Document the system architecture:
1. High-level overview
2. Component interactions
3. Data flow diagrams
4. Design decisions and rationale
5. System constraints and limitations
```

## Analysis and Improvement

### Dependency Analysis
```
Analyze the project dependencies:
1. Identify outdated packages
2. Check for security vulnerabilities
3. Suggest alternative packages
4. Review dependency usage patterns

Include specific upgrade recommendations.
```

### Test Coverage
```
Review the test coverage:
1. Identify untested components
2. Suggest additional test cases
3. Review test quality
4. Recommend testing strategies
```

### Code Quality
```
Assess code quality and suggest improvements:
1. Review naming conventions
2. Check code organization
3. Evaluate error handling
4. Review commenting practices

Provide specific examples of good and problematic patterns.
```

## Tips for Better Results

1. **Be Specific**: Include clear objectives and evaluation criteria
2. **Set Context**: Specify your role and expertise level needed
3. **Request Format**: Define how you want the response structured
4. **Prioritize**: Indicate which aspects are most important

## Model-Specific Notes

### Claude
- Use XML output format
- Place important instructions at the end
- Specify response structure

### ChatGPT
- Use Markdown format
- Break large codebases into sections
- Include system role prompts

### Gemini
- Works with all formats
- Focus on specific areas per request
- Use step-by-step analysis
</file>

<file path="website/client/src/ko/guide/remote-repository-processing.md">
# Remote Repository Processing

## Basic Usage

Process public repositories:
```bash
# Using full URL
repomix --remote https://github.com/user/repo

# Using GitHub shorthand
repomix --remote user/repo
```

## Branch and Commit Selection

```bash
# Specific branch
repomix --remote user/repo --remote-branch main

# Tag
repomix --remote user/repo --remote-branch v1.0.0

# Commit hash
repomix --remote user/repo --remote-branch 935b695
```

## Requirements

- Git must be installed
- Internet connection
- Read access to repository

## Output Control

```bash
# Custom output location
repomix --remote user/repo -o custom-output.xml

# With XML format
repomix --remote user/repo --style xml

# Remove comments
repomix --remote user/repo --remove-comments
```

## Docker Usage

```bash
# Process and output to current directory
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo

# Output to specific directory
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo
```

## Common Issues

### Access Issues
- Ensure repository is public
- Check Git installation
- Verify internet connection

### Large Repositories
- Use `--include` to select specific paths
- Enable `--remove-comments`
- Process branches separately
</file>

<file path="website/client/src/ko/guide/security.md">
# 보안

## 보안 검사 기능

Repomix는 [Secretlint](https://github.com/secretlint/secretlint)를 사용하여 파일 내의 민감한 정보를 감지합니다:
- API 키
- 액세스 토큰
- 인증 정보
- 개인 키
- 환경 변수

## 설정

보안 검사는 기본적으로 활성화되어 있습니다.

명령행에서 비활성화:
```bash
repomix --no-security-check
```

또는 `repomix.config.json`에서 설정:
```json
{
  "security": {
    "enableSecurityCheck": false
  }
}
```

## 보안 조치

1. **바이너리 파일 제외**: 출력에 바이너리 파일이 포함되지 않음
2. **Git 인식**: `.gitignore` 패턴을 준수
3. **자동 감지**: 다음과 같은 일반적인 보안 문제를 스캔:
    - AWS 자격 증명
    - 데이터베이스 연결 문자열
    - 인증 토큰
    - 개인 키

## 보안 검사에서 문제가 발견된 경우

출력 예시:
```bash
🔍 Security Check:
──────────────────
2 suspicious file(s) detected and excluded:
1. config/credentials.json
   - Found AWS access key
2. .env.local
   - Found database password
```

## 모범 사례

1. 공유하기 전에 반드시 출력 내용 검토
2. `.repomixignore`를 사용하여 민감한 경로 제외
3. 보안 검사 기능 활성화 유지
4. 저장소에서 민감한 파일 제거

## 보안 문제 보고

보안 취약점을 발견하셨다면:
1. 공개 이슈를 생성하지 마세요
2. 이메일: koukun0120@gmail.com
3. 또는 [GitHub 보안 권고](https://github.com/yamadashy/repomix/security/advisories/new) 사용
</file>

<file path="website/client/src/ko/guide/usage.md">
# 기본 사용법

## 빠른 시작

저장소 전체를 패키징:
```bash
repomix
```

## 일반적인 사용 사례

### 특정 디렉토리 패키징
```bash
repomix path/to/directory
```

### 특정 파일 포함
[glob 패턴](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax) 사용:
```bash
repomix --include "src/**/*.ts,**/*.md"
```

### 파일 제외
```bash
repomix --ignore "**/*.log,tmp/"
```

### 원격 저장소 처리
```bash
# GitHub URL 사용
repomix --remote https://github.com/user/repo

# 단축형 사용
repomix --remote user/repo

# 특정 브랜치/태그/커밋
repomix --remote user/repo --remote-branch main
repomix --remote user/repo --remote-branch 935b695
```

## 출력 형식

### 일반 텍스트 (기본값)
```bash
repomix --style plain
```

### XML
```bash
repomix --style xml
```

### Markdown
```bash
repomix --style markdown
```

## 추가 옵션

### 주석 제거
```bash
repomix --remove-comments
```

### 행 번호 표시
```bash
repomix --output-show-line-numbers
```

### 클립보드에 복사
```bash
repomix --copy
```

### 보안 검사 비활성화
```bash
repomix --no-security-check
```

## 설정

설정 파일 초기화:
```bash
repomix --init
```

더 자세한 설정 옵션은 [설정 가이드](/ko/guide/configuration)를 참조하세요.
</file>

<file path="website/client/src/ko/index.md">
---
layout: home
title: Repomix
titleTemplate: 코드베이스를 AI 친화적인 형식으로 패키징
aside: false
editLink: false

features:
  - icon: 🤖
    title: AI 최적화
    details: 코드베이스를 AI가 이해하고 처리하기 쉬운 형식으로 변환합니다.

  - icon: ⚙️
    title: Git 인식
    details: .gitignore 파일을 자동으로 인식하고 처리합니다.

  - icon: 🛡️
    title: 보안 중심
    details: Secretlint를 통합하여 민감한 정보를 감지하고 보호합니다.

  - icon: 📊
    title: 토큰 카운팅
    details: LLM 컨텍스트 제한을 위한 파일별 및 전체 토큰 수를 제공합니다.

---

<div class="cli-section">

## 빠른 시작

Repomix를 사용하여 패키지 파일(`repomix-output.txt`)을 생성한 후, 다음과 같은 프롬프트와 함께 AI 어시스턴트에게 전송할 수 있습니다:

```
이 파일은 저장소의 모든 파일을 하나로 통합한 것입니다.
코드를 리팩터링하고 싶으니 먼저 검토해 주세요.
```

AI는 전체 코드베이스를 분석하고 포괄적인 인사이트를 제공할 것입니다:

![Repomix 사용 예시 1](/images/docs/repomix-file-usage-1.png)

구체적인 변경 사항을 논의할 때는 AI가 코드 생성을 도와줍니다. Claude의 Artifacts와 같은 기능을 사용하면 상호 의존적인 여러 파일도 한 번에 받을 수 있습니다:

![Repomix 사용 예시 2](/images/docs/repomix-file-usage-2.png)

즐거운 코딩 되세요! 🚀



## 파워 유저 가이드

고급 사용자를 위해 Repomix는 CLI 인터페이스를 통해 다양한 사용자 정의 옵션을 제공합니다.

### 빠른 시작

프로젝트 디렉토리에서 설치 없이 바로 Repomix를 시작할 수 있습니다:

```bash
npx repomix
```

또는 반복 사용을 위해 전역 설치:

```bash
# npm으로 설치
npm install -g repomix

# 또는 yarn으로 설치
yarn global add repomix

# 또는 Homebrew로 설치 (macOS/Linux)
brew install repomix

# 그런 다음 아무 프로젝트 디렉토리에서 실행
repomix
```

이게 전부입니다! Repomix가 현재 디렉토리에 `repomix-output.txt` 파일을 생성하며, 이 파일에는 AI 친화적인 형식으로 정리된 전체 코드베이스가 포함됩니다.



### 사용법

전체 저장소를 패키징:

```bash
repomix
```

특정 디렉토리를 패키징:

```bash
repomix path/to/directory
```

[glob 패턴](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)을 사용하여 특정 파일이나 디렉토리를 지정:

```bash
repomix --include "src/**/*.ts,**/*.md"
```

특정 파일이나 디렉토리 제외:

```bash
repomix --ignore "**/*.log,tmp/"
```

원격 저장소 처리:
```bash
repomix --remote https://github.com/yamadashy/repomix

# GitHub 단축형도 사용 가능:
repomix --remote yamadashy/repomix

# 브랜치명, 태그, 또는 커밋 해시 지정 가능:
repomix --remote https://github.com/yamadashy/repomix --remote-branch main

# 또는 특정 커밋 해시 사용:
repomix --remote https://github.com/yamadashy/repomix --remote-branch 935b695
```

새 설정 파일(`repomix.config.json`) 초기화:

```bash
repomix --init
```

생성된 파일은 Claude, ChatGPT, Gemini와 같은 생성형 AI 도구와 함께 사용할 수 있습니다.

#### Docker 사용법

Docker를 사용하여 Repomix를 실행할 수도 있습니다 🐳  
격리된 환경에서 Repomix를 실행하거나 컨테이너를 선호하는 경우에 유용합니다.

기본 사용법(현재 디렉토리):

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

특정 디렉토리를 처리:
```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory
```

원격 저장소를 처리하고 `output` 디렉토리에 출력:

```bash
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote https://github.com/yamadashy/repomix
```

### 출력 형식

선호하는 출력 형식을 선택하세요:

```bash
# XML 형식(기본값)
repomix --style xml

# Markdown 형식
repomix --style markdown

# 일반 텍스트 형식
repomix --style plain
```

### 사용자 정의

`repomix.config.json`을 생성하여 지속적인 설정을 관리할 수 있습니다:

```json
{
  "output": {
    "style": "markdown",
    "filePath": "custom-output.md",
    "removeComments": true,
    "showLineNumbers": true,
    "topFilesLength": 10
  },
  "ignore": {
    "customPatterns": ["*.test.ts", "docs/**"]
  }
}
```

### 더 많은 예제
::: tip
💡 전체 문서와 더 많은 예제는 [GitHub 저장소](https://github.com/yamadashy/repomix)를 참조하세요!
:::

</div>
</file>

<file path="website/client/src/pt-br/guide/development/index.md">
# Contribuindo para o Repomix

## Início Rápido

```bash
git clone https://github.com/yamadashy/repomix.git
cd repomix
npm install
```

## Comandos de Desenvolvimento

```bash
# Executar CLI
npm run cli-run

# Executar testes
npm run test
npm run test-coverage

# Lintar código
npm run lint
```

## Estilo de Código

- Use [Biome](https://biomejs.dev/) para lintar e formatar
- Injeção de dependência para testabilidade
- Mantenha os arquivos com menos de 250 linhas
- Adicione testes para novos recursos

## Diretrizes para Pull Requests

1. Execute todos os testes
2. Passe nas verificações de lint
3. Atualize a documentação
4. Siga o estilo de código existente

## Precisa de Ajuda?

- [Abra uma issue](https://github.com/yamadashy/repomix/issues)
- [Junte-se ao Discord](https://discord.gg/wNYzTwZFku)
</file>

<file path="website/client/src/pt-br/guide/development/setup.md">
# Configuração de Desenvolvimento

## Pré-requisitos

- Node.js ≥ 18.0.0
- Git
- npm

## Desenvolvimento Local

```bash
# Clonar repositório
git clone https://github.com/yamadashy/repomix.git
cd repomix

# Instalar dependências
npm install

# Executar CLI
npm run cli-run
```

## Desenvolvimento com Docker

```bash
# Construir imagem
docker build -t repomix .

# Executar container
docker run -v ./:/app -it --rm repomix
```

## Estrutura do Projeto

```
src/
├── cli/          # Implementação da CLI
├── config/       # Manipulação de configuração
├── core/         # Funcionalidade principal
└── shared/       # Utilitários compartilhados
```

## Testando

```bash
# Executar testes
npm run test

# Cobertura de teste
npm run test-coverage

# Linting
npm run lint-biome
npm run lint-ts
npm run lint-secretlint
```

## Processo de Release

1. Atualizar versão
```bash
npm version patch  # ou minor/major
```

2. Executar testes e construir
```bash
npm run test-coverage
npm run build
```

3. Publicar
```bash
npm publish
</file>

<file path="website/client/src/pt-br/guide/tips/best-practices.md">
# AI-Assisted Development Best Practices: From My Experience

While I haven't successfully completed a large-scale project using AI yet, I'd like to share what I've learned so far from my experience working with AI in development.

## Basic Development Approach

When working with AI, attempting to implement all features at once can lead to unexpected issues and project stagnation. That's why it's more effective to start with core functionality and build each feature one at a time, ensuring solid implementation before moving forward.

### The Power of Existing Code

This approach is effective because implementing core functionality allows you to materialize your ideal design and coding style through actual code. The most effective way to communicate your project vision is through code that reflects your standards and preferences.

By starting with core features and ensuring each component works properly before moving on, the entire project maintains consistency, making it easier for AI to generate more appropriate code.

## The Modular Approach

Breaking code into smaller modules is crucial. In my experience, keeping files around 250 lines of code makes it easier to give clear instructions to AI and makes the trial-and-error process more efficient. While token count would be a more accurate metric, line count is more practical for human developers to work with, so we use that as a guideline.

This modularization isn't just about separating frontend, backend, and database components - it's about breaking down functionality at a much finer level. For example, within a single feature, you might separate validation, error handling, and other specific functionalities into distinct modules. Of course, high-level separation is also important, and implementing this modular approach gradually helps maintain clear instructions and enables AI to generate more appropriate code. This approach is effective not just for AI but for human developers as well.

## Ensuring Quality Through Testing

I consider testing to be crucial in AI-assisted development. Tests serve not only as quality assurance measures but also as documentation that clearly demonstrates code intentions. When asking AI to implement new features, existing test code effectively acts as a specification document.

Tests are also an excellent tool for validating the correctness of AI-generated code. For instance, when having AI implement new functionality for a module, writing test cases beforehand allows you to objectively evaluate whether the generated code behaves as expected. This aligns well with Test-Driven Development (TDD) principles and is particularly effective when collaborating with AI.

## Balancing Planning and Implementation

Before implementing large-scale features, I recommend first discussing the plan with AI. Organizing requirements and considering architecture leads to smoother implementation. A good practice is to compile requirements first, then move to a separate chat session for implementation work.

It's essential to have human review of AI output and make adjustments as needed. While the quality of AI-generated code is generally moderate, it still accelerates development compared to writing everything from scratch.

## Conclusion

By following these practices, you can leverage AI's strengths while building a consistent, high-quality codebase. Even as your project grows in size, each component remains well-defined and manageable.
</file>

<file path="website/client/src/pt-br/guide/command-line-options.md">
# Opções de Linha de Comando

## Opções Básicas

```bash
repomix [diretório]  # Processar diretório específico (padrão: ".")
```

## Opções de Saída

| Opção | Descrição | Padrão |
|--------|-------------|---------|
| `-o, --output <arquivo>` | Nome do arquivo de saída | `repomix-output.txt` |
| `--style <tipo>` | Estilo de saída (`plain`, `xml`, `markdown`) | `plain` |
| `--output-show-line-numbers` | Adicionar números de linha | `false` |
| `--copy` | Copiar para a área de transferência | `false` |
| `--no-file-summary` | Desabilitar resumo de arquivos | `true` |
| `--no-directory-structure` | Desabilitar estrutura de diretórios | `true` |
| `--remove-comments` | Remover comentários | `false` |
| `--remove-empty-lines` | Remover linhas vazias | `false` |

## Opções de Filtro

| Opção | Descrição |
|--------|-------------|
| `--include <padrões>` | Padrões de inclusão (separados por vírgula) |
| `-i, --ignore <padrões>` | Padrões de exclusão (separados por vírgula) |

## Repositório Remoto

| Opção | Descrição |
|--------|-------------|
| `--remote <url>` | Processar repositório remoto |
| `--remote-branch <nome>` | Especificar branch/tag/commit |

## Configuração

| Opção | Descrição |
|--------|-------------|
| `-c, --config <caminho>` | Caminho do arquivo de configuração personalizado |
| `--init` | Criar arquivo de configuração |
| `--global` | Usar configuração global |

## Segurança

| Opção | Descrição | Padrão |
|--------|-------------|---------|
| `--no-security-check` | Desabilitar verificação de segurança | `true` |

## Outras Opções

| Opção | Descrição |
|--------|-------------|
| `-v, --version` | Mostrar versão |
| `--verbose` | Habilitar logging detalhado |
| `--top-files-len <número>` | Número de arquivos principais para mostrar | `5` |

## Exemplos

```bash
# Uso básico
repomix

# Saída personalizada
repomix -o output.xml --style xml

# Processar arquivos específicos
repomix --include "src/**/*.ts" --ignore "**/*.test.ts"

# Repositório remoto
repomix --remote user/repo --remote-branch main
</file>

<file path="website/client/src/pt-br/guide/comment-removal.md">
# Remoção de Comentários

O Repomix pode remover automaticamente os comentários do seu código ao gerar o arquivo de saída. Isso pode ajudar a reduzir o ruído e focar no código real.

## Uso

Para habilitar a remoção de comentários, defina a opção `removeComments` como `true` no seu `repomix.config.json`:

```json
{
  "output": {
    "removeComments": true
  }
}
```

## Linguagens Suportadas

O Repomix suporta a remoção de comentários para uma ampla gama de linguagens de programação, incluindo:

- JavaScript/TypeScript (`//`, `/* */`)
- Python (`#`, `"""`, `'''`)
- Java (`//`, `/* */`)
- C/C++ (`//`, `/* */`)
- HTML (`<!-- -->`)
- CSS (`/* */`)
- E muitas outras...

## Exemplo

Dado o seguinte código JavaScript:

```javascript
// Este é um comentário de linha única
function test() {
  /* Este é um
     comentário de várias linhas */
  return true;
}
```

Com a remoção de comentários habilitada, a saída será:

```javascript
function test() {
  return true;
}
```

## Notas

- A remoção de comentários é realizada antes de outras etapas de processamento, como a adição de números de linha.
- Alguns comentários, como os comentários JSDoc, podem ser preservados dependendo da linguagem e do contexto.
</file>

<file path="website/client/src/pt-br/guide/configuration.md">
# Configuração

## Início Rápido

Criar arquivo de configuração:
```bash
repomix --init
```

## Arquivo de Configuração

`repomix.config.json`:
```json
{
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "headerText": "Texto de cabeçalho personalizado",
    "instructionFilePath": "repomix-instruction.md",
    "fileSummary": true,
    "directoryStructure": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "includeEmptyDirectories": false
  },
  "include": ["**/*"],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": ["tmp/", "*.log"]
  },
  "security": {
    "enableSecurityCheck": true
  }
}
```

## Configuração Global

Criar configuração global:
```bash
repomix --init --global
```

Localização:
- Windows: `%LOCALAPPDATA%\Repomix\repomix.config.json`
- macOS/Linux: `~/.config/repomix/repomix.config.json`

## Padrões de Exclusão

Ordem de prioridade:
1. Opções de CLI (`--ignore`)
2. .repomixignore
3. .gitignore
4. Padrões padrão

Exemplo de `.repomixignore`:
```text
# Diretórios de cache
.cache/
tmp/

# Saídas de build
dist/
build/

# Logs
*.log
```

## Padrões de Exclusão Padrão

Padrões comuns incluídos por padrão:
```text
node_modules/**
.git/**
coverage/**
dist/**
```

Lista completa: [defaultIgnore.ts](https://github.com/yamadashy/repomix/blob/main/src/config/defaultIgnore.ts)
</file>

<file path="website/client/src/pt-br/guide/custom-instructions.md">
# Instruções Personalizadas

O Repomix permite fornecer instruções personalizadas que serão incluídas no arquivo de saída. Isso pode ser útil para adicionar contexto ou diretrizes específicas para sistemas de IA que processam o repositório.

## Uso

Para incluir uma instrução personalizada, crie um arquivo markdown (por exemplo, `repomix-instruction.md`) na raiz do seu repositório. Em seguida, especifique o caminho para este arquivo no seu `repomix.config.json`:

```json
{
  "output": {
    "instructionFilePath": "repomix-instruction.md"
  }
}
```

O conteúdo deste arquivo será incluído na saída sob a seção "Instruction".

## Exemplo

```markdown
# Instruções do Repositório

Este repositório contém o código-fonte da ferramenta Repomix. Por favor, siga estas diretrizes ao analisar o código:

1. Concentre-se na funcionalidade principal no diretório `src/core`.
2. Preste atenção especial às verificações de segurança em `src/core/security`.
3. Ignore quaisquer arquivos no diretório `tests`.
```

Isso resultará na seguinte seção na saída:

```xml
<instruction>
# Instruções do Repositório

Este repositório contém o código-fonte da ferramenta Repomix. Por favor, siga estas diretrizes ao analisar o código:

1. Concentre-se na funcionalidade principal no diretório `src/core`.
2. Preste atenção especial às verificações de segurança em `src/core/security`.
3. Ignore quaisquer arquivos no diretório `tests`.
</instruction>
</file>

<file path="website/client/src/pt-br/guide/index.md">
# Introdução ao Repomix

O Repomix é uma ferramenta que compacta todo o seu repositório em um único arquivo amigável para IA. Ele foi projetado para ajudá-lo a alimentar seu código-fonte para Modelos de Linguagem Grandes (LLMs) como Claude, ChatGPT e Gemini.

## Início Rápido

Execute este comando no diretório do seu projeto:

```bash
npx repomix
```

É isso! Você encontrará um arquivo `repomix-output.txt` contendo todo o seu repositório em um formato amigável para IA.

Você pode então enviar este arquivo para um assistente de IA com um prompt como:

```
Este arquivo contém todos os arquivos do repositório combinados em um só.
Eu quero refatorar o código, então, por favor, revise-o primeiro.
```

A IA analisará todo o seu código-fonte e fornecerá insights abrangentes:

![Uso do Arquivo Repomix 1](/images/docs/repomix-file-usage-1.png)

Ao discutir mudanças específicas, a IA pode ajudar a gerar código. Com recursos como o Artifacts do Claude, você pode até receber vários arquivos interdependentes:

![Uso do Arquivo Repomix 2](/images/docs/repomix-file-usage-2.png)

Feliz codificação! 🚀

## Principais Recursos

- **Saída Otimizada para IA**: Formata seu código-fonte para fácil processamento por IA
- **Contagem de Tokens**: Rastreia o uso de tokens para limites de contexto de LLM
- **Consciente do Git**: Respeita seus arquivos .gitignore
- **Focado em Segurança**: Detecta informações sensíveis
- **Múltiplos Formatos de Saída**: Escolha entre texto simples, XML ou Markdown

## O que vem a seguir?

- [Guia de Instalação](installation.md): Diferentes maneiras de instalar o Repomix
- [Guia de Uso](usage.md): Aprenda sobre recursos básicos e avançados
- [Configuração](configuration.md): Personalize o Repomix para suas necessidades
- [Recursos de Segurança](security.md): Aprenda sobre verificações de segurança

## Comunidade

Junte-se à nossa [comunidade Discord](https://discord.gg/wNYzTwZFku) para:
- Obter ajuda com o Repomix
- Compartilhar suas experiências
- Sugerir novos recursos
- Conectar-se com outros usuários

## Suporte

Encontrou um bug ou precisa de ajuda?
- [Abra um problema no GitHub](https://github.com/yamadashy/repomix/issues)
- Junte-se ao nosso servidor Discord
- Verifique a [documentação](https://repomix.com)
</file>

<file path="website/client/src/pt-br/guide/installation.md">
# Instalação

## Usando npx (Nenhuma Instalação Necessária)

```bash
npx repomix
```

## Instalação Global

### npm
```bash
npm install -g repomix
```

### Yarn
```bash
yarn global add repomix
```

### Homebrew (macOS/Linux)
```bash
brew install repomix
```

## Instalação via Docker

Baixe e execute a imagem Docker:

```bash
# Diretório atual
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix

# Diretório específico
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory

# Repositório remoto
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote yamadashy/repomix
```

## Requisitos de Sistema

- Node.js: ≥ 18.0.0
- Git: Necessário para processamento de repositório remoto

## Verificação

Após a instalação, verifique se o Repomix está funcionando:

```bash
repomix --version
repomix --help
```
</file>

<file path="website/client/src/pt-br/guide/output.md">
# Output Formats

Repomix supports three output formats:
- Plain Text (default)
- XML
- Markdown

## Plain Text Format

```bash
repomix --style plain
```

Output structure:
```text
This file is a merged representation of the entire codebase...

================
File Summary
================
(Metadata and AI instructions)

================
Directory Structure
================
src/
  index.ts
  utils/
    helper.ts

================
Files
================

================
File: src/index.ts
================
// File contents here
```

## XML Format

```bash
repomix --style xml
```

XML format is optimized for AI processing:

```xml
This file is a merged representation of the entire codebase...

<file_summary>
(Metadata and AI instructions)
</file_summary>

<directory_structure>
src/
  index.ts
  utils/
    helper.ts
</directory_structure>

<files>
<file path="src/index.ts">
// File contents here
</file>
</files>
```

::: tip Why XML?
XML tags help AI models like Claude parse content more accurately. [Claude Documentation](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/use-xml-tags) recommends using XML tags for structured prompts.
:::

## Markdown Format

```bash
repomix --style markdown
```

Markdown provides readable formatting:

```markdown
This file is a merged representation of the entire codebase...

# File Summary
(Metadata and AI instructions)

# Directory Structure
```
src/
index.ts
utils/
helper.ts
```

# Files

## File: src/index.ts
```typescript
// File contents here
```
```

## Usage with AI Models

Each format works well with AI models, but consider:
- Use XML for Claude (best parsing accuracy)
- Use Markdown for general readability
- Use Plain Text for simplicity and universal compatibility

## Customization

Set default format in `repomix.config.json`:
```json
{
  "output": {
    "style": "xml",
    "filePath": "output.xml"
  }
}
```
</file>

<file path="website/client/src/pt-br/guide/prompt-examples.md">
# Exemplos de Prompts

## Revisão de Código

### Revisão de Arquitetura
```
Analise a arquitetura desta base de código:
1. Avalie a estrutura geral e os padrões
2. Identifique possíveis problemas de arquitetura
3. Sugira melhorias para escalabilidade
4. Observe áreas que seguem as melhores práticas

Concentre-se na manutenibilidade e modularidade.
```

### Revisão de Segurança
```
Realize uma revisão de segurança desta base de código:
1. Identifique possíveis vulnerabilidades de segurança
2. Verifique se há antipadrões de segurança comuns
3. Revise o tratamento de erros e a validação de entrada
4. Avalie a segurança das dependências

Forneça exemplos específicos e etapas de correção.
```

### Revisão de Desempenho
```
Revise a base de código para desempenho:
1. Identifique gargalos de desempenho
2. Verifique a utilização de recursos
3. Revise a eficiência algorítmica
4. Avalie as estratégias de cache

Inclua recomendações específicas de otimização.
```

## Geração de Documentação

### Documentação de API
```
Gere documentação abrangente da API:
1. Liste e descreva todos os endpoints públicos
2. Documente os formatos de solicitação/resposta
3. Inclua exemplos de uso
4. Observe quaisquer limitações ou restrições
```

### Guia do Desenvolvedor
```
Crie um guia do desenvolvedor cobrindo:
1. Instruções de configuração
2. Visão geral da estrutura do projeto
3. Fluxo de trabalho de desenvolvimento
4. Abordagem de teste
5. Etapas comuns de solução de problemas
```

### Documentação de Arquitetura
```
Documente a arquitetura do sistema:
1. Visão geral de alto nível
2. Interações de componentes
3. Diagramas de fluxo de dados
4. Decisões de design e justificativa
5. Restrições e limitações do sistema
```

## Análise e Melhoria

### Análise de Dependências
```
Analise as dependências do projeto:
1. Identifique pacotes desatualizados
2. Verifique se há vulnerabilidades de segurança
3. Sugira pacotes alternativos
4. Revise os padrões de uso de dependências

Inclua recomendações específicas de atualização.
```

### Cobertura de Testes
```
Revise a cobertura de testes:
1. Identifique componentes não testados
2. Sugira casos de teste adicionais
3. Revise a qualidade do teste
4. Recomende estratégias de teste
```

### Qualidade do Código
```
Avalie a qualidade do código e sugira melhorias:
1. Revise as convenções de nomenclatura
2. Verifique a organização do código
3. Avalie o tratamento de erros
4. Revise as práticas de comentários

Forneça exemplos específicos de padrões bons e problemáticos.
```

## Dicas para Obter Melhores Resultados

1. **Seja Específico**: Inclua objetivos claros e critérios de avaliação
2. **Defina o Contexto**: Especifique sua função e o nível de especialização necessário
3. **Formato da Solicitação**: Defina como você deseja que a resposta seja estruturada
4. **Priorize**: Indique quais aspectos são mais importantes

## Notas Específicas do Modelo

### Claude
- Use o formato de saída XML
- Coloque instruções importantes no final
- Especifique a estrutura da resposta

### ChatGPT
- Use o formato Markdown
- Divida grandes bases de código em seções
- Inclua prompts de função do sistema

### Gemini
- Funciona com todos os formatos
- Concentre-se em áreas específicas por solicitação
- Use análise passo a passo
</file>

<file path="website/client/src/pt-br/guide/remote-repository-processing.md">
# Processamento de Repositório Remoto

## Uso Básico

Processar repositórios públicos:
```bash
# Usando URL completo
repomix --remote https://github.com/user/repo

# Usando atalho do GitHub
repomix --remote user/repo
```

## Seleção de Branch e Commit

```bash
# Branch específico
repomix --remote user/repo --remote-branch main

# Tag
repomix --remote user/repo --remote-branch v1.0.0

# Hash do commit
repomix --remote user/repo --remote-branch 935b695
```

## Requisitos

- Git deve estar instalado
- Conexão com a internet
- Acesso de leitura ao repositório

## Controle de Saída

```bash
# Local de saída personalizado
repomix --remote user/repo -o custom-output.xml

# Com formato XML
repomix --remote user/repo --style xml

# Remover comentários
repomix --remote user/repo --remove-comments
```

## Uso com Docker

```bash
# Processar e enviar para o diretório atual
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo

# Enviar para um diretório específico
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo
```

## Problemas Comuns

### Problemas de Acesso
- Certifique-se de que o repositório é público
- Verifique a instalação do Git
- Verifique a conexão com a internet

### Repositórios Grandes
- Use `--include` para selecionar caminhos específicos
- Habilite `--remove-comments`
- Processe branches separadamente
</file>

<file path="website/client/src/pt-br/guide/security.md">
# Segurança

## Recurso de Verificação de Segurança

O Repomix usa o [Secretlint](https://github.com/secretlint/secretlint) para detectar informações confidenciais em seus arquivos:
- Chaves de API
- Tokens de acesso
- Credenciais
- Chaves privadas
- Variáveis de ambiente

## Configuração

As verificações de segurança são habilitadas por padrão.

Desativar via CLI:
```bash
repomix --no-security-check
```

Ou em `repomix.config.json`:
```json
{
  "security": {
    "enableSecurityCheck": false
  }
}
```

## Medidas de Segurança

1. **Exclusão de Arquivos Binários**: Arquivos binários não são incluídos na saída
2. **Compatível com Git**: Respeita os padrões do `.gitignore`
3. **Detecção Automatizada**: Verifica problemas de segurança comuns:
    - Credenciais da AWS
    - Strings de conexão de banco de dados
    - Tokens de autenticação
    - Chaves privadas

## Quando a Verificação de Segurança Encontra Problemas

Exemplo de saída:
```bash
🔍 Verificação de Segurança:
──────────────────
2 arquivo(s) suspeito(s) detectados e excluídos:
1. config/credentials.json
   - Chave de acesso da AWS encontrada
2. .env.local
   - Senha do banco de dados encontrada
```

## Melhores Práticas

1. Sempre revise a saída antes de compartilhar
2. Use `.repomixignore` para caminhos confidenciais
3. Mantenha as verificações de segurança habilitadas
4. Remova arquivos confidenciais do repositório

## Reportando Problemas de Segurança

Encontrou uma vulnerabilidade de segurança? Por favor:
1. Não abra uma issue pública
2. Envie um e-mail para: koukun0120@gmail.com
3. Ou use [Avisos de Segurança do GitHub](https://github.com/yamadashy/repomix/security/advisories/new)
</file>

<file path="website/client/src/pt-br/guide/usage.md">
# Uso Básico

## Início Rápido

Compacte todo o seu repositório:
```bash
repomix
```

## Casos de Uso Comuns

### Compactar Diretórios Específicos
```bash
repomix path/to/directory
```

### Incluir Arquivos Específicos
Use [glob patterns](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax):
```bash
repomix --include "src/**/*.ts,**/*.md"
```

### Excluir Arquivos
```bash
repomix --ignore "**/*.log,tmp/"
```

### Repositórios Remotos
```bash
# Usando URL do GitHub
repomix --remote https://github.com/user/repo

# Usando abreviação
repomix --remote user/repo

# Branch/tag/commit específico
repomix --remote user/repo --remote-branch main
repomix --remote user/repo --remote-branch 935b695
```

## Formatos de Saída

### Texto Simples (Padrão)
```bash
repomix --style plain
```

### XML
```bash
repomix --style xml
```

### Markdown
```bash
repomix --style markdown
```

## Opções Adicionais

### Remover Comentários
```bash
repomix --remove-comments
```

### Mostrar Números de Linha
```bash
repomix --output-show-line-numbers
```

### Copiar para a Área de Transferência
```bash
repomix --copy
```

### Desativar Verificação de Segurança
```bash
repomix --no-security-check
```

## Configuração

Inicializar arquivo de configuração:
```bash
repomix --init
```

Veja o [Guia de Configuração](/pt-br/guide/configuration) para opções detalhadas.
</file>

<file path="website/client/src/pt-br/index.md">
---
layout: home
title: Repomix
titleTemplate: Compacte seu código-fonte em formatos amigáveis para IA
aside: false
editLink: false

features:
  - icon: 🤖
    title: Otimizado para IA
    details: Formata seu código-fonte de uma maneira fácil para a IA entender e processar.

  - icon: ⚙️
    title: Consciente do Git
    details: Respeita automaticamente seus arquivos .gitignore.

  - icon: 🛡️
    title: Focado na Segurança
    details: Incorpora o Secretlint para verificações de segurança robustas para detectar e prevenir a inclusão de informações confidenciais.

  - icon: 📊
    title: Contagem de Tokens
    details: Fornece contagens de tokens para cada arquivo e para todo o repositório, útil para limites de contexto de LLM.

---

<div class="cli-section">

## Início Rápido

Depois de gerar um arquivo compactado (`repomix-output.txt`) usando o Repomix, você pode enviá-lo para um assistente de IA com um prompt como:

```
Este arquivo contém todos os arquivos do repositório combinados em um.
Eu quero refatorar o código, então, por favor, revise-o primeiro.
```

A IA analisará todo o seu código-fonte e fornecerá insights abrangentes:

![Repomix File Usage 1](/images/docs/repomix-file-usage-1.png)

Ao discutir mudanças específicas, a IA pode ajudar a gerar código. Com recursos como o Artifacts do Claude, você pode até receber vários arquivos interdependentes:

![Repomix File Usage 2](/images/docs/repomix-file-usage-2.png)

Feliz codificação! 🚀

## Guia do Usuário Avançado

Para usuários avançados que precisam de mais controle, o Repomix oferece extensas opções de personalização através de sua interface CLI.

### Início Rápido

Você pode experimentar o Repomix instantaneamente no diretório do seu projeto sem instalação:

```bash
npx repomix
```

Ou instale globalmente para uso repetido:

```bash
# Instalar usando npm
npm install -g repomix

# Alternativamente usando yarn
yarn global add repomix

# Alternativamente usando Homebrew (macOS/Linux)
brew install repomix

# Então execute em qualquer diretório de projeto
repomix
```

É isso! O Repomix irá gerar um arquivo `repomix-output.txt` no seu diretório atual, contendo todo o seu repositório em um formato amigável para IA.

### Uso

Para compactar todo o seu repositório:

```bash
repomix
```

Para compactar um diretório específico:

```bash
repomix path/to/directory
```

Para compactar arquivos ou diretórios específicos usando [glob patterns](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax):

```bash
repomix --include "src/**/*.ts,**/*.md"
```

Para excluir arquivos ou diretórios específicos:

```bash
repomix --ignore "**/*.log,tmp/"
```

Para compactar um repositório remoto:
```bash
repomix --remote https://github.com/yamadashy/repomix

# Você também pode usar o atalho do GitHub:
repomix --remote yamadashy/repomix

# Você pode especificar o nome do branch, tag ou hash do commit:
repomix --remote https://github.com/yamadashy/repomix --remote-branch main

# Ou usar um hash de commit específico:
repomix --remote https://github.com/yamadashy/repomix --remote-branch 935b695
```

Para inicializar um novo arquivo de configuração (`repomix.config.json`):

```bash
repomix --init
```

Depois de gerar o arquivo compactado, você pode usá-lo com ferramentas de IA Generativa como Claude, ChatGPT e Gemini.

#### Uso do Docker

Você também pode executar o Repomix usando o Docker 🐳
Isso é útil se você quiser executar o Repomix em um ambiente isolado ou preferir usar contêineres.

Uso básico (diretório atual):

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

Para compactar um diretório específico:
```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory
```

Processar um repositório remoto e enviar para um diretório `output`:

```bash
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote https://github.com/yamadashy/repomix
```

### Formatos de Saída

Escolha seu formato de saída preferido:

```bash
# Formato XML (padrão)
repomix --style xml

# Formato Markdown
repomix --style markdown

# Formato de texto simples
repomix --style plain
```

### Customização

Crie um `repomix.config.json` para configurações persistentes:

```json
{
  "output": {
    "style": "markdown",
    "filePath": "custom-output.md",
    "removeComments": true,
    "showLineNumbers": true,
    "topFilesLength": 10
  },
  "ignore": {
    "customPatterns": ["*.test.ts", "docs/**"]
  }
}
```

### Mais Exemplos
::: tip
💡 Confira nosso [repositório GitHub](https://github.com/yamadashy/repomix) para documentação completa e mais exemplos!
:::

</div>
</file>

<file path="website/client/src/public/images/repomix-logo.svg">
<?xml version="1.0" encoding="utf-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="96.259 93.171 300 300" xmlns:bx="https://boxy-svg.com">
  <g id="group-1" transform="matrix(1.160932, 0, 0, 1.160932, 97.635941, 94.725143)" style="">
    <path style="fill-rule: nonzero; fill-opacity: 1; stroke-width: 2; fill: rgb(234, 127, 58);" d="M 128.03 -1.486 L 21.879 65.349 L 21.848 190.25 L 127.979 256.927 L 234.2 190.27 L 234.197 65.463 L 128.03 -1.486 Z M 208.832 70.323 L 127.984 121.129 L 47.173 70.323 L 128.144 19.57 L 208.832 70.323 Z M 39.669 86.367 L 119.188 136.415 L 119.255 230.529 L 39.637 180.386 L 39.669 86.367 Z M 136.896 230.506 L 136.887 136.575 L 216.469 86.192 L 216.417 180.46 L 136.896 230.506 Z M 136.622 230.849"/>
  </g>
</svg>
</file>

<file path="website/client/src/zh-cn/guide/development/index.md">
# 参与 Repomix 开发

## 快速开始

```bash
git clone https://github.com/yamadashy/repomix.git
cd repomix
npm install
```

## 开发命令

```bash
# 运行 CLI
npm run cli-run

# 运行测试
npm run test
npm run test-coverage

# 代码检查
npm run lint
```

## 代码风格

- 使用 [Biome](https://biomejs.dev/) 进行代码检查和格式化
- 使用依赖注入以提高可测试性
- 保持文件不超过 250 行
- 为新功能添加测试用例

## Pull Request 提交指南

1. 运行所有测试
2. 通过代码检查
3. 更新文档
4. 遵循现有代码风格

## 需要帮助？

- [提交 Issue](https://github.com/yamadashy/repomix/issues)
- [加入 Discord](https://discord.gg/wNYzTwZFku)
</file>

<file path="website/client/src/zh-cn/guide/development/setup.md">
# 开发环境搭建

## 前提条件

- Node.js ≥ 18.0.0
- Git
- npm

## 本地开发

```bash
# 克隆仓库
git clone https://github.com/yamadashy/repomix.git
cd repomix

# 安装依赖
npm install

# 运行 CLI
npm run cli-run
```

## Docker 开发环境

```bash
# 构建镜像
docker build -t repomix .

# 运行容器
docker run -v ./:/app -it --rm repomix
```

## 项目结构

```
src/
├── cli/          # CLI 实现
├── config/       # 配置处理
├── core/         # 核心功能
└── shared/       # 共享工具
```

## 测试

```bash
# 运行测试
npm run test

# 测试覆盖率
npm run test-coverage

# 代码检查
npm run lint-biome
npm run lint-ts
npm run lint-secretlint
```

## 发布流程

1. 更新版本
```bash
npm version patch  # 或 minor/major
```

2. 运行测试和构建
```bash
npm run test-coverage
npm run build
```

3. 发布
```bash
npm publish
```
</file>

<file path="website/client/src/zh-cn/guide/tips/best-practices.md">
# AI 辅助开发最佳实践：从实践经验谈起

虽然我还没有完成一个大型的 AI 辅助开发项目，但我想分享一下到目前为止从与 AI 合作开发中学到的经验。

## 基本开发方法

在与 AI 合作时，试图一次性实现所有功能可能会导致意外问题和项目停滞。因此，从核心功能开始，一步一步稳扎稳打地构建每个功能是更有效的方法。

### 现有代码的重要性

这种方法之所以有效，是因为通过核心功能的实现，你可以将你理想中的设计和编码风格具体化为实际代码。向 AI 传达项目愿景的最有效方式就是通过反映你的标准和偏好的代码本身。

从核心功能开始，确保每个功能在进入下一个功能之前都能正常工作，这样整个项目就能保持一致性，使 AI 更容易生成更合适的代码。

## 模块化方法

将代码分解成更小的模块至关重要。根据经验，将文件限制在 250 行左右的代码使得向 AI 提供清晰的指示更容易，并使试错过程更有效。虽然令牌计数会是更准确的指标，但对人类开发者来说，行数更容易判断，所以我们使用行数作为参考。

这不仅仅是关于前端、后端和数据库等大单元的分离，而是关于更精细层面的功能划分。例如，在一个功能内部，也要将验证、错误处理等具体功能分离成独立模块。

当然，大单元的分离也很重要，逐步实施模块化方法不仅让指令更清晰，也让 AI 能生成更合适的代码。这种方法不仅对 AI，对人类开发者来说也是有效的。

## 通过测试确保质量

我认为测试在 AI 辅助开发中尤为重要。测试不仅作为质量保证手段，还作为清晰展示代码意图的文档。当要求 AI 实现新功能时，现有的测试代码有效地充当了规范文档。

测试也是验证 AI 生成代码正确性的绝佳工具。例如，当让 AI 为某个模块实现新功能时，预先编写测试用例可以客观评估生成的代码是否符合预期。这与测试驱动开发（TDD）的理念高度契合，在与 AI 协作时特别有效。

## 规划与实现的平衡

在实现大规模功能之前，建议先与 AI 讨论计划。整理需求并考虑架构可以使后续实现更顺畅。先整理需求，然后在新的对话中进行实现是个好方法。

此外，AI 的输出必须经过人工审查，并在必要时进行调整。虽然 AI 输出的质量通常处于中等水平，但与从头开始编写代码相比，仍然可以提高开发速度。

## 结语

通过实践这些方法，你可以充分发挥 AI 的优势，同时构建一个连贯的、高质量的代码库。即使项目规模增长，每个部分都能保持清晰定义和易于管理的状态。
</file>

<file path="website/client/src/zh-cn/guide/command-line-options.md">
# 命令行选项

## 基本选项

```bash
repomix [directory]  # 处理指定目录（默认为当前目录 "."）
```

## 输出选项

| 选项 | 说明 | 默认值 |
|--------|-------------|---------|
| `-o, --output <file>` | 输出文件名 | `repomix-output.txt` |
| `--style <type>` | 输出格式（`plain`, `xml`, `markdown`） | `plain` |
| `--output-show-line-numbers` | 添加行号 | `false` |
| `--copy` | 复制到剪贴板 | `false` |
| `--no-file-summary` | 禁用文件概要 | `true` |
| `--no-directory-structure` | 禁用目录结构 | `true` |
| `--remove-comments` | 移除注释 | `false` |
| `--remove-empty-lines` | 移除空行 | `false` |

## 过滤选项

| 选项 | 说明 |
|--------|-------------|
| `--include <patterns>` | 包含模式（逗号分隔） |
| `-i, --ignore <patterns>` | 忽略模式（逗号分隔） |

## 远程仓库

| 选项 | 说明 |
|--------|-------------|
| `--remote <url>` | 处理远程仓库 |
| `--remote-branch <name>` | 指定分支/标签/提交 |

## 配置

| 选项 | 说明 |
|--------|-------------|
| `-c, --config <path>` | 自定义配置文件路径 |
| `--init` | 创建配置文件 |
| `--global` | 使用全局配置 |

## 安全

| 选项 | 说明 | 默认值 |
|--------|-------------|---------|
| `--no-security-check` | 禁用安全检查 | `true` |

## 其他选项

| 选项 | 说明 |
|--------|-------------|
| `-v, --version` | 显示版本 |
| `--verbose` | 启用详细日志 |
| `--top-files-len <number>` | 显示的顶部文件数量 | `5` |

## 使用示例

```bash
# 基本用法
repomix

# 自定义输出
repomix -o output.xml --style xml

# 处理特定文件
repomix --include "src/**/*.ts" --ignore "**/*.test.ts"

# 远程仓库
repomix --remote user/repo --remote-branch main
```
</file>

<file path="website/client/src/zh-cn/guide/comment-removal.md">
# 注释移除

Repomix 可以在生成输出文件时自动移除代码中的注释。这有助于减少干扰，让代码更加简洁。

## 使用方法

要启用注释移除，在 `repomix.config.json` 中将 `removeComments` 选项设置为 `true`：

```json
{
  "output": {
    "removeComments": true
  }
}
```

## 支持的语言

Repomix 支持移除多种编程语言的注释，包括：

- JavaScript/TypeScript (`//`, `/* */`)
- Python (`#`, `"""`, `'''`)
- Java (`//`, `/* */`)
- C/C++ (`//`, `/* */`)
- HTML (`<!-- -->`)
- CSS (`/* */`)
- 以及更多语言...

## 示例

以下是 JavaScript 代码示例：

```javascript
// 这是单行注释
function test() {
  /* 这是
     多行注释 */
  return true;
}
```

启用注释移除后，输出将变为：

```javascript
function test() {
  return true;
}
```

## 注意事项

- 注释移除在其他处理步骤（如行号添加）之前执行
- 某些注释，例如 JSDoc 注释，可能会根据语言和上下文保留
- 如果你需要保留某些重要注释，请考虑使用其他方式记录这些信息，例如使用自定义指令

## 建议用法

1. **选择性使用**：
   - 对于需要向 AI 展示实现细节的代码，保留注释
   - 对于主要关注代码结构的分析，移除注释

2. **配合其他功能**：
   - 与 `--remove-empty-lines` 选项组合使用，获得更简洁的输出
   - 使用自定义指令提供额外的上下文信息

3. **性能考虑**：
   - 移除注释可以减少输出文件大小
   - 对于大型代码库特别有用
</file>

<file path="website/client/src/zh-cn/guide/configuration.md">
# 配置

## 快速开始

创建配置文件：
```bash
repomix --init
```

## 配置文件

`repomix.config.json`：
```json
{
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "headerText": "自定义头部文本",
    "instructionFilePath": "repomix-instruction.md",
    "fileSummary": true,
    "directoryStructure": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "includeEmptyDirectories": false
  },
  "include": ["**/*"],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": ["tmp/", "*.log"]
  },
  "security": {
    "enableSecurityCheck": true
  }
}
```

## 全局配置

创建全局配置：
```bash
repomix --init --global
```

配置文件位置：
- Windows: `%LOCALAPPDATA%\\Repomix\\repomix.config.json`
- macOS/Linux: `~/.config/repomix/repomix.config.json`

## 忽略模式

优先级顺序：
1. 命令行选项（`--ignore`）
2. .repomixignore 文件
3. .gitignore 文件
4. 默认模式

`.repomixignore` 示例：
```text
# 缓存目录
.cache/
tmp/

# 构建输出
dist/
build/

# 日志文件
*.log
```

## 默认忽略模式

内置的常用模式：
```text
node_modules/**
.git/**
coverage/**
dist/**
```

完整列表：[defaultIgnore.ts](https://github.com/yamadashy/repomix/blob/main/src/config/defaultIgnore.ts)
</file>

<file path="website/client/src/zh-cn/guide/custom-instructions.md">
# 自定义指令

Repomix 允许你提供自定义指令，这些指令将被包含在输出文件中。这对于为处理代码库的 AI 系统提供上下文或特定指导非常有用。

## 使用方法

要包含自定义指令，请在仓库根目录创建一个 markdown 文件（例如 `repomix-instruction.md`）。然后，在 `repomix.config.json` 中指定该文件的路径：

```json
{
  "output": {
    "instructionFilePath": "repomix-instruction.md"
  }
}
```

该文件的内容将在输出中的"Instruction"部分中显示。

## 示例

```markdown
# 仓库指令

这个仓库包含了 Repomix 工具的源代码。在分析代码时请遵循以下指导原则：

1. 重点关注 `src/core` 目录中的核心功能
2. 特别注意 `src/core/security` 中的安全检查
3. 忽略 `tests` 目录中的文件

## 代码规范
- 遵循 TypeScript 最佳实践
- 确保所有公共 API 都有适当的文档
- 使用依赖注入模式以便于测试

## 安全考虑
- 确保所有用户输入都经过适当验证
- 避免在日志中记录敏感信息
- 使用安全的依赖版本
```

这将在输出中生成以下部分：

```xml
<instruction>
# 仓库指令

这个仓库包含了 Repomix 工具的源代码。在分析代码时请遵循以下指导原则：

1. 重点关注 `src/core` 目录中的核心功能
2. 特别注意 `src/core/security` 中的安全检查
3. 忽略 `tests` 目录中的文件

## 代码规范
- 遵循 TypeScript 最佳实践
- 确保所有公共 API 都有适当的文档
- 使用依赖注入模式以便于测试

## 安全考虑
- 确保所有用户输入都经过适当验证
- 避免在日志中记录敏感信息
- 使用安全的依赖版本
</instruction>
```

## 最佳实践

1. **保持简洁明确**：指令应该简短但详细
2. **提供具体示例**：在适当的情况下添加代码示例
3. **设置优先级**：将最重要的指令放在前面
4. **包含上下文**：提供项目背景和重要考虑因素
5. **结构化内容**：使用标题和列表使指令易于阅读

## 注意事项

- 避免在指令中包含敏感信息
- 定期更新指令以反映项目的变化
- 确保指令与项目的其他文档保持一致
- 使用清晰的层次结构组织内容
</file>

<file path="website/client/src/zh-cn/guide/index.md">
# Repomix 入门指南

Repomix 是一个将代码库打包成单个 AI 友好文件的工具。它专为帮助你将代码提供给大型语言模型（如 Claude、ChatGPT 和 Gemini）而设计。

## 快速开始

在你的项目目录中运行以下命令：

```bash
npx repomix
```

就这么简单！你会在当前目录中找到一个 `repomix-output.txt` 文件，其中包含了以 AI 友好格式整理的整个代码库。

然后，你可以将此文件发送给 AI 助手，并附上类似这样的提示：

```
这个文件包含了仓库中所有文件的合并内容。
我想重构代码，请先帮我审查一下。
```

AI 将分析你的整个代码库并提供全面的见解：

![Repomix 使用示例1](/images/docs/repomix-file-usage-1.png)

在讨论具体修改时，AI 可以帮助生成代码。通过像 Claude 的 Artifacts 这样的功能，你甚至可以一次性接收多个相互依赖的文件：

![Repomix 使用示例2](/images/docs/repomix-file-usage-2.png)

祝你编码愉快！🚀

## 核心功能

- **AI 优化**：以 AI 易于理解的格式整理代码库
- **令牌计数**：为 LLM 上下文限制提供令牌使用统计
- **Git 感知**：自动识别并遵循 .gitignore 文件
- **注重安全**：使用 Secretlint 进行敏感信息检测
- **多种输出格式**：可选纯文本、XML 或 Markdown 格式

## 下一步

- [安装指南](installation.md)：了解安装 Repomix 的不同方式
- [使用指南](usage.md)：学习基本和高级功能
- [配置](configuration.md)：根据需求自定义 Repomix
- [安全功能](security.md)：了解安全检查详情

## 社区

加入我们的 [Discord 社区](https://discord.gg/wNYzTwZFku)：
- 获取 Repomix 使用帮助
- 分享你的使用经验
- 提出新功能建议
- 与其他用户交流

## 支持

发现问题或需要帮助？
- [在 GitHub 上提交问题](https://github.com/yamadashy/repomix/issues)
- 加入 Discord 服务器
- 查看[文档](https://repomix.com)
</file>

<file path="website/client/src/zh-cn/guide/installation.md">
# 安装

## 使用 npx（无需安装）

```bash
npx repomix
```

## 全局安装

### npm 安装
```bash
npm install -g repomix
```

### Yarn 安装
```bash
yarn global add repomix
```

### Homebrew 安装（macOS/Linux）
```bash
brew install repomix
```

## Docker 安装

使用 Docker 是最便捷的方式之一，可以避免环境配置问题。以下是具体步骤：

```bash
# 处理当前目录
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix

# 处理指定目录
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory

# 处理远程仓库
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote yamadashy/repomix
```

## 系统要求

- Node.js: ≥ 18.0.0
- Git: 处理远程仓库时需要

## 验证安装

安装完成后，可以通过以下命令验证 Repomix 是否正常工作：

```bash
repomix --version
repomix --help
```
</file>

<file path="website/client/src/zh-cn/guide/output.md">
# 输出格式

Repomix 支持三种输出格式：
- 纯文本（默认）
- XML
- Markdown

## 纯文本格式

```bash
repomix --style plain
```

输出结构：
```text
本文件是整个代码库的合并表示形式...

================
文件概要
================
（元数据和 AI 指令）

================
目录结构
================
src/
  index.ts
  utils/
    helper.ts

================
文件
================

================
File: src/index.ts
================
// 文件内容
```

## XML 格式

```bash
repomix --style xml
```

XML 格式针对 AI 处理进行了优化：

```xml
本文件是整个代码库的合并表示形式...

<file_summary>
（元数据和 AI 指令）
</file_summary>

<directory_structure>
src/
  index.ts
  utils/
    helper.ts
</directory_structure>

<files>
<file path="src/index.ts">
// 文件内容
</file>
</files>
```

::: tip 为什么选择 XML？
XML 标签有助于像 Claude 这样的 AI 模型更准确地解析内容。[Claude 官方文档](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/use-xml-tags)推荐使用 XML 标签来构建结构化提示。
:::

## Markdown 格式

```bash
repomix --style markdown
```

Markdown 提供了易读的格式：

```markdown
本文件是整个代码库的合并表示形式...

# 文件概要
（元数据和 AI 指令）

# 目录结构
```
src/
index.ts
utils/
helper.ts
```

# 文件

## File: src/index.ts
```typescript
// 文件内容
```
```

## 在 AI 模型中的使用

每种格式都能在 AI 模型中正常工作，但需要考虑以下几点：
- 对 Claude 使用 XML（解析最准确）
- 对一般可读性使用 Markdown
- 对简单性和通用兼容性使用纯文本

## 自定义设置

在 `repomix.config.json` 中设置默认格式：
```json
{
  "output": {
    "style": "xml",
    "filePath": "output.xml"
  }
}
```
</file>

<file path="website/client/src/zh-cn/guide/prompt-examples.md">
# 提示示例

## 代码评审

### 架构评审
```
分析此代码库的架构：
1. 评估整体结构和模式
2. 识别潜在的架构问题
3. 提出改进可扩展性的建议
4. 标注遵循最佳实践的部分

重点关注可维护性和模块化。
```

### 安全性评审
```
对此代码库进行安全性评审：
1. 识别潜在的安全漏洞
2. 检查常见的安全反模式
3. 评审错误处理和输入验证
4. 评估依赖项的安全性

请提供具体示例和修复步骤。
```

### 性能评审
```
从性能角度评审代码库：
1. 识别性能瓶颈
2. 检查资源使用情况
3. 评审算法效率
4. 评估缓存策略

包含具体的优化建议。
```

## 文档生成

### API 文档
```
生成全面的 API 文档：
1. 列出并描述所有公共端点
2. 记录请求/响应格式
3. 包含使用示例
4. 说明限制和约束
```

### 开发者指南
```
创建包含以下内容的开发者指南：
1. 环境搭建说明
2. 项目结构概览
3. 开发工作流程
4. 测试方法
5. 常见问题排查步骤
```

### 架构文档
```
记录系统架构：
1. 高层概述
2. 组件交互
3. 数据流程图
4. 设计决策及理由
5. 系统限制和约束
```

## 分析与改进

### 依赖项分析
```
分析项目依赖：
1. 识别过时的包
2. 检查安全漏洞
3. 建议替代包
4. 评审依赖使用模式

包含具体的升级建议。
```

### 测试覆盖率
```
评审测试覆盖率：
1. 识别未测试的组件
2. 建议额外的测试用例
3. 评审测试质量
4. 推荐测试策略
```

### 代码质量
```
评估代码质量并提出改进建议：
1. 评审命名规范
2. 检查代码组织
3. 评估错误处理
4. 评审注释实践

提供具体的良好和问题模式示例。
```

## 获得更好结果的技巧

1. **明确具体**：包含清晰的目标和评估标准
2. **设置上下文**：说明你的角色和所需的专业水平
3. **请求格式**：定义期望的响应结构
4. **设置优先级**：指出哪些方面最重要

## 模型特定说明

### Claude
- 使用 XML 输出格式
- 将重要指令放在最后
- 指定响应结构

### ChatGPT
- 使用 Markdown 格式
- 将大型代码库分成小节
- 包含系统角色提示

### Gemini
- 适用于所有格式
- 每次请求专注于特定领域
- 使用逐步分析
</file>

<file path="website/client/src/zh-cn/guide/remote-repository-processing.md">
# 远程仓库处理

## 基本用法

处理公共仓库：
```bash
# 使用完整 URL
repomix --remote https://github.com/user/repo

# 使用 GitHub 简写
repomix --remote user/repo
```

## 分支和提交选择

```bash
# 指定分支
repomix --remote user/repo --remote-branch main

# 指定标签
repomix --remote user/repo --remote-branch v1.0.0

# 指定提交哈希
repomix --remote user/repo --remote-branch 935b695
```

## 系统要求

- 必须安装 Git
- 需要网络连接
- 需要仓库的读取权限

## 输出控制

```bash
# 自定义输出位置
repomix --remote user/repo -o custom-output.xml

# 使用 XML 格式
repomix --remote user/repo --style xml

# 移除注释
repomix --remote user/repo --remove-comments
```

## Docker 使用方法

```bash
# 在当前目录处理并输出
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo

# 输出到指定目录
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo
```

## 常见问题

### 访问问题
- 确保仓库是公开的
- 检查 Git 是否已安装
- 验证网络连接

### 大型仓库处理
- 使用 `--include` 选择特定路径
- 启用 `--remove-comments`
- 分开处理不同分支
</file>

<file path="website/client/src/zh-cn/guide/security.md">
# 安全性

## 安全检查功能

Repomix 使用 [Secretlint](https://github.com/secretlint/secretlint) 检测文件中的敏感信息：
- API 密钥
- 访问令牌
- 认证凭证
- 私钥
- 环境变量

## 配置

安全检查默认启用。

通过命令行禁用：
```bash
repomix --no-security-check
```

或在 `repomix.config.json` 中配置：
```json
{
  "security": {
    "enableSecurityCheck": false
  }
}
```

## 安全措施

1. **二进制文件排除**：输出中不包含二进制文件
2. **Git 感知**：遵循 `.gitignore` 模式
3. **自动检测**：扫描常见安全问题：
    - AWS 凭证
    - 数据库连接字符串
    - 认证令牌
    - 私钥

## 安全检查发现问题时

输出示例：
```bash
🔍 Security Check:
──────────────────
2 suspicious file(s) detected and excluded:
1. config/credentials.json
   - Found AWS access key
2. .env.local
   - Found database password
```

## 最佳实践

1. 分享前务必检查输出内容
2. 使用 `.repomixignore` 排除敏感路径
3. 保持安全检查功能启用
4. 从仓库中移除敏感文件

## 报告安全问题

如果发现安全漏洞，请：
1. 不要创建公开的 Issue
2. 发送邮件至：koukun0120@gmail.com
3. 或使用 [GitHub 安全公告](https://github.com/yamadashy/repomix/security/advisories/new)
</file>

<file path="website/client/src/zh-cn/guide/usage.md">
# 基本用法

## 快速开始

打包整个仓库：
```bash
repomix
```

## 常见使用场景

### 打包指定目录
```bash
repomix path/to/directory
```

### 包含特定文件
使用 [glob 模式](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)：
```bash
repomix --include "src/**/*.ts,**/*.md"
```

### 排除文件
```bash
repomix --ignore "**/*.log,tmp/"
```

### 处理远程仓库
```bash
# 使用 GitHub URL
repomix --remote https://github.com/user/repo

# 使用简写形式
repomix --remote user/repo

# 指定分支/标签/提交
repomix --remote user/repo --remote-branch main
repomix --remote user/repo --remote-branch 935b695
```

## 输出格式

### 纯文本（默认）
```bash
repomix --style plain
```

### XML
```bash
repomix --style xml
```

### Markdown
```bash
repomix --style markdown
```

## 其他选项

### 移除注释
```bash
repomix --remove-comments
```

### 显示行号
```bash
repomix --output-show-line-numbers
```

### 复制到剪贴板
```bash
repomix --copy
```

### 禁用安全检查
```bash
repomix --no-security-check
```

## 配置

初始化配置文件：
```bash
repomix --init
```

更多详细配置选项请参阅[配置指南](/zh-cn/guide/configuration)。
</file>

<file path="website/client/src/zh-cn/index.md">
---
layout: home
title: Repomix
titleTemplate: 将代码库打包成AI友好的格式
aside: false
editLink: false

features:
  - icon: 🤖
    title: AI 优化
    details: 以 AI 易于理解和处理的方式格式化代码库。

  - icon: ⚙️
    title: Git 感知
    details: 自动识别并尊重您的 .gitignore 文件。

  - icon: 🛡️
    title: 注重安全
    details: 集成 Secretlint 进行强大的安全检查，检测并防止敏感信息的泄露。

  - icon: 📊
    title: 令牌计数
    details: 提供每个文件和整个代码库的令牌计数，便于控制 LLM 上下文限制。

---

<div class="cli-section">

## 快速开始

使用 Repomix 生成打包文件（`repomix-output.txt`）后，您可以将其发送给 AI 助手，并附上这样的提示：

```
此文件包含了仓库中所有文件的合并内容。
我想重构代码，请先帮我审查一下。
```

AI 将分析您的整个代码库并提供全面的见解：

![Repomix 使用示例1](/images/docs/repomix-file-usage-1.png)

在讨论具体修改时，AI 可以帮助生成代码。通过像 Claude 的 Artifacts 这样的功能，您甚至可以一次性接收多个相互依赖的文件：

![Repomix 使用示例2](/images/docs/repomix-file-usage-2.png)

祝您编码愉快！🚀



## 进阶使用指南

对于需要更多控制的高级用户，Repomix 通过其 CLI 界面提供了广泛的自定义选项。

### 快速上手

您可以在项目目录中无需安装即可立即尝试 Repomix：

```bash
npx repomix
```

或者全局安装以便重复使用：

```bash
# 使用 npm 安装
npm install -g repomix

# 或使用 yarn 安装
yarn global add repomix

# 或使用 Homebrew 安装（macOS/Linux）
brew install repomix

# 然后在任意项目目录中运行
repomix
```

就是这么简单！Repomix 将在您的当前目录中生成一个 `repomix-output.txt` 文件，其中包含了以 AI 友好格式整理的整个代码库。



### 基本用法

打包整个代码库：

```bash
repomix
```

打包特定目录：

```bash
repomix path/to/directory
```

使用 [glob 模式](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)打包特定文件：

```bash
repomix --include "src/**/*.ts,**/*.md"
```

排除特定文件：

```bash
repomix --ignore "**/*.log,tmp/"
```

处理远程仓库：
```bash
repomix --remote https://github.com/yamadashy/repomix

# 也可以使用 GitHub 简写形式：
repomix --remote yamadashy/repomix

# 可以指定分支名称、标签或提交哈希：
repomix --remote https://github.com/yamadashy/repomix --remote-branch main

# 或使用特定的提交哈希：
repomix --remote https://github.com/yamadashy/repomix --remote-branch 935b695
```

初始化配置文件（`repomix.config.json`）：

```bash
repomix --init
```

生成打包文件后，您可以将其用于 Claude、ChatGPT、Gemini 等生成式 AI 工具。

#### Docker 使用方法

您也可以使用 Docker 运行 Repomix 🐳  
如果您想在隔离环境中运行 Repomix 或更偏好使用容器，这是一个很好的选择。

基本用法（当前目录）：

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

打包特定目录：
```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory
```

处理远程仓库并输出到 `output` 目录：

```bash
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote https://github.com/yamadashy/repomix
```

### 输出格式

选择您偏好的输出格式：

```bash
# XML 格式（默认）
repomix --style xml

# Markdown 格式
repomix --style markdown

# 纯文本格式
repomix --style plain
```

### 自定义设置

创建 `repomix.config.json` 进行持久化设置：

```json
{
  "output": {
    "style": "markdown",
    "filePath": "custom-output.md",
    "removeComments": true,
    "showLineNumbers": true,
    "topFilesLength": 10
  },
  "ignore": {
    "customPatterns": ["*.test.ts", "docs/**"]
  }
}
```

### 更多示例
::: tip
💡 查看我们的 [GitHub 仓库](https://github.com/yamadashy/repomix)获取完整文档和更多示例！
:::

</div>
</file>

<file path="website/client/.gitignore">
.vitepress/cache
.vitepress/dist
node_modules
</file>

<file path="website/client/.tool-versions">
nodejs 23.6.0
</file>

<file path="website/client/Dockerfile">
FROM node:23-alpine

RUN apk add --no-cache git

WORKDIR /app

COPY package*.json ./

RUN npm i

COPY . .

EXPOSE 5173

CMD ["npm", "run", "docs:dev"]
</file>

<file path="website/client/package.json">
{
  "private": true,
  "type": "module",
  "scripts": {
    "docs:dev": "vitepress dev",
    "docs:build": "vitepress build",
    "docs:preview": "vitepress preview"
  },
  "devDependencies": {
    "vitepress": "^1.5.0"
  },
  "dependencies": {
    "@types/gtag.js": "^0.0.20",
    "lucide-vue-next": "^0.471.0"
  }
}
</file>

<file path="website/client/tsconfig.json">
{
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "jsx": "preserve",
    "sourceMap": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "esModuleInterop": true,
    "lib": ["ESNext", "DOM"],
    "skipLibCheck": true,
    "noEmit": true,
    "baseUrl": ".",
    "types": ["vite/client", "vitepress/client"]
  },
  "include": [".vitepress/**/*.ts", ".vitepress/**/*.d.ts", ".vitepress/**/*.tsx", ".vitepress/**/*.vue"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="website/client/tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": [".vitepress/config.ts", ".vitepress/config/**/*", ".vitepress/theme/**/*"]
}
</file>

<file path="website/server/src/schemas/request.ts">
import { isValidRemoteValue } from 'repomix';
import { z } from 'zod';

// Regular expression to validate ignore patterns
// Allowed characters: alphanumeric, *, ?, /, -, _, ., space, comma
const ignorePatternRegex = /^[a-zA-Z0-9*?\/\-_., ]*$/;

export const packOptionsSchema = z
  .object({
    removeComments: z.boolean().optional(),
    removeEmptyLines: z.boolean().optional(),
    showLineNumbers: z.boolean().optional(),
    fileSummary: z.boolean().optional(),
    directoryStructure: z.boolean().optional(),
    includePatterns: z
      .string()
      .max(1000, 'Include patterns too long')
      .optional()
      .transform((val) => val?.trim()),
    ignorePatterns: z
      .string()
      .regex(ignorePatternRegex, 'Invalid characters in ignore patterns')
      .max(1000, 'Ignore patterns too long')
      .optional()
      .transform((val) => val?.trim()),
    outputParsable: z.boolean().optional(),
  })
  .strict();

export const packRequestSchema = z
  .object({
    url: z
      .string()
      .min(1, 'Repository URL is required')
      .max(200, 'Repository URL is too long')
      .transform((val) => val.trim())
      .refine((val) => isValidRemoteValue(val), { message: 'Invalid repository URL' }),
    format: z.enum(['xml', 'markdown', 'plain']),
    options: packOptionsSchema,
  })
  .strict();

export type PackRequest = z.infer<typeof packRequestSchema>;
</file>

<file path="website/server/src/utils/cache.ts">
import pako from 'pako';
import type { PackOptions, PackResult } from '../types.js';

interface CacheEntry<T> {
  value: Uint8Array; // Compressed data
  timestamp: number;
}

export class RequestCache<T> {
  private cache: Map<string, CacheEntry<T>> = new Map();
  private readonly ttl: number;

  constructor(ttlInSeconds = 60) {
    this.ttl = ttlInSeconds * 1000;

    // Set up periodic cache cleanup
    setInterval(() => this.cleanup(), ttlInSeconds * 1000);
  }

  get(key: string): T | undefined {
    const entry = this.cache.get(key);
    if (!entry) {
      return undefined;
    }

    const now = Date.now();
    if (now - entry.timestamp > this.ttl) {
      this.cache.delete(key);
      return undefined;
    }

    try {
      // Decompress and return the data
      const decompressedData = pako.inflate(entry.value, { to: 'string' });
      return JSON.parse(decompressedData);
    } catch (error) {
      console.error('Error decompressing cache entry:', error);
      this.cache.delete(key);
      return undefined;
    }
  }

  set(key: string, value: T): void {
    try {
      // Convert data to JSON string and compress
      const jsonString = JSON.stringify(value);
      const compressedData = pako.deflate(jsonString);

      this.cache.set(key, {
        value: compressedData,
        timestamp: Date.now(),
      });
    } catch (error) {
      console.error('Error compressing cache entry:', error);
    }
  }

  // Remove expired entries from cache
  cleanup(): void {
    const now = Date.now();
    for (const [key, entry] of this.cache.entries()) {
      if (now - entry.timestamp > this.ttl) {
        this.cache.delete(key);
      }
    }
  }
}

// Cache key generation utility
export function generateCacheKey(url: string, format: string, options: PackOptions): string {
  return JSON.stringify({
    url,
    format,
    options,
  });
}
</file>

<file path="website/server/src/utils/errorHandler.ts">
import type { ContentfulStatusCode } from 'hono/utils/http-status';

export class AppError extends Error {
  constructor(
    message: string,
    public readonly statusCode: ContentfulStatusCode = 500,
  ) {
    super(message);
    this.name = 'AppError';
  }
}

export function handlePackError(error: unknown): AppError {
  if (error instanceof AppError) {
    return error;
  }

  if (error instanceof Error) {
    const errorMessage = error.message || '';

    if (errorMessage.includes('Repository not found')) {
      return new AppError('Repository not found', 404);
    }

    if (errorMessage.includes('Failed to clone repository')) {
      return new AppError('Failed to clone repository', 422);
    }

    if (errorMessage.includes('circular') || errorMessage.includes('Converting circular structure to JSON')) {
      return new AppError(
        'Failed to process repository: circular dependency detected in the repository structure',
        422,
      );
    }

    return new AppError(process.env.NODE_ENV === 'production' ? 'An unexpected error occurred' : error.message);
  }

  return new AppError('An unexpected error occurred');
}

export function safeJSONStringify(obj: unknown): string {
  const cache = new Set();
  return JSON.stringify(obj, (key, value) => {
    if (typeof value === 'object' && value !== null) {
      if (cache.has(value)) {
        return '[Circular Reference]';
      }
      cache.add(value);
    }
    return value;
  });
}
</file>

<file path="website/server/src/utils/rateLimit.ts">
interface RateLimitEntry {
  count: number;
  resetTime: number;
}

export class RateLimiter {
  private limits: Map<string, RateLimitEntry> = new Map();
  private readonly windowMs: number;
  private readonly maxRequests: number;

  constructor(windowMs = 60000, maxRequests = 10) {
    this.windowMs = windowMs;
    this.maxRequests = maxRequests;
  }

  isAllowed(identifier: string): boolean {
    const now = Date.now();
    const entry = this.limits.get(identifier);

    if (!entry || now > entry.resetTime) {
      this.limits.set(identifier, {
        count: 1,
        resetTime: now + this.windowMs,
      });
      return true;
    }

    if (entry.count >= this.maxRequests) {
      return false;
    }

    entry.count += 1;
    return true;
  }

  getRemainingTime(identifier: string): number {
    const entry = this.limits.get(identifier);
    if (!entry) return 0;
    return Math.max(0, entry.resetTime - Date.now());
  }
}
</file>

<file path="website/server/src/utils/validation.ts">
import { z } from 'zod';
import { AppError } from './errorHandler.js';

export function validateRequest<T>(schema: z.ZodSchema<T>, data: unknown): T {
  try {
    return schema.parse(data);
  } catch (error) {
    if (error instanceof z.ZodError) {
      const messages = error.errors.map((err) => `${err.path.join('.')}: ${err.message}`).join(', ');
      throw new AppError(`Invalid request: ${messages}`, 400);
    }
    throw error;
  }
}

export function sanitizePattern(patterns: string | undefined): string {
  if (!patterns) return '';

  return (
    patterns
      .split(',')
      .map((p) => p.trim())
      .filter(Boolean)
      // Additional security checks
      .filter((p) => {
        // Prevent absolute paths
        if (p.startsWith('/')) return false;
        // Prevent directory traversal
        if (p.includes('../') || p.includes('..\\')) return false;
        // Prevent environment variable expansion
        if (p.includes('$')) return false;
        // Prevent command execution
        if (p.includes('`') || p.includes('$(')) return false;
        return true;
      })
      .join(',')
  );
}
</file>

<file path="website/server/src/index.ts">
import { serve } from '@hono/node-server';
import { Hono } from 'hono';
import { bodyLimit } from 'hono/body-limit';
import { compress } from 'hono/compress';
import { cors } from 'hono/cors';
import { logger } from 'hono/logger';
import { timeout } from 'hono/timeout';
import { processRemoteRepo } from './remoteRepo.js';
import type { ErrorResponse } from './types.js';
import { handlePackError } from './utils/errorHandler.js';

const app = new Hono();

// Set up CORS
app.use(
  '/*',
  cors({
    origin: ['http://localhost:5173', 'https://repomix.com', 'https://api.repomix.com'],
    allowMethods: ['GET', 'POST', 'OPTIONS'],
    allowHeaders: ['Content-Type'],
    maxAge: 86400,
    credentials: true,
  }),
);

// Enable compression for all routes
app.use(compress());

// Set up timeout middleware for /api routes
app.use('/api', timeout(30000));

// Set up logger middleware
app.use(logger());

// GET /health
app.get('/health', (c) => c.text('OK'));

// POST /api/pack
app.post(
  '/api/pack',
  bodyLimit({
    maxSize: 50 * 1024, // 50kb
    onError: (c) => {
      return c.text('overflow :(', 413);
    },
  }),
  async (c) => {
    try {
      const body = await c.req.json();
      const { url, format, options } = body;

      if (!url) {
        return c.json({ error: 'Repository URL is required' } as ErrorResponse, 400);
      }

      if (!['xml', 'markdown', 'plain'].includes(format)) {
        return c.json({ error: 'Invalid format specified' } as ErrorResponse, 400);
      }

      // Get client IP address
      const clientIp =
        c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || c.req.header('cf-connecting-ip') || '0.0.0.0';

      const result = await processRemoteRepo(url, format, options, clientIp);
      return c.json(result);
    } catch (error) {
      console.error('Error processing request:', error);
      const appError = handlePackError(error);
      return c.json(
        {
          error: appError.message,
        } as ErrorResponse,
        appError.statusCode,
      );
    }
  },
);

// Start the server
const port = process.env.PORT ? Number.parseInt(process.env.PORT, 10) : 3000;
console.log(`Server is starting on port ${port}`);

serve({
  fetch: app.fetch,
  port,
});

// Export the app for testing
export default app;
</file>

<file path="website/server/src/remoteRepo.ts">
import { randomUUID } from 'node:crypto';
import fs from 'node:fs/promises';
import { type CliOptions, runRemoteAction } from 'repomix';
import { packRequestSchema } from './schemas/request.js';
import type { PackOptions, PackResult } from './types.js';
import { RequestCache, generateCacheKey } from './utils/cache.js';
import { AppError } from './utils/errorHandler.js';
import { RateLimiter } from './utils/rateLimit.js';
import { sanitizePattern, validateRequest } from './utils/validation.js';

// Create instances of cache and rate limiter
const cache = new RequestCache<PackResult>(180); // 3 minutes cache
const rateLimiter = new RateLimiter(60_000, 3); // 3 requests per minute

export async function processRemoteRepo(
  repoUrl: string,
  format: string,
  options: PackOptions,
  clientIp: string,
): Promise<PackResult> {
  // Validate the request
  const validatedData = validateRequest(packRequestSchema, {
    url: repoUrl,
    format,
    options,
  });

  // Rate limit check
  if (!rateLimiter.isAllowed(clientIp)) {
    const remainingTime = Math.ceil(rateLimiter.getRemainingTime(clientIp) / 1000);
    throw new AppError(`Rate limit exceeded. Please try again in ${remainingTime} seconds.`, 429);
  }

  // Generate cache key
  const cacheKey = generateCacheKey(validatedData.url, validatedData.format, validatedData.options);

  // Check if the result is already cached
  const cachedResult = cache.get(cacheKey);
  if (cachedResult) {
    return cachedResult;
  }

  // Sanitize ignore patterns
  const sanitizedIncludePatterns = sanitizePattern(validatedData.options.includePatterns);
  const sanitizedIgnorePatterns = sanitizePattern(validatedData.options.ignorePatterns);

  const outputFilePath = `repomix-output-${randomUUID()}.txt`;

  // Create CLI options with correct mapping
  const cliOptions = {
    output: outputFilePath,
    style: validatedData.format,
    parsableStyle: validatedData.options.outputParsable,
    removeComments: validatedData.options.removeComments,
    removeEmptyLines: validatedData.options.removeEmptyLines,
    outputShowLineNumbers: validatedData.options.showLineNumbers,
    fileSummary: validatedData.options.fileSummary,
    directoryStructure: validatedData.options.directoryStructure,
    securityCheck: false,
    topFilesLen: 10,
    include: sanitizedIncludePatterns,
    ignore: sanitizedIgnorePatterns,
  } as CliOptions;

  try {
    // Execute remote action
    const result = await runRemoteAction(repoUrl, cliOptions);
    const { packResult } = result;

    // Read the generated file
    const content = await fs.readFile(outputFilePath, 'utf-8');

    // Create pack result
    const packResultData: PackResult = {
      content,
      format,
      metadata: {
        repository: repoUrl,
        timestamp: new Date().toISOString(),
        summary: {
          totalFiles: packResult.totalFiles,
          totalCharacters: packResult.totalCharacters,
          totalTokens: packResult.totalTokens,
        },
        topFiles: Object.entries(packResult.fileCharCounts)
          .map(([path, charCount]) => ({
            path,
            charCount,
            tokenCount: packResult.fileTokenCounts[path] || 0,
          }))
          .sort((a, b) => b.charCount - a.charCount)
          .slice(0, cliOptions.topFilesLen),
      },
    };

    // Save the result to cache
    cache.set(cacheKey, packResultData);

    return packResultData;
  } catch (error) {
    console.error('Error in remote action:', error);
    if (error instanceof Error) {
      throw new AppError(`Remote action failed: ${error.message}`, 500);
    }
    throw new AppError('Remote action failed with unknown error', 500);
  } finally {
    // Clean up the output file
    try {
      await fs.unlink(outputFilePath);
    } catch (err) {
      // Ignore file deletion errors
      console.warn('Failed to cleanup output file:', err);
    }
  }
}
</file>

<file path="website/server/src/types.ts">
export interface PackOptions {
  removeComments?: boolean;
  removeEmptyLines?: boolean;
  showLineNumbers?: boolean;
  fileSummary?: boolean;
  directoryStructure?: boolean;
  includePatterns?: string;
  ignorePatterns?: string;
  outputParsable?: boolean;
}

interface TopFile {
  path: string;
  charCount: number;
  tokenCount: number;
}

interface PackSummary {
  totalFiles: number;
  totalCharacters: number;
  totalTokens: number;
}

export interface PackResult {
  content: string;
  format: string;
  metadata: {
    repository: string;
    timestamp: string;
    summary?: PackSummary;
    topFiles?: TopFile[];
  };
}

export interface ErrorResponse {
  error: string;
}
</file>

<file path="website/server/.dockerignore">
# Dependencies
node_modules
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Build outputs
dist
build
*.tsbuildinfo

# Development files
.git
.gitignore
.env
.env.*
.npmrc
.yarnrc
.editorconfig
README.md
CHANGELOG.md
LICENSE
*.md

# IDE files
.vscode
.idea
*.swp
*.swo
.DS_Store
Thumbs.db

# Test files
__tests__
test
tests
coverage
.nyc_output

# Docker files
Dockerfile
.dockerignore

# Temporary files
tmp
temp
*.tmp
*.temp

# Log files
logs
*.log

# Cache directories
.npm
.eslintcache

# Cloud platform specific
.gcloudignore
cloudbuild.yaml
cloudbuild.yml

# TypeScript source maps
*.map

# Misc
.git
.github
.circleci
.husky
</file>

<file path="website/server/.gitignore">
dist
node_modules
</file>

<file path="website/server/cloudbuild.yaml">
steps:
  # Build the container image
  - name: 'gcr.io/cloud-builders/docker'
    id: 'build'
    args:
      - 'build'
      - '-t'
      - '$_REGION-docker.pkg.dev/$PROJECT_ID/repomix/server:$BUILD_ID'
      - '--cache-from'
      - '$_REGION-docker.pkg.dev/$PROJECT_ID/repomix/server:latest'
      - '--build-arg'
      - 'NODE_ENV=production'
      - '.'

  # Push the container image
  - name: 'gcr.io/cloud-builders/docker'
    id: 'push'
    args:
      - 'push'
      - '$_REGION-docker.pkg.dev/$PROJECT_ID/repomix/server:$BUILD_ID'

  # Deploy to Cloud Run
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'deploy'
    entrypoint: 'gcloud'
    args:
      - 'run'
      - 'deploy'
      - '$_SERVICE_NAME'
      - '--image'
      - '$_REGION-docker.pkg.dev/$PROJECT_ID/repomix/server:$BUILD_ID'
      - '--region'
      - '$_REGION'
      - '--platform'
      - 'managed'
      - '--port'
      - '8080'
      - '--memory'
      - '2048Mi'
      - '--cpu'
      - '4'
      - '--min-instances'
      - '0'
      - '--max-instances'
      - '10'
      - '--ingress'
      - 'all'
      - '--allow-unauthenticated'
      - '--set-env-vars'
      - 'NODE_ENV=production'

  # Tag the image as latest
  - name: 'gcr.io/cloud-builders/docker'
    id: 'tag-latest'
    args:
      - 'tag'
      - '$_REGION-docker.pkg.dev/$PROJECT_ID/repomix/server:$BUILD_ID'
      - '$_REGION-docker.pkg.dev/$PROJECT_ID/repomix/server:latest'

  # Push the latest tag
  - name: 'gcr.io/cloud-builders/docker'
    id: 'push-latest'
    args:
      - 'push'
      - '$_REGION-docker.pkg.dev/$PROJECT_ID/repomix/server:latest'

substitutions:
  _REGION: asia-northeast1
  _SERVICE_NAME: repomix-server

options:
  logging: CLOUD_LOGGING_ONLY
  dynamic_substitutions: true

images:
  - '$_REGION-docker.pkg.dev/$PROJECT_ID/repomix/server:$BUILD_ID'
  - '$_REGION-docker.pkg.dev/$PROJECT_ID/repomix/server:latest'
</file>

<file path="website/server/Dockerfile">
# ==============================================================================
# Base image
# ==============================================================================
FROM node:23-alpine AS builder

# Install git and other dependencies
RUN apk add --no-cache \
    git \
    ca-certificates

WORKDIR /app
COPY package*.json ./

# Install dependencies
RUN npm i

# Copy source code
COPY . .

# Build TypeScript
RUN npm run build

# ==============================================================================
# Production image
# ==============================================================================
FROM node:23-alpine

# Install git and other dependencies
RUN apk add --no-cache \
    git \
    ca-certificates \
    curl

WORKDIR /app

# Copy only necessary files
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/package*.json ./
COPY --from=builder /app/node_modules ./node_modules

# Set environment variables
ENV NODE_ENV=production \
    PORT=8080

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

# Start the server
CMD ["npm", "start"]
</file>

<file path="website/server/package.json">
{
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "PORT=8080 tsx watch src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "clean": "rimraf dist",
    "cloud-deploy": "gcloud builds submit --config=cloudbuild.yaml ."
  },
  "dependencies": {
    "@hono/node-server": "^1.13.7",
    "hono": "^4.6.16",
    "pako": "^2.1.0",
    "repomix": "^0.2.20",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@types/node": "^22.10.5",
    "@types/pako": "^2.0.3",
    "rimraf": "^6.0.1",
    "tsx": "^4.19.2",
    "typescript": "^5.7.3"
  }
}
</file>

<file path="website/server/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"]
}
</file>

<file path="website/compose.yml">
# Run website in development mode
# $ docker-compose -f website/compose.yml up --build

services:
  client:
    build:
      context: ./client
      dockerfile: Dockerfile
    ports:
      - "5173:5173"
    volumes:
      - ./client:/app
    environment:
      - NODE_ENV=development
    # override default command
    command: sh -c "npm i && npm run docs:dev -- --port 5173 --host"

  server:
    build:
      context: ./server
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    volumes:
      - ./server:/app
    environment:
      - NODE_ENV=development
      - PORT=8080
    # override default command
    command: sh -c "npm i && npm run dev"
</file>

<file path=".codecov.yml">
coverage:
  status:
    patch:
      default:
        target: 80%
        informational: true
    project:
      default:
        target: 75%
        threshold: 1%
</file>

<file path=".dockerignore">
node_modules
npm-debug.log
.git
.gitignore
.env
.env.*
*.md
.vscode
coverage
.nyc_output
dist
build
</file>

<file path=".editorconfig">
root = true

[*.*]
indent_style = space
indent_size = 2
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true
end_of_line = lf
max_line_length = null

[*.md]
trim_trailing_whitespace = false
</file>

<file path=".gitignore">
# Dependency directories
node_modules/

# Build output
lib/

# Logs
*.log

# OS generated files
.DS_Store

# Editor directories and files
.vscode/
.idea/

# Test coverage
coverage/

# Temporary files
*.tmp
*.temp

# Repomix output
repomix-output.txt
repomix-output.xml
repomix-output.md

# ESLint cache
.eslintcache

# yarn
.yarn/

# biome
.biome/
</file>

<file path=".node-version">
23.6.0
</file>

<file path=".npmignore">
# Source files
src/

# Test files
tests/
coverage/

# Configuration files
tsconfig.json
tsconfig.build.json
.eslintrc.js
eslint.config.mjs
prettier.config.mjs
vite.config.ts
biome.json

# Git files
.gitignore
.git

# CI files
.github/

# yarn files
.yarn

# ESLint files
.eslintcache

# Config files
.editorconfig
.node-version
.tool-versions
repomix.config.js

# Editor files
.vscode/
.idea/

# Logs
*.log

# Repomix output
repomix-output.txt

# Development scripts
scripts/

# Documentation files (except README and LICENSE)
docs/
CONTRIBUTING.md
CHANGELOG.md

# Temporary files
*.tmp
*.temp

# OS generated files
.DS_Store
Thumbs.db

# biome
.biome/

# Website
website/

# Devcontainer
.devcontainer/
</file>

<file path=".repomixignore">
node_modules
.yarn
.eslinttcache
tests/integration-tests/fixtures
</file>

<file path=".secretlintrc.json">
{
  "rules": [
    {
      "id": "@secretlint/secretlint-rule-preset-recommend"
    }
  ]
}
</file>

<file path=".tool-versions">
nodejs 23.6.0
</file>

<file path="biome.json">
{
  "$schema": "https://biomejs.dev/schemas/1.8.3/schema.json",
  "files": {
    "include": [
      "./bin/**",
      "./src/**",
      "./tests/**",
      "./website/**",
      "./.devcontainer/**",
      "./.github/**",
      "package.json",
      "biome.json",
      ".secretlintrc.json",
      "tsconfig.json",
      "tsconfig.build.json",
      "vite.config.ts",
      "repomix.config.json"
    ],
    "ignore": [
      "website/client/.vitepress/.temp",
      "website/client/.vitepress/dist",
      "website/client/.vitepress/cache",
      "website/server/dist"
    ]
  },
  "organizeImports": {
    "enabled": true
  },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": true
    }
  },
  "formatter": {
    "enabled": true,
    "formatWithErrors": false,
    "indentStyle": "space",
    "indentWidth": 2,
    "lineWidth": 120
  },
  "javascript": {
    "formatter": {
      "quoteStyle": "single",
      "trailingCommas": "all",
      "semicolons": "always"
    }
  },
  "json": {
    "parser": {
      "allowComments": true
    }
  }
}
</file>

<file path="CODE_OF_CONDUCT.md">
# Repomix Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we, as contributors and maintainers, pledge to make participation in our project and community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contribute to creating a positive environment include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or advances
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as physical or electronic addresses, without explicit permission
* Other conduct that could reasonably be considered inappropriate in a professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that do not align with this Code of Conduct or to ban temporarily or permanently any contributor for behaviors that they deem inappropriate, threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project email address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at [koukun0120@gmail.com](mailto:koukun0120@gmail.com). All complaints will be reviewed and investigated, resulting in a response deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality concerning the reporter of an incident. Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at [https://www.contributor-covenant.org/version/1/4/code-of-conduct.html](https://www.contributor-covenant.org/version/1/4/code-of-conduct.html).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this Code of Conduct, see [https://www.contributor-covenant.org/faq](https://www.contributor-covenant.org/faq).
</file>

<file path="CONTRIBUTING.md">
# Contribution Guide

Thanks for your interest in **Repomix**! 🚀 We’d love your help to make it even better. Here’s how you can get involved:


- **Create an Issue**: Spot a bug? Have an idea for a new feature? Let us know by creating an issue.
- **Submit a Pull Request**: Found something to fix or improve? Jump in and submit a PR!
- **Spread the Word**: Share your experience with Repomix on social media, blogs, or with your tech community.
- **Use Repomix**: The best feedback comes from real-world usage, so feel free to integrate Repomix into your own projects!

## Maintainers

Repomix is maintained by Yamadashy ([@yamadashy](https://github.com/yamadashy)). While all contributions are welcome, please understand that not every suggestion may be accepted if they don't align with the project's goals or coding standards.

---

## Pull Requests

Before submitting a Pull Request, please ensure:

1. Your code passes all tests: Run `npm run test`
2. Your code adheres to our linting standards: Run `npm run lint`
3. You have updated relevant documentation (especially README.md) if you've added or changed functionality.

## Local Development

To set up Repomix for local development:

```bash
git clone https://github.com/yamadashy/repomix.git
cd repomix
npm install
```

To run Repomix locally:

```bash
npm run cli-run
```

### Docker Usage
You can also run Repomix using Docker. Here's how:

First, build the Docker image:
```bash
docker build -t repomix .
```

Then, run the Docker container:
```bash
docker run -v ./:/app -it --rm repomix
```

### Coding Style

We use [Biome](https://biomejs.dev/) for linting and formatting. Please make sure your code follows the style guide by running:

```bash
npm run lint
```

### Testing

We use [Vitest](https://vitest.dev/) for testing. To run the tests:

```bash
npm run test
```

For test coverage:

```bash
npm run test-coverage
```

### Documentation

When adding new features or making changes, please update the relevant documentation in the README.md file.

## Releasing

New versions are managed by the maintainer. If you think a release is needed, open an issue to discuss it

Thank you for contributing to Repomix!
</file>

<file path="Dockerfile">
FROM node:22-slim

RUN apt-get update && apt-get install -y --no-install-recommends \
    git \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

RUN mkdir /repomix
WORKDIR /repomix

# Install dependencies and build repomix, then link the package to the global scope
# To reduce the size of the layer, npm ci and npm link are executed in the same RUN command
COPY . .
RUN npm ci \
    && npm run build \
    && npm link \
    && npm ci --omit=dev \
    && npm cache clean --force

WORKDIR /app

# Check the operation of repomix
RUN repomix --version
RUN repomix --help

ENTRYPOINT ["repomix"]
</file>

<file path="LICENSE">
Copyright 2024 Kazuki Yamada

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</file>

<file path="package.json">
{
  "name": "repomix",
  "version": "0.2.20",
  "description": "A tool to pack repository contents to single file for AI consumption",
  "main": "./lib/index.js",
  "types": "./lib/index.d.ts",
  "exports": {
    ".": {
      "import": {
        "types": "./lib/index.d.ts",
        "default": "./lib/index.js"
      },
      "require": {
        "types": "./lib/index.d.ts",
        "default": "./lib/index.js"
      },
      "default": "./lib/index.js"
    }
  },
  "bin": "./bin/repomix.cjs",
  "scripts": {
    "clean": "rimraf lib",
    "build": "npm run clean && tsc -p tsconfig.build.json --sourceMap --declaration",
    "lint": "npm run lint-biome && npm run lint-ts && npm run lint-secretlint",
    "lint-biome": "biome check --write",
    "lint-ts": "tsc --noEmit",
    "lint-secretlint": "secretlint \"**/*\" --secretlintignore .gitignore",
    "test": "vitest",
    "test-coverage": "vitest run --coverage",
    "cli-run": "npm run build && node --trace-warnings bin/repomix.cjs",
    "npm-publish": "npm run lint && npm run test-coverage && npm run build && npm publish",
    "npm-release-patch": "npm version patch && npm run npm-publish",
    "npm-release-minor": "npm version minor && npm run npm-publish",
    "npm-release-prerelease": "npm version prerelease && npm run npm-publish"
  },
  "keywords": [
    "repository",
    "generative-ai",
    "ai",
    "llm",
    "source-code",
    "code-analysis",
    "codebase-packer",
    "development-tool",
    "ai-assistant",
    "code-review"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/yamadashy/repomix.git"
  },
  "bugs": {
    "url": "https://github.com/yamadashy/repomix/issues"
  },
  "author": "Kazuki Yamada <koukun0120@gmail.com>",
  "homepage": "https://github.com/yamadashy/repomix",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "type": "module",
  "dependencies": {
    "@clack/prompts": "^0.9.1",
    "@secretlint/core": "^9.0.0",
    "@secretlint/secretlint-rule-preset-recommend": "^9.0.0",
    "cli-spinners": "^2.9.2",
    "clipboardy": "^4.0.0",
    "commander": "^13.0.0",
    "fast-xml-parser": "^4.5.1",
    "globby": "^14.0.2",
    "handlebars": "^4.7.8",
    "iconv-lite": "^0.6.3",
    "istextorbinary": "^9.5.0",
    "jschardet": "^3.1.4",
    "log-update": "^6.1.0",
    "minimatch": "^10.0.1",
    "p-map": "^7.0.3",
    "picocolors": "^1.1.1",
    "strip-comments": "^2.0.1",
    "strip-json-comments": "^5.0.1",
    "tiktoken": "^1.0.18",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@biomejs/biome": "^1.9.4",
    "@types/node": "^22.10.5",
    "@types/strip-comments": "^2.0.4",
    "@vitest/coverage-v8": "^2.1.8",
    "rimraf": "^6.0.1",
    "secretlint": "^9.0.0",
    "typescript": "^5.7.3",
    "vitest": "^2.1.8"
  },
  "engines": {
    "node": ">=18.0.0",
    "yarn": ">=1.22.22"
  }
}
</file>

<file path="README.md">
<div align="center">
  <a href="https://repomix.com">
    <img src="website/client/src/public/images/repomix-title.png" alt="Repomix" width="500" height="auto" />
  </a>
  <p align="center">
    <b>Pack your codebase into AI-friendly formats</b>
  </p>
</div>

<hr />

<p align="center">
  <a href="https://repomix.com"><b>Use Repomix online! 👉 repomix.com</b></a><br>
</p>

<p align="center">
  Need discussion? Join us on <a href="https://discord.gg/wNYzTwZFku">Discord</a>!<br>
  <i>Share your experience and tips</i><br>
  <i>Stay updated on new features</i><br>
  <i>Get help with configuration and usage</i><br>
</p>

<hr />

[![Actions Status](https://github.com/yamadashy/repomix/actions/workflows/ci.yml/badge.svg)](https://github.com/yamadashy/repomix/actions?query=workflow%3A"ci")
[![npm](https://img.shields.io/npm/v/repomix.svg?maxAge=1000)](https://www.npmjs.com/package/repomix)
[![npm](https://img.shields.io/npm/d18m/repomix)](https://www.npmjs.com/package/repomix)
[![npm](https://img.shields.io/npm/l/repomix.svg?maxAge=1000)](https://github.com/yamadashy/repomix/blob/main/LICENSE)
[![node](https://img.shields.io/node/v/repomix.svg?maxAge=1000)](https://www.npmjs.com/package/repomix)
[![codecov](https://codecov.io/github/yamadashy/repomix/graph/badge.svg)](https://codecov.io/github/yamadashy/repomix)

📦 Repomix is a powerful tool that packs your entire repository into a single, AI-friendly file.  
It is perfect for when you need to feed your codebase to Large Language Models (LLMs) or other AI tools like Claude,
ChatGPT, and Gemini.

## 🎉 New: Repomix Website & Discord Community!

- Try Repomix in your browser at [repomix.com](https://repomix.com/)
- Join our [Discord Server](https://discord.gg/wNYzTwZFku) for support and discussion

**We look forward to seeing you there!**

## 🌟 Features

- **AI-Optimized**: Formats your codebase in a way that's easy for AI to understand and process.
- **Token Counting**: Provides token counts for each file and the entire repository, useful for LLM context limits.
- **Simple to Use**: You need just one command to pack your entire repository.
- **Customizable**: Easily configure what to include or exclude.
- **Git-Aware**: Automatically respects your .gitignore files.
- **Security-Focused**: Incorporates [Secretlint](https://github.com/secretlint/secretlint) for robust security checks
  to detect and prevent inclusion of sensitive information.

## 🚀 Quick Start

### Using the CLI Tool `>_`

You can try Repomix instantly in your project directory without installation:

```bash
npx repomix
```

Or install globally for repeated use:

```bash
# Install using npm
npm install -g repomix

# Alternatively using yarn
yarn global add repomix

# Alternatively using Homebrew (macOS/Linux)
brew install repomix

# Then run in any project directory
repomix
```

That's it! Repomix will generate a `repomix-output.txt` file in your current directory, containing your entire
repository in an AI-friendly format.

You can then send this file to an AI assistant with a prompt like:

```
This file contains all the files in the repository combined into one.
I want to refactor the code, so please review it first.
```

![Repomix File Usage 1](website/client/src/public/images/docs/repomix-file-usage-1.png)

When you propose specific changes, the AI might be able to generate code accordingly. With features like Claude's
Artifacts, you could potentially output multiple files, allowing for the generation of multiple interdependent pieces of
code.

![Repomix File Usage 2](website/client/src/public/images/docs/repomix-file-usage-2.png)

Happy coding! 🚀

### Using The Website 🌐

Want to try it quickly? Visit the official website at [repomix.com](https://repomix.com). Simply enter your repository
name, fill in any optional details, and click the **Pack** button to see your generated output.

#### Available Options

The website offers several convenient features:

- Customizable output format (Plain Text, XML, or Markdown)
- Instant token count estimation
- Much more!

### Alternative Tools 🛠️

If you're using Python, you might want to check out `Gitingest`, which is better suited for Python ecosystem and data
science workflows:
https://github.com/cyclotruc/gitingest

## 📊 Usage

To pack your entire repository:

```bash
repomix
```

To pack a specific directory:

```bash
repomix path/to/directory
```

To pack specific files or directories
using [glob patterns](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax):

```bash
repomix --include "src/**/*.ts,**/*.md"
```

To exclude specific files or directories:

```bash
repomix --ignore "**/*.log,tmp/"
```

To pack a remote repository:

```bash
repomix --remote https://github.com/yamadashy/repomix

# You can also use GitHub shorthand:
repomix --remote yamadashy/repomix

# You can specify the branch name, tag, or commit hash:
repomix --remote https://github.com/yamadashy/repomix --remote-branch main

# Or use a specific commit hash:
repomix --remote https://github.com/yamadashy/repomix --remote-branch 935b695
```

To initialize a new configuration file (`repomix.config.json`):

```bash
repomix --init
```

Once you have generated the packed file, you can use it with Generative AI tools like Claude, ChatGPT, and Gemini.

### Docker Usage 🐳

You can also run Repomix using Docker.  
This is useful if you want to run Repomix in an isolated environment or prefer using containers.

Basic usage (current directory):

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

To pack a specific directory:

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory
```

Process a remote repository and output to a `output` directory:

```bash
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote https://github.com/yamadashy/repomix
```

### Prompt Examples

Once you have generated the packed file with Repomix, you can use it with AI tools like Claude, ChatGPT, and Gemini.
Here are some example prompts to get you started:

#### Code Review and Refactoring

For a comprehensive code review and refactoring suggestions:

```
This file contains my entire codebase. Please review the overall structure and suggest any improvements or refactoring opportunities, focusing on maintainability and scalability.
```

#### Documentation Generation

To generate project documentation:

```
Based on the codebase in this file, please generate a detailed README.md that includes an overview of the project, its main features, setup instructions, and usage examples.
```

#### Test Case Generation

For generating test cases:

```
Analyze the code in this file and suggest a comprehensive set of unit tests for the main functions and classes. Include edge cases and potential error scenarios.
```

#### Code Quality Assessment

Evaluate code quality and adherence to best practices:

```
Review the codebase for adherence to coding best practices and industry standards. Identify areas where the code could be improved in terms of readability, maintainability, and efficiency. Suggest specific changes to align the code with best practices.
```

#### Library Overview

Get a high-level understanding of the library

```
This file contains the entire codebase of library. Please provide a comprehensive overview of the library, including its main purpose, key features, and overall architecture.
```

Feel free to modify these prompts based on your specific needs and the capabilities of the AI tool you're using.

### Community Discussion

Check out our [community discussion](https://github.com/yamadashy/repomix/discussions/154) where users share:

- Which AI tools they're using with Repomix
- Effective prompts they've discovered
- How Repomix has helped them
- Tips and tricks for getting the most out of AI code analysis

Feel free to join the discussion and share your own experiences! Your insights could help others make better use of
Repomix.

### Output File Format

Repomix generates a single file with clear separators between different parts of your codebase.  
To enhance AI comprehension, the output file begins with an AI-oriented explanation, making it easier for AI models to
understand the context and structure of the packed repository.

#### Plain Text Format (default)

```text
This file is a merged representation of the entire codebase, combining all repository files into a single document.

================================================================
File Summary
================================================================
(Metadata and usage AI instructions)

================================================================
Directory Structure
================================================================
src/
  cli/
    cliOutput.ts
    index.ts
  config/
    configLoader.ts

(...remaining directories)

================================================================
Files
================================================================

================
File: src/index.js
================
// File contents here

================
File: src/utils.js
================
// File contents here

(...remaining files)

================================================================
Instruction
================================================================
(Custom instructions from `output.instructionFilePath`)
```

#### XML Format

To generate output in XML format, use the `--style xml` option:

```bash
repomix --style xml
```

The XML format structures the content in a hierarchical manner:

```xml
This file is a merged representation of the entire codebase, combining all repository files into a single document.

<file_summary>
  (Metadata and usage AI instructions)
</file_summary>

<directory_structure>
src/
cli/
cliOutput.ts
index.ts

(...remaining directories)
</directory_structure>

<files>
<file path="src/index.js">
  // File contents here
</file>

(...remaining files)
</files>

<instruction>
(Custom instructions from `output.instructionFilePath`)
</instruction>
```

For those interested in the potential of XML tags in AI contexts:  
https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/use-xml-tags

> When your prompts involve multiple components like context, instructions, and examples, XML tags can be a
> game-changer. They help Claude parse your prompts more accurately, leading to higher-quality outputs.

This means that the XML output from Repomix is not just a different format, but potentially a more effective way to feed
your codebase into AI systems for analysis, code review, or other tasks.

#### Markdown Format

To generate output in Markdown format, use the `--style markdown` option:

```bash
repomix --style markdown
```

The Markdown format structures the content in a hierarchical manner:

````markdown
This file is a merged representation of the entire codebase, combining all repository files into a single document.

# File Summary

(Metadata and usage AI instructions)

# Repository Structure

```
src/
  cli/
    cliOutput.ts
    index.ts
```

(...remaining directories)

# Repository Files

## File: src/index.js

```
// File contents here
```

(...remaining files)

# Instruction

(Custom instructions from `output.instructionFilePath`)
````

This format provides a clean, readable structure that is both human-friendly and easily parseable by AI systems.

### Command Line Options

- `-v, --version`: Show tool version
- `-o, --output <file>`: Specify the output file name
- `--include <patterns>`: List of include patterns (comma-separated)
- `-i, --ignore <patterns>`: Additional ignore patterns (comma-separated)
- `-c, --config <path>`: Path to a custom config file
- `--style <style>`: Specify the output style (`plain`, `xml`, `markdown`)
- `--parsable-style`: Enable parsable output based on the chosen style schema. Note that this can increase token count.
- `--no-file-summary`: Disable file summary section output
- `--no-directory-structure`: Disable directory structure section output
- `--remove-comments`: Remove comments from supported file types
- `--remove-empty-lines`: Remove empty lines from the output
- `--top-files-len <number>`: Number of top files to display in the summary
- `--output-show-line-numbers`: Show line numbers in the output
- `--copy`: Additionally copy generated output to system clipboard
- `--remote <url>`: Process a remote Git repository
- `--remote-branch <name>`: Specify the remote branch name, tag, or commit hash (defaults to repository default branch)
- `--no-security-check`: Disable security check
- `--token-count-encoding <encoding>`: Specify token count encoding (e.g., `o200k_base`, `cl100k_base`)
- `--verbose`: Enable verbose logging

Examples:

```bash
repomix -o custom-output.txt
repomix -i "*.log,tmp" -v
repomix -c ./custom-config.json
repomix --style xml
repomix --remote https://github.com/user/repo
npx repomix src
```

### Updating Repomix

To update a globally installed Repomix:

```bash
# Using npm
npm update -g repomix

# Using yarn
yarn global upgrade repomix
```

Using `npx repomix` is generally more convenient as it always uses the latest version.

### Remote Repository Processing

Repomix supports processing remote Git repositories without the need for manual cloning. This feature allows you to
quickly analyze any public Git repository with a single command.

To process a remote repository, use the `--remote` option followed by the repository URL:

```bash
repomix --remote https://github.com/yamadashy/repomix
```

You can also use GitHub's shorthand format:

```bash
repomix --remote yamadashy/repomix
```

You can specify the branch name, tag, or commit hash:

```bash
repomix --remote https://github.com/yamadashy/repomix --remote-branch main
```

Or use a specific commit hash:

```bash
repomix --remote https://github.com/yamadashy/repomix --remote-branch 935b695
```

## ⚙️ Configuration

Create a `repomix.config.json` file in your project root for custom configurations.

```bash
repomix --init
```

Here's an explanation of the configuration options:

| Option                           | Description                                                                                                                  | Default                |
|----------------------------------|------------------------------------------------------------------------------------------------------------------------------|------------------------|
| `output.filePath`                | The name of the output file                                                                                                  | `"repomix-output.txt"` |
| `output.style`                   | The style of the output (`plain`, `xml`, `markdown`)                                                                         | `"plain"`              |
| `output.parsableStyle`           | Whether to escape the output based on the chosen style schema. Note that this can increase token count.                      | `false`                |
| `output.headerText`              | Custom text to include in the file header                                                                                    | `null`                 |
| `output.instructionFilePath`     | Path to a file containing detailed custom instructions                                                                       | `null`                 |
| `output.fileSummary`             | Whether to include a summary section at the beginning of the output                                                          | `true`                 |
| `output.directoryStructure`      | Whether to include the directory structure in the output                                                                     | `true`                 |
| `output.removeComments`          | Whether to remove comments from supported file types                                                                         | `false`                |
| `output.removeEmptyLines`        | Whether to remove empty lines from the output                                                                                | `false`                |
| `output.showLineNumbers`         | Whether to add line numbers to each line in the output                                                                       | `false`                |
| `output.copyToClipboard`         | Whether to copy the output to system clipboard in addition to saving the file                                                | `false`                |
| `output.topFilesLength`          | Number of top files to display in the summary. If set to 0, no summary will be displayed                                     | `5`                    |
| `output.includeEmptyDirectories` | Whether to include empty directories in the repository structure                                                             | `false`                |
| `include`                        | Patterns of files to include (using [glob patterns](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax))  | `[]`                   |
| `ignore.useGitignore`            | Whether to use patterns from the project's `.gitignore` file                                                                 | `true`                 |
| `ignore.useDefaultPatterns`      | Whether to use default ignore patterns                                                                                       | `true`                 |
| `ignore.customPatterns`          | Additional patterns to ignore (using [glob patterns](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)) | `[]`                   |
| `security.enableSecurityCheck`   | Whether to perform security checks on files                                                                                  | `true`                 |
| `tokenCount.encoding`            | Token count encoding for AI model context limits (e.g., `o200k_base`, `cl100k_base`)                                         | `"o200k_base"`         |

Example configuration:

```json5
{
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "parsableStyle": true,
    "headerText": "Custom header information for the packed file.",
    "fileSummary": true,
    "directoryStructure": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "showLineNumbers": false,
    "copyToClipboard": true,
    "topFilesLength": 5,
    "includeEmptyDirectories": false
  },
  "include": [
    "**/*"
  ],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    // Patterns can also be specified in .repomixignore
    "customPatterns": [
      "additional-folder",
      "**/*.log"
    ]
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
```

### Global Configuration

To create a global configuration file:

```bash
repomix --init --global
```

The global configuration file will be created in:

- Windows: `%LOCALAPPDATA%\Repomix\repomix.config.json`
- macOS/Linux: `$XDG_CONFIG_HOME/repomix/repomix.config.json` or `~/.config/repomix/repomix.config.json`

Note: Local configuration (if present) takes precedence over global configuration.

### Include and Ignore

#### Include Patterns

Repomix now supports specifying files to include
using [glob patterns](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax). This allows for more
flexible and powerful file selection:

- Use `**/*.js` to include all JavaScript files in any directory
- Use `src/**/*` to include all files within the `src` directory and its subdirectories
- Combine multiple patterns like `["src/**/*.js", "**/*.md"]` to include JavaScript files in `src` and all Markdown
  files

#### Ignore Patterns

Repomix offers multiple methods to set ignore patterns for excluding specific files or directories during the packing
process:

- **.gitignore**: By default, patterns listed in your project's `.gitignore` file are used. This behavior can be
  controlled with the `ignore.useGitignore` setting.
- **Default patterns**: Repomix includes a default list of commonly excluded files and directories (e.g., node_modules,
  .git, binary files). This feature can be controlled with the `ignore.useDefaultPatterns` setting. Please
  see [defaultIgnore.ts](src/config/defaultIgnore.ts) for more details.
- **.repomixignore**: You can create a `.repomixignore` file in your project root to define Repomix-specific ignore
  patterns. This file follows the same format as `.gitignore`.
- **Custom patterns**: Additional ignore patterns can be specified using the `ignore.customPatterns` option in the
  configuration file. You can overwrite this setting with the `-i, --ignore` command line option.

Priority Order (from highest to lowest):

1. Custom patterns `ignore.customPatterns`
2. `.repomixignore`
3. `.gitignore` (if `ignore.useGitignore` is true)
4. Default patterns (if `ignore.useDefaultPatterns` is true)

This approach allows for flexible file exclusion configuration based on your project's needs. It helps optimize the size
of the generated pack file by ensuring the exclusion of security-sensitive files and large binary files, while
preventing the leakage of confidential information.

Note: Binary files are not included in the packed output by default, but their paths are listed in the "Repository
Structure" section of the output file. This provides a complete overview of the repository structure while keeping the
packed file efficient and text-based.

### Custom Instruction

The `output.instructionFilePath` option allows you to specify a separate file containing detailed instructions or
context about your project. This allows AI systems to understand the specific context and requirements of your project,
potentially leading to more relevant and tailored analysis or suggestions.

Here's an example of how you might use this feature:

1. Create a file named `repomix-instruction.md` in your project root:

```markdown
# Coding Guidelines

- Follow the Airbnb JavaScript Style Guide
- Suggest splitting files into smaller, focused units when appropriate
- Add comments for non-obvious logic. Keep all text in English
- All new features should have corresponding unit tests

# Generate Comprehensive Output

- Include all content without abbreviation, unless specified otherwise
- Optimize for handling large codebases while maintaining output quality
```

2. In your `repomix.config.json`, add the `instructionFilePath` option:

```json5
{
  "output": {
    "instructionFilePath": "repomix-instruction.md",
    // other options...
  }
}
```

When Repomix generates the output, it will include the contents of `repomix-instruction.md` in a dedicated section.

Note: The instruction content is appended at the end of the output file. This placement can be particularly effective
for AI systems. For those interested in understanding why this might be beneficial, Anthropic provides some insights in
their documentation:  
https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/long-context-tips

> Put long-form data at the top: Place your long documents and inputs (~20K+ tokens) near the top of your prompt, above
> your query, instructions, and examples. This can significantly improve Claude's performance across all models.
> Queries at the end can improve response quality by up to 30% in tests, especially with complex, multi-document inputs.

### Comment Removal

When `output.removeComments` is set to `true`, Repomix will attempt to remove comments from supported file types. This
feature can help reduce the size of the output file and focus on the essential code content.

Supported languages include:  
HTML, CSS, JavaScript, TypeScript, Vue, Svelte, Python, PHP, Ruby, C, C#, Java, Go, Rust, Swift, Kotlin, Dart, Shell,
and YAML.

Note: The comment removal process is conservative to avoid accidentally removing code. In complex cases, some comments
might be retained.

## 🔍 Security Check

Repomix includes a security check feature that uses [Secretlint](https://github.com/secretlint/secretlint) to detect
potentially sensitive information in your files. This feature helps you identify possible security risks before sharing
your packed repository.

The security check results will be displayed in the CLI output after the packing process is complete. If any suspicious
files are detected, you'll see a list of these files along with a warning message.

Example output:

```
🔍 Security Check:
──────────────────
2 suspicious file(s) detected:
1. src/utils/test.txt
2. tests/utils/secretLintUtils.test.ts

Please review these files for potentially sensitive information.
```

By default, Repomix's security check feature is enabled. You can disable it by setting `security.enableSecurityCheck` to
`false` in your configuration file:

```json
{
  "security": {
    "enableSecurityCheck": false
  }
}
```

Or using the `--no-security-check` command line option:

```bash
repomix --no-security-check
```

> [!NOTE]
> Disabling security checks may expose sensitive information. Use this option with caution and only when necessary, such
> as when working with test files or documentation that contains example credentials.

## 🤝 Contribution

We welcome contributions from the community! To get started, please refer to our [Contributing Guide](CONTRIBUTING.md).

### Contributors

<a href="https://github.com/yamadashy/repomix/graphs/contributors">
  <img alt="contributors" src="https://contrib.rocks/image?repo=yamadashy/repomix"/>
</a>

## 📜 License

This project is licensed under the [MIT License](LICENSE).

<p align="center">
  &nbsp;&nbsp;&nbsp;
  <a href="#-repomix" target="_blank">
    Back To Top
  </a>

</p>
</file>

<file path="repomix-instruction.md">
# Coding Guidelines
- Follow the Airbnb JavaScript Style Guide
- Suggest splitting files into smaller, focused units when appropriate
  - Keep code files under 250 lines, if the file is over 250 lines, split it into multiple files based on the functionality.
- Add comments for non-obvious logic. Keep all text in English
- All new features should have corresponding unit tests

## Dependencies and Testing
- Inject dependencies through a deps object parameter for testability
- Example:
  ```typescript
  export const functionName = async (
    param1: Type1,
    param2: Type2,
    deps = {
      defaultFunction1,
      defaultFunction2,
    }
  ) => {
    // Use deps.defaultFunction1() instead of direct call
  };
  ```
- Mock dependencies by passing test doubles through deps object
- Use vi.mock() only when dependency injection is not feasible

# Generate Comprehensive Output
- Include all content without abbreviation, unless specified otherwise
- Optimize for handling large codebases while maintaining output quality

# GitHub Release Note Guidelines
Here are some examples of release notes that follow the guidelines:

v0.1.40
````md
This release introduces improvements to file handling and output formatting, enhancing Repomix's functionality and user experience.

## Improvements

### Enhanced Markdown Support (#86, #95)

- Improved code block formatting in Markdown output:
  - Added language identifiers to code blocks for better syntax highlighting
  - Extended support for various file extensions to improve language detection
- Dynamic output file extension:
  - The extension of the output file now changes based on the selected style (e.g., `.md` for Markdown, `.xml` for XML)
  - This behavior only applies when no specific output file path is provided by the user

### Enhanced Exclusion of Package Manager Lock Files (#90, #94)

- Improved exclusion of common package manager lock files:
  - npm: `package-lock.json`
  - Yarn: `yarn.lock`
  - pnpm: `pnpm-lock.yaml`
  - These files are now automatically excluded from the packed output, including those in subdirectories

## How to Update

To update to the latest version, run:

```bash
npm update -g repomix
```

---

We value your feedback and contributions in making Repomix better! If you encounter any issues or have suggestions, please share them through our GitHub issues.
````

v0.1.38
````md
This release introduces a new Markdown output style, providing users with an additional option for formatting their repository content.

## What's New

### Markdown Output Style (#86, #87)

- Added new 'markdown' output style option
  - Users can now generate output in Markdown format, alongside existing plain text and XML options

## How to Use

To use the new Markdown output style, use the `--style markdown` option:

```bash
repomix --style markdown
```

Or update your `repomix.config.json`:

```json
{
  "output": {
    "style": "markdown"
  }
}
```

---

To update, simply run:
```bash
npm update -g repomix
```

As always, we appreciate your feedback and contributions to make Repomix even better! If you encounter any issues or have suggestions regarding this new feature, please let us know through our GitHub issues.
````

v0.1.36
````md
This release introduces a new configuration option that allows users to control the security check feature, providing more flexibility in how Repomix handles sensitive information detection.

## What's New

### Configurable Security Check (#74, #75)

- Added new configuration option `security.enableSecurityCheck` (default: `true`)
  - Users can now disable the security check when needed, such as when working with cryptographic libraries or known false positives

## How to Use

To **disable** the security check, add the following to your `repomix.config.json`:

```json
{
  "security": {
    "enableSecurityCheck": false
  }
}
```

**Note:** Disabling the security check may expose sensitive information. Use this option with caution and only when necessary.

---

To update, simply run:
```bash
npm update -g repomix
```

As always, we appreciate your feedback and contributions to make Repomix even better! If you encounter any issues or have suggestions regarding this new feature, please let us know through our GitHub issues.
````

v0.1.32
````md
This release focuses on improving performance and user experience, particularly when processing large repositories.

## Bug Fixes
###  Fixed an issue where the application appeared to hang (#63, #65)

- Fixed an issue where the application appeared to hang during the security check process on large repositories.
- Reduced the impact on the event loop to prevent hanging when processing a large number of files.
- Implemented more frequent console updates during file processing and security checks.

---
To update, simply run:
```
npm update -g repomix
```

As always, we appreciate your feedback and contributions to make Repomix even better!
````
</file>

<file path="repomix.config.json">
{
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "headerText": "This repository contains the source code for the Repomix tool.\nRepomix is designed to pack repository contents into a single file,\nmaking it easier for AI systems to analyze and process the codebase.\n\nKey Features:\n- Configurable ignore patterns\n- Custom header text support\n- Efficient file processing and packing\n\nPlease refer to the README.md file for more detailed information on usage and configuration.\n",
    "instructionFilePath": "repomix-instruction.md",
    "fileSummary": true,
    "directoryStructure": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "includeEmptyDirectories": true
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    // ignore is specified in .repomixignore
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
</file>

<file path="SECURITY.md">
# Security Policy

## Reporting a Vulnerability

To securely report a vulnerability, please [open an advisory on GitHub](https://github.com/yamadashy/repomix/security/advisories/new) or report it by sending an email to `koukun0120@gmail.com`.
</file>

<file path="tsconfig.build.json">
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "rootDir": "./src"
  },
  "include": ["./src/**/*"]
}
</file>

<file path="tsconfig.json">
{
  "compileOnSave": false,
  "compilerOptions": {
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "target": "es2016",
    "outDir": "./lib",
    "rootDir": ".",
    "strict": true,
    "esModuleInterop": true,
    "noImplicitAny": true,
    "skipLibCheck": true,
    "lib": ["es2022"],
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "types": ["node", "picocolors"]
  },
  "include": ["src/**/*", "tests/**/*"],
  "exclude": ["tests/integration-tests/fixtures"]
}
</file>

<file path="typos.toml">
[files]
extend-exclude = [
    "website/client/src/**/*.md"
]
</file>

<file path="vitest.config.ts">
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    include: ['tests/**/*.test.ts'],
    coverage: {
      include: ['src/**/*'],
      exclude: ['src/index.ts'],
      reporter: ['text', 'json', 'html'],
    },
  },
});
</file>

</files>

<instruction>
# Coding Guidelines
- Follow the Airbnb JavaScript Style Guide
- Suggest splitting files into smaller, focused units when appropriate
  - Keep code files under 250 lines, if the file is over 250 lines, split it into multiple files based on the functionality.
- Add comments for non-obvious logic. Keep all text in English
- All new features should have corresponding unit tests

## Dependencies and Testing
- Inject dependencies through a deps object parameter for testability
- Example:
  ```typescript
  export const functionName = async (
    param1: Type1,
    param2: Type2,
    deps = {
      defaultFunction1,
      defaultFunction2,
    }
  ) => {
    // Use deps.defaultFunction1() instead of direct call
  };
  ```
- Mock dependencies by passing test doubles through deps object
- Use vi.mock() only when dependency injection is not feasible

# Generate Comprehensive Output
- Include all content without abbreviation, unless specified otherwise
- Optimize for handling large codebases while maintaining output quality

# GitHub Release Note Guidelines
Here are some examples of release notes that follow the guidelines:

v0.1.40
````md
This release introduces improvements to file handling and output formatting, enhancing Repomix's functionality and user experience.

## Improvements

### Enhanced Markdown Support (#86, #95)

- Improved code block formatting in Markdown output:
  - Added language identifiers to code blocks for better syntax highlighting
  - Extended support for various file extensions to improve language detection
- Dynamic output file extension:
  - The extension of the output file now changes based on the selected style (e.g., `.md` for Markdown, `.xml` for XML)
  - This behavior only applies when no specific output file path is provided by the user

### Enhanced Exclusion of Package Manager Lock Files (#90, #94)

- Improved exclusion of common package manager lock files:
  - npm: `package-lock.json`
  - Yarn: `yarn.lock`
  - pnpm: `pnpm-lock.yaml`
  - These files are now automatically excluded from the packed output, including those in subdirectories

## How to Update

To update to the latest version, run:

```bash
npm update -g repomix
```

---

We value your feedback and contributions in making Repomix better! If you encounter any issues or have suggestions, please share them through our GitHub issues.
````

v0.1.38
````md
This release introduces a new Markdown output style, providing users with an additional option for formatting their repository content.

## What's New

### Markdown Output Style (#86, #87)

- Added new 'markdown' output style option
  - Users can now generate output in Markdown format, alongside existing plain text and XML options

## How to Use

To use the new Markdown output style, use the `--style markdown` option:

```bash
repomix --style markdown
```

Or update your `repomix.config.json`:

```json
{
  "output": {
    "style": "markdown"
  }
}
```

---

To update, simply run:
```bash
npm update -g repomix
```

As always, we appreciate your feedback and contributions to make Repomix even better! If you encounter any issues or have suggestions regarding this new feature, please let us know through our GitHub issues.
````

v0.1.36
````md
This release introduces a new configuration option that allows users to control the security check feature, providing more flexibility in how Repomix handles sensitive information detection.

## What's New

### Configurable Security Check (#74, #75)

- Added new configuration option `security.enableSecurityCheck` (default: `true`)
  - Users can now disable the security check when needed, such as when working with cryptographic libraries or known false positives

## How to Use

To **disable** the security check, add the following to your `repomix.config.json`:

```json
{
  "security": {
    "enableSecurityCheck": false
  }
}
```

**Note:** Disabling the security check may expose sensitive information. Use this option with caution and only when necessary.

---

To update, simply run:
```bash
npm update -g repomix
```

As always, we appreciate your feedback and contributions to make Repomix even better! If you encounter any issues or have suggestions regarding this new feature, please let us know through our GitHub issues.
````

v0.1.32
````md
This release focuses on improving performance and user experience, particularly when processing large repositories.

## Bug Fixes
###  Fixed an issue where the application appeared to hang (#63, #65)

- Fixed an issue where the application appeared to hang during the security check process on large repositories.
- Reduced the impact on the event loop to prevent hanging when processing a large number of files.
- Implemented more frequent console updates during file processing and security checks.

---
To update, simply run:
```
npm update -g repomix
```

As always, we appreciate your feedback and contributions to make Repomix even better!
````

</instruction>
